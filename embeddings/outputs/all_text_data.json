[
    "5.1.  Functions #",
    "Functions are called subroutines, modules or procedures in other programming languages.",
    "They are a sequence of instructions that can be called by name in a code – we will see how shortly.",
    "Functions are useful for decomposing a problem into smaller sub-problems.",
    "This is referred to as modular programming .",
    "The modularity concept is the extent to which a program can be divided into smaller pieces.",
    "5.1.1.  Why functions? #",
    "Decomposing a solution into functions is helpful because:",
    "Improve collaboration.",
    "We can divide work among different programmers.",
    "Each programmer can work on a different function, and we later assemble/integrate the functions to solve the bigger problem.",
    "Improve collaboration.",
    "We can divide work among different programmers.",
    "Each programmer can work on a different function, and we later assemble/integrate the functions to solve the bigger problem.",
    "Improve reusability.",
    "You do not need to re-implement the same code over and over again.",
    "If you have a function that you use in multiple places, you can just call the function instead of writing the same code over and over again.",
    "For example, printf() , scanf() , rand() , rint() , pow() , etc.",
    "are all functions that are already implemented in C.",
    "You can use them in your programs without having to write the code for them.",
    "Improve reusability.",
    "You do not need to re-implement the same code over and over again.",
    "If you have a function that you use in multiple places, you can just call the function instead of writing the same code over and over again.",
    "For example, printf() , scanf() , rand() , rint() , pow() , etc.",
    "are all functions that are already implemented in C.",
    "You can use them in your programs without having to write the code for them.",
    "Less code means less bugs.",
    "Since you are reusing code and writing fewer lines of code, you are less likely to make mistakes.",
    "Less code means less bugs.",
    "Since you are reusing code and writing fewer lines of code, you are less likely to make mistakes.",
    "Easier testing.",
    "Since sub-problems will be isolated into different functions.",
    "We can test each function individually.",
    "This makes debugging easier.",
    "Easier testing.",
    "Since sub-problems will be isolated into different functions.",
    "We can test each function individually.",
    "This makes debugging easier.",
    "5.1.2.  Example where modular programming is truly useful #",
    "Recall the example Print a 2 dimensional pattern , where we had to print the following pattern:",
    "We decomposed the solution into two sub-problems:",
    "Printing the lines",
    "Printing the stars in each line",
    "Printing the lines is a bigger problem that involves printing the stars in each line.",
    "Creating a function for each problem makes it easier to think clearly about the solution.",
    "For example, to print a particular number of stars, we can use the following function printStars :",
    "Fig. 5.1  Function implementation that prints a number of stars. #",
    "The return type of our function is void .",
    "In this function, we do not return any values to the caller function.",
    "We will see how to return a value in the next section.",
    "The return type of our function is void .",
    "In this function, we do not return any values to the caller function.",
    "We will see how to return a value in the next section.",
    "The function name is printStars .",
    "This name will be used to call the function to execute its instructions.",
    "The function name is printStars .",
    "This name will be used to call the function to execute its instructions.",
    "The type of the input parameter is int .",
    "The variable name of the input parameter is numOfStars .",
    "This is the same variable name used within the function.",
    "The variable name of the input parameter is numOfStars .",
    "This is the same variable name used within the function.",
    "The body of the function has instructions to print one line of numOfStars stars.",
    "And to print the lines, we can make use of printStars function in another printPattern function as follows:",
    "Fig. 5.2  Function implementation of  printPattern  that prints a pattern by calling  printStars . #",
    "In printPattern function, we have a loop that increments the row number from \\(1\\) to numOfRows .",
    "For each row, it calls printStars that prints a number of stars equal to row .",
    "In printPattern function, we have a loop that increments the row number from \\(1\\) to numOfRows .",
    "For each row, it calls printStars that prints a number of stars equal to row .",
    "To call printStars that does not return a value, it is enough to write its name and the name of the variable to send its value, as printStars(row); .",
    "The value of row will be copied to numOfStars in printStars function.",
    "To call printStars that does not return a value, it is enough to write its name and the name of the variable to send its value, as printStars(row); .",
    "The value of row will be copied to numOfStars in printStars function.",
    "The entire code in use will be as follows.",
    "Download print-pattern-functions.c if you want to run the program yourself.",
    "In lines \\(4\\) – \\(6\\) , we wrote down the function prototypes of printStars and printPattern .",
    "A function prototype tells the compiler three main features of a function:",
    "The type and the number of input parameters, e.g. in void printStars(int numOfStars); , we know int is the type of the only input parameter",
    "The function name, e.g. printStars",
    "The return type of the function, e.g. void since both of other functions do not return anything",
    "You may or may not include the variable names as shown in the following figure.",
    "Fig. 5.3  Two ways to write a function prototype. #",
    "In line \\(12\\) , we call printPattern function passing the value of line variable to the variable numOfRows .",
    "printPattern ultimately calls printStars which prints the appropriate number of stars for each line.",
    "5.1.3.  Order of execution with functions #",
    "The following figure shows the order of executing a program with functions.",
    "Fig. 5.4  Steps taken to execute a program with functions. #",
    "Step 1 : instructions in the main function are the first to be executed.",
    "Step 2 : The main function called printPattern function.",
    "The value of lines is to be “passed” to printPattern .",
    "Step 3 : printPattern function will catch the passed value of lines in a new variable named numOfRows .",
    "Step 4 : printPattern function calls printStars function.",
    "The value of row is to be “passed” to printStars .",
    "Step 5 : printStars function will catch the passed value of row in a new variable named numOfStars .",
    "Step 6 : printStars function body will print a line of stars equal to numOfStars .",
    "Step 7 : Once printStars prints a line of stars, it returns to exactly where it was initially called, printPattern .",
    "printPattern will continue executing its loop, and call printStars again if row in printPattern remains less than or equal numOfRows .",
    "Steps \\(4\\) to \\(7\\) will continue until the loop in printPattern exits.",
    "Step 8 : When printPattern finishes printing the pattern, it returns to where it was initially called in the main function.",
    "The next step in main is return 0; where the program exits.",
    "5.1.4.  Another way to write code with functions (but not favorable) #",
    "There is another way to write your program when it has functions, that does not involve writing the function prototypes.",
    "It requires that you implement all the functions before the main function, instead of including the function prototypes.",
    "The following code shows the code above in this new way.",
    "Function prototypes are replaced with the function implementations, that were at the end of the program.",
    "You should not have function implementations at the end of the program in this case.",
    "Why is this method not favorable?",
    "The compiler compiles your code one line at a time from top to bottom.",
    "The compiler should have observed the function prototype or function implementation before they are called in any functions, including the the main function.",
    "For example, in the previous code, if we switched the order of the function implementations of printStars and printPattern , it will cause an error at line \\(6\\) in the following code, because this is the first time printStars is observed by the compiler.",
    "The compiler did not see before line \\(6\\) any prototype or implementation of printStars , which is why it flags an error.",
    "This causes a compile-time error.",
    "Fig. 5.5  The order of function implementation can cause an issue if no caution is taken! #",
    "However, if you were to write the function prototypes before the main, then the order of the function implementations after the main function does not matter.",
    "There is no caution that is required.",
    "Quiz",
    "0 Questions",
    "5.3.  Variable scope #",
    "In the previous section, we found that we created a new variable n in factorial function to take in the value of number from the main function.",
    "This is because we cannot access number inside factorial function.",
    "Likewise, n cannot be accessed in the main function.",
    "We say the scope of number is within the main function, and the scope of n is factorial function.",
    "This is similar to what we discussed in for loops in Scope of the loop variable .",
    "We said that the following would cause a compile-time error, since count is declared inside the loop and is undefined outside the loop.",
    "The scope of count is only in the for loop.",
    "Code snippet causing compile-time error at line \\(4\\)",
    "Similarly, variables inside a function cannot be accessed outside a function, even if they have similar names.",
    "For example, in the following code, the main function has a variable n , and it calls divideByTwo function by transferring the value of n .",
    "This is called “call by value”, as we call to transfer only the value of n .",
    "Inside divideByTwo function, another variable n is created, that is totally different from n in the main function.",
    "Download divideByTwo.c if you want to run the program yourself.",
    "To understand how variables from another function cannot be accessed and how “call by value” works under the hood, we look into how the variables of each function is stored in the main memory.",
    "The following video will execute the program one line at a time, and explain what happens in the main memory.",
    "Quiz",
    "0 Questions",
    "5.5.  Exercises #",
    "Many of these exercises are taken from past exams of APS105 Computer Fundamentals courses at University of Toronto.",
    "The solutions are provided in the answer boxes.",
    "Headings in this page classify the exercises into different categories: [Easy] , [Intermediate] , and [Challenging] .",
    "I suggest you start by easy exercises and work your way up to the challenging ones.",
    "Question 5 in Winter 2020 Midterm Exam [Easy]",
    "Write the output of the following program.",
    "Question 4 in Winter 2022 Midterm Exam[Easy]",
    "The following function is called with three distinct characters and returns the middle character, e.g., if ‘a’, ‘b’, and ‘c’ is passed as arguments to the function, it returns ‘b’.",
    "Rewrite this function such that it only uses one return and one if statement.",
    "Question 11 in Fall 2015 Midterm Exam [Intermediate]",
    "Write a C function reverseDigits , the prototype of which is given below, that takes an integer argument value, and returns an integer with its digits reversed.",
    "For example, if the argument is 1234 , the function will return 4321 .",
    "Question 12 in Fall 2015 Midterm Exam [Challenging]",
    "In 1706, John Machin, then a professor in London UK, devised a formula for calculating \\(\\pi\\) :",
    "\\(\\frac{\\pi}{4} = 4 \\cdot \\arctan(\\frac{1}{5}) − \\arctan(\\frac{1}{239})\\)",
    "where the arctan values can be calculated using the following formula:",
    "\\(\\arctan(x) = x − \\frac{x^3}{3} + \\frac{x^5}{5} - \\frac{x^7}{7} + \\frac{x^9}{9} \\dots - \\frac{x^{299}}{299} + \\frac{x^{301}}{301}\\)",
    "Write a C program that calculates and prints \\(\\pi\\) using this method, printing \\(10\\) digits after the decimal point.",
    "You must define your own function called arctan to compute the arctan values, and you are not allowed to use the atan function from the math library.",
    "When your program is run, its output should be (up to 10 decimal places):",
    "Question 9 in Winter 2020 Midterm Exam [Challenging]",
    "A pythagorean triple is a triple of integers \\((x, y, z)\\) such that \\(x^2 + y^2 = z^2\\) .",
    "Complete this function that takes a single positive integer x as an argument and prints three positive integer values x , y and z such that:",
    "\\(x^2 + y^2 = z^2\\)",
    "\\(y > 0\\) and \\(y < 100\\)",
    "\\(y < z\\) .",
    "If there is no triple that satisfies these conditions print “no solution exists.” Start with the following definition:",
    "An easier solution",
    "Solution given in marking scheme",
    "5.  Functions #",
    "In previous chapters, in every worked exercise, we discussed how to solve a problem by decomposing the solution into steps.",
    "Sometimes, we decompose the problem into smaller sub-problems that can be decomposed into further steps.",
    "In this chapter, we will discuss how to write a sequence of instructions as a function to consider it as a step by itself.",
    "We will discuss how to use functions for a sub-problem to solve “the” problem.",
    "Think of assembling a table.",
    "It is difficult to think of building the table from scratch.",
    "You bought the table not assembled and you were given instructions on how to assemble it.",
    "We can think of each step in the assembling manual as a function.",
    "5.4.  Pass more values to a function #",
    "In this section, we will solve an exercise were we need to pass to a function three input parameters and return one.",
    "5.4.1.  Worked exercise #",
    "This exercise is a modified version of Question 7 in 2019 Midterm Exam.",
    "Write a program that takes in three integers from the user.",
    "The main function should call a function named median to find the median among these integers, which is the number at the middle.",
    "In particular, your function should take \\(3\\) int-type parameters and return the value of the number at the middle.",
    "For example, with integers \\(2\\) , \\(7\\) , and \\(5\\) as input, the function returns 5; with integers \\(6\\) , \\(4\\) , and \\(6\\) as input, the function returns \\(6\\) .",
    "Step 1: Toy example.",
    "As the problem statement says, we can use x \\(= 2\\) , y \\(= 7\\) , and z \\(= 5\\) as a toy example.",
    "Step 2: Think of a solution! There are many ways to think of a solution.",
    "I will discuss one way.",
    "If we can compare x with y , regardless of who is greater, both can be the median.",
    "We cannot eliminate one variable by one comparison.",
    "Hence, we need to compare x with y and z in one statement.",
    "For example, if x is greater than y and smaller than z , x is median.",
    "But this is not the only case that makes x median.",
    "x can be greater than z and smaller than y and still be the median.",
    "What makes x median is if it falls between y and z .",
    "Similarly, for y and z to be the median, they have to fall in between the other two numbers.",
    "Fig. 5.8  Image showing all possible arrangements of three variables:  x ,  y  and  z . #",
    "Step 3: Decompose into steps.",
    "To decompose the problem into steps.",
    "The first step is to take input numbers from the user, and the next step is to check which number is the median.",
    "The latter can be written in a function as specified by the question.",
    "In that function, we will do the following steps",
    "Check if x is the median: does it fall between y and z ?",
    "Store x in a variable or return it if it is the median.",
    "Check if y is the median: does it fall between x and z ?",
    "Store y in a variable or return it if it is the median.",
    "Check if z is the median: does it fall between x and y ?",
    "Store z in a variable or return it if it is the median.",
    "The last step is to print this median.",
    "Step 4: Write the code.",
    "When writing a program that is modular, i.e. uses functions.",
    "It is a good idea to start typing the function first.",
    "As required in the question, the function takes three int values and return an int having the value of the median.",
    "Code snippet",
    "In line 2, (x >= z && x <= y) checks the first possibility in the Median Possibilities figure above.",
    "This condition is OR-ed with the second possibility that makes x a median (x >= y && x <= z) .",
    "In line \\(3\\) , the function will return the value of x if it is the median.",
    "This means further lines will never be executed.",
    "The same will happen if y is median in line \\(5\\) and if z is median in line \\(7\\) .",
    "However, if your function is quite long and has several return s, it will be difficult to trace how many return s and debug the function if it has bugs.",
    "Therefore, it is a good practice to have only one single return in a function.",
    "In our median function, we can re-write it by saving the value of the median in a variable and at the end of the function return the value of that variable.",
    "For example, we have one return in line 9 in the following code.",
    "Code snippet",
    "What’s left now is the main function that takes input from the user, calls median function and prints the median.",
    "Download median-function.c if you want to run the program yourself.",
    "In line 3, there was no need to write the variable names of the three int arguments.",
    "Their types are enough.",
    "In line 9, median is called with a , b and c , and in median the variables will be received in the same order, i.e. the value of a in main will be passed to x , b to y and c to z .",
    "Step 5: Test and debug the code.",
    "You should make sure your code works with different input ranges, i.e. positive, negative and zero.",
    "Although you may believe it will work with all numbers, testing is the only way to make sure.",
    "So, I will test with all negative numbers ( \\(-105\\) \\(-28\\) \\(-73\\) ), some negative and positive and zero ( \\(0\\) \\(-101\\) \\(98\\) ), and many more.",
    "The code given should work in all these cases.",
    "If your program does not work, and it has many lines of code and many functions, it is difficult to find the errors.",
    "It is easier and faster to test each function separately.",
    "This method in testing is called isolation , where each function is tested in isolation.",
    "If I were to test the function median alone, I will copy it in another .c file and write a simple main function, where I call median with pre-set values.",
    "For example, in the following code we test median with several inputs.",
    "It is easier in this case to test median on many inputs, use the debugger without having to input numbers in the console, and quickly find which inputs cause issues.",
    "Download median-test.c if you want to run the program yourself.",
    "Code for testing only",
    "In lines \\(6\\) – \\(8\\) , we test median with three different inputs in the same code.",
    "Step 6: Debug the code.",
    "If the desired output was not produced as you test in isolation, using the debugger will easily help you find the bug in your median function.",
    "Only if we are confident that median function is correct, now we can integrate it with the main function where we take input from the user or with other functions (if there are any).",
    "Quiz",
    "0 Questions",
    "5.2.  Communicate from a function #",
    "In the previous section, we discussed an example where functions helped in dividing our problem into sub-problems.",
    "Functions make it easy to think of problems.",
    "The functions we discussed in the previous section did not return any information back to the caller function.",
    "In this section, we discuss problems that require returning a value to the caller function.",
    "5.2.1.  Return a non-void variable type #",
    "For example, we want to write a function that calculates the factorial of a number.",
    "The function is to take an input parameter \\(n\\) , calculate the value of \\(n \\times (n -1) \\times (n-2) ....",
    "3 \\times 2 \\times 1\\) , and returns it to the calling function.",
    "The following figure shows the code along with the order of execution.",
    "Download factorial.c if you want to run the program yourself.",
    "Fig. 5.6  Order of execution in a code that gets the factorial. #",
    "As always, the execution starts from the main function.",
    "factorial function takes in 4 as an input.",
    "The variable n in factorial function is assigned the value of 4.",
    "The function factorial returns the value of 24 to the caller function, which is the main function.",
    "factorial(number) now is evaluated as 24.",
    "The value of result is set to the evaluated value of factorial(number) , which is 24.",
    "5.2.2.  Summary of syntax of a program with functions #",
    "To summarize the syntax of a C program that has functions, in the following figure you will find the skeleton of a C program that has a non-void and void return function.",
    "Fig. 5.7  Basic skeleton of a program that uses functions. #",
    "The order of the parameters passed to a function MUST be the same as the order of the parameters in the header of the function.",
    "Quiz",
    "0 Questions",
    "13.4.  Delete nodes in a linked list #",
    "In the previous section, we have been dynamically allocating memory for nodes and never deleting them.",
    "This is a problem because we are wasting memory.",
    "We can fix this by deleting nodes when we are done with them.",
    "In this section, we will implement functions that help us delete nodes in a linked list.",
    "Generally , to delete a node, we need to do the following:",
    "Find the node we want to delete",
    "Fix the links before and after the node we want to delete",
    "free the dynamically allocated memory for the node we want to delete",
    "(if necessary) Update the head of the list",
    "13.4.1.  Deleting a node at the beginning/front of the list #",
    "To delete a node at the beginning of the list, we need to do the following:",
    "Declare a pointer to the second node in the linked list",
    "free the memory allocated for the first node pointed to by the head pointer of the list",
    "Update the head pointer to point to the second node in the list",
    "To implement this function, we don’t need to return anything, and we only pass the LinkedList* .",
    "We can do the following:",
    "We check for if the list is empty or not, because we may not have any nodes in the list.",
    "This will cause a segmentation fault if we access list->head->next when the list is empty.",
    "If the list is not empty, we can safely delete the first node in the list.",
    "Otherwise, we do nothing.",
    "The function above works if we have only one node.",
    "newHead will have NULL and eventually list->head will be set to newHead which is NULL .",
    "This will cause the list to be empty.",
    "13.4.2.  Deleting a node at the end of the list #",
    "To delete a node at the end of the list, we need to do the following:",
    "Find the second to last node in the list",
    "free the memory allocated for the last node in the list",
    "Set the next of the second to last node to NULL",
    "The following figure illustrates the steps above:",
    "Fig. 13.6  Illustration of deleting the last node in a linked list.  Step 1  is to find the second last node.  Step 2  is to free the space allocated for the last node.  Step 3  is to set the next of the second last node to  NULL  making it the last node. #",
    "To implement this function, we don’t need to return anything, and we only pass the LinkedList* .",
    "To identify the last node, we previously said that if current->next == NULL , then current is pointing at the last node.",
    "If current->next->next == NULL , then current is pointing at the second last node.",
    "We can do the following to delete the last node in the list:",
    "However, if the code above can work if we have two nodes in the list, otherwise current->next->next will cause a segmentation fault.",
    "We can fix this by checking if the list is empty or if it has one node before checking current->next->next .",
    "If the list is empty, we can return as there is nothing to delete.",
    "If the list has one node, we can delete that one node by calling deleteFront(list) .",
    "The following code implements the above logic.",
    "Download deleteBack.c if you want to play with the code.",
    "In lines \\(2 - 5\\) , we check if the list is empty.",
    "If it is, we return as there is nothing to delete.",
    "In lines \\(7 - 11\\) , we check if the list has one node.",
    "If it does, we call deleteFront(list) to delete the only node in the list.",
    "13.4.3.  Deleting all nodes in the linked list #",
    "To delete all nodes in the linked list, we need to call deleteFront (or deleteBack ) until the list is empty.",
    "We implement a function named deleteAllNodes that deletes all nodes and returns the number of nodes deleted.",
    "It takes LinkedList* as a parameter.",
    "We implement it as follows:",
    "13.4.4.  Delete the first matching node with  data  =  searchVal #",
    "To delete a node with a specific value, e.g , \\(3\\) we need to do the following:",
    "Find the node with the specified data",
    "Link the previous node to the next node after the node with specified data",
    "free the space dynamically allocated for the node with the specified data",
    "The following figure illustrates the steps above:",
    "To find the node with the specified data, we can traverse the linked list using a Node* named current .",
    "If current stops at the node with the specified data, we can delete it, but we won’t be able to go back to the previous node, and link it’s next to the next of the node we want to delete.",
    "To solve this problem, we can make current stop at the node before the node we want to delete.",
    "Given that current stopped at the node before the node we want to delete, and we were to delete the current->next node, we won’t be able to access current->next->next , since current->next is freed.",
    "To solve this problem, we can store the address of the next node after current in a Node* named temp .",
    "Then, first link current->next to temp->next , then delete the node pointed to by temp .",
    "We can’t link current->next to temp->next if we deleted/freed temp first, since we won’t be able to access the next of the freed node temp .",
    "This means that the order of steps is crucial.",
    "We should do the steps in the following order:",
    "Store the address of current->next in temp",
    "Connect current->next to temp->next",
    "free the node pointed to by temp",
    "The steps are illustrated in the following figure:",
    "We can write a function named deleteFirstMatch that takes the LinkedList* and the searchVal as parameters to implement the steps above.",
    "It returns true if it found the node and deleted it, and false otherwise.",
    "A draft is shown below:",
    "Special case 1: What if the node was not found?",
    "If the node was not found, there is a possibility of segmentation fault when checking the while loop condition.",
    "current will traverse the list till the end current->next == NULL , and checking current->next->data will cause a segmentation fault.",
    "To solve this, we can check current->next != NULL before checking the data in the next node after current, as we show in line \\(5\\) .",
    "We exit the loop if current is pointing to the node before the node to be deleted, or if current is pointing at the last node and the node with searchVal is not found.",
    "In the first case, current->next is not NULL , and current->next->data is equal to searchVal , we can delete the node at current->next as in lines \\(11\\) to \\(17\\) .",
    "In the second case, current->next is NULL , the node was not found, and we should return false as in line \\(20\\) to indicate that the node was not found.",
    "Special case 2: What if the node to be deleted is the first node?",
    "The present code starts checking data of nodes starting from the second node.",
    "If the node to be deleted is the first node, we can call deleteFront(list) to delete it.",
    "We show this in lines \\(2\\) to \\(6\\) .",
    "Special case 3: What if the linked list is empty?",
    "If the linked list is empty, there is nothing to delete, and we can return false as we show in lines \\(2\\) to \\(5\\) .",
    "Special case 4: What if the node to be deleted is the last node?",
    "current will point to the second last node before the node to be deleted.",
    "In this case, our code will perfectly work to delete the last node by freeing temp and setting current->next to NULL .",
    "Download deleteFirstMatch.c if you want to play with the code we developed for deleteFirstMatch function.",
    "13.4.5.  Delete all matching nodes with  data  =  searchVal #",
    "In the previous section, we deleted only the first matching node in a linked list.",
    "In this section, we develop a function that deletes all the nodes in a linked list that have data equal to searchVal .",
    "The steps to do so include:",
    "Delete first match of searchVal using deleteFirstMatch function",
    "Repeat 1 till there is no more matches",
    "How can we check for the condition of no more matches?",
    "We can use a while loop that checks if deleteFirstMatch returns true or false .",
    "If it returns true , it means that a node was deleted, and we should repeat the process.",
    "If it returns false , it means that no node was deleted, and we should exit the loop.",
    "In the body of the loop, we can increment a counter than counts the number of matches deleted.",
    "The following code shows the implementation of deleteAllMatches function.",
    "Quiz",
    "0 Questions",
    "13.3.  Insert nodes into a linked list #",
    "In this section, we will discuss how to insert nodes into a linked list.",
    "We will discuss how to insert a node at the beginning of the list, at the end of the list, and in the middle of the list.",
    "13.3.1.  Preliminaries #",
    "Before we implement any functions, let’s recap the data structure we will be using.",
    "We will be using the following Node structure:",
    "13.3.2.  Create a node in the linked list #",
    "In the previous section, we discussed how to create a linked list.",
    "Before inserting any node, we had to dynamically allocate it first.",
    "We can do so by using the malloc function.",
    "The malloc function takes in the size of the memory space we want to allocate, and returns a pointer to the memory space.",
    "We can then assign the pointer to a pointer variable of type Node .",
    "malloc returning NULL",
    "If malloc returns NULL , it means that it was unable to allocate memory.",
    "This can happen if the program is running out of memory.",
    "Hence, we should check if the pointer returned from malloc is NULL before we use it.",
    "If it is NULL , we should return NULL from the function.",
    "If we use it anyway, we will get a segmentation fault.",
    "Segmentation fault is a common error that occurs when we try to access memory that we are not allowed to access.",
    "This can happen if we try to access memory that is not allocated to us, or if we try to access memory that has been freed.",
    "For example, if newNode is NULL , and we do newNode->data = 1 , it will cause segmentation fault, since newNode is not pointing to any memory space.",
    "We can use createNode to form the following linked list:",
    "Download the following code createNode-example.c if you want to play with it.",
    "In line \\(14\\) , we call createNode which returns a pointer to a newly dynamically allocated Node with data set to 1 .",
    "We then assign the address of this Node to head.",
    "In line \\(16\\) , we call createNode again, which returns a pointer to a newly dynamically allocated Node with data set to 2 .",
    "The mistake is to set the address of the newly allocated Node to head .",
    "The problem is that no other pointer will have the address of the Node with data set to 1 .",
    "This is a memory leak, since we can never access that previously allocated node.",
    "Instead, in line \\(17\\) , we can call createNode again, which returns a pointer to a newly dynamically allocated Node with data set to 2 .",
    "We then set the next pointer of the head to point to this newly allocated Node , e.g. head->next = createNode(2); .",
    "This way, we link the two nodes together, where head is pointing to the first node, and head->next is pointing to the second node.",
    "In line \\(19\\) , we call createNode again, which returns a pointer to a newly dynamically allocated Node with data set to 4 .",
    "We then set the next pointer of the second node head->next to point to this newly allocated Node , e.g. head->next->next = createNode(4); .",
    "This way, we link the three nodes together, where head is pointing to the first node, head->next is pointing to the second node, and head->next->next is pointing to the third node.",
    "In line \\(20\\) , we call createNode again, and set its return value to head->next->next->next to link the four nodes together.",
    "Note: Of course the above code is missing the free statements to free the memory allocated to the nodes.",
    "We will discuss this in the next section.",
    "Too many ->next",
    "It can be confusing to keep track of ->next numbers in a statement.",
    "Instead, we use different functions to insert nodes at the beginning, end, and middle of the list.",
    "13.3.3.  Inserting a node at the beginning/front of the list #",
    "To insert a node at the beginning of the list, we need to create a new node, and set its next pointer to point to the current head.",
    "We then set the head to point to the newly created node.",
    "The steps are illustrated in the following figure.",
    "We can implement a function to insert a node at the front of the list.",
    "The function can take the head of the list and the data of the node to be inserted as parameters.",
    "The function will return a bool that is true if the node was successfully inserted, false otherwise.",
    "The following figure illustrates the function and draws the changes to the linked list at each step.",
    "Errorneous Code",
    "Issues with passing head by value",
    "In the above code, we pass head by value, and head becomes a local variable holding the address of the first node of the list in insertAtFront function.",
    "Even if we change the value of head in insertAtFront , it will only change in insertAtFront function.",
    "It will not change the value of head in main function.",
    "Hence, the linked list will not be changed.",
    "The following figure shows how head gets changed in insertAtFront function, but not the main function.",
    "13.3.3.1.  Solution 1: Pass pointer to head #",
    "To fix this issue, we can pass a pointer to head to insertAtFront function.",
    "The following figure shows how we can pass head as a pointer.",
    "In line \\(1\\) , we receive a pointer to Node* head variable.",
    "This is a double pointer, hence the type is Node** .",
    "We can use this pointer to change the value of head in main function.",
    "In line \\(6\\) , we set temp->next to point to the current head.",
    "The current head is pointed to by Node** headPtr .",
    "We can dereference headPtr to get to the current head in the main function.",
    "Hence, we set temp->next = *headPtr; .",
    "In line \\(7\\) , we change the head in main function to point to the newly created node pointed to by temp .",
    "We can dereference headPtr to get to the current head in the main function.",
    "Hence, we set *headPtr = temp; .",
    "In line \\(15\\) , we call insertAtFront function to insert a node with data set to 0 at the beginning of the list.",
    "We pass the address of head to insertAtFront function as &head .",
    "Hence, headPtr in insertAtFront function will point to head in main function.",
    "We can then change the value of head in main function.",
    "The following figure illustrated the value of variables in main function before and after calling insertAtFront function.",
    "13.3.3.2.  Solution 2: Create a new data structure #",
    "Since double pointers can be confusing to deal with, we can create a new data structure to hold the head of the list.",
    "Then, pass a pointer to the data structure if we want to change the head.",
    "Let’s first discuss how does the new data structure look like.",
    "It looks as follows:",
    "We can then create a new data structure in main function.",
    "The following figure shows how we can create a new data structure in main function.",
    "We can then pass a pointer to the data structure LinkedList to the insertAtFront function.",
    "This serves as a pointer to the Node* head pointer holding the address of the first node in the list.",
    "The following figure shows how we can pass a pointer to the data structure LinkedList to the insertAtFront function.",
    "Code snippet",
    "13.3.4.  Print the linked list to check if the node was inserted #",
    "We can print the linked list to check if the node was inserted.",
    "We start with a pointer named Node* current pointing at the first node in the list.",
    "Then print current->data , and traverse to the next node by setting current to current->next .",
    "This can continue till current is NULL .",
    "This is when current reached the end of the list.",
    "The following figure shows how we can traverse the list to print the linked list.",
    "To implement the function that prints the data in the linked list, we can take LinkedList *list as input, and return void , since we are just printing.",
    "Code snippet",
    "To fully test the function, we can create a linked list with 3 nodes, and print the linked list.",
    "The following code shows how we can create a linked list with 3 nodes, and print the linked list.",
    "Download insertAtFront.c if you want to play with the code.",
    "13.3.5.  Insert a node at the end of the linked list #",
    "If we want to insert a node at the end of the linked list, we have to traverse till the last node, and insert the new node at the next of the last node.",
    "The following figure shows how we can insert a node at the end of the linked list.",
    "To implement the function that inserts a node with data = value at the end of the linked list, we can take LinkedList *list and int value as input, and return bool , which is true if the node was inserted successfully, and false otherwise.",
    "In the function, we will traverse the linked list with a Node* pointer named current and stop when current->next is equal to NULL .",
    "This is when current reached the end of the list.",
    "Then, we can insert the new node at the next of current .",
    "The following figure shows how we can implement the function that inserts a node at the end of the linked list.",
    "Missing a case: Code snippet",
    "However, the figure above is missing one case.",
    "What if the linked list is empty?",
    "current will be NULL , and we will get segmentation fault if we do current->next .",
    "Hence, before checking the next of current , if current was NULL , we just make list->head point to that new node.",
    "The following code shows how we can handle the case when the linked list is empty.",
    "In line \\(8\\) to \\(12\\) , we handle the case if the list was empty.",
    "If the list was empty, we just make list->head point to the new node.",
    "13.3.6.  Insert a node into an ordered linked list #",
    "To implement the function that inserts a node with data = value into an ordered linked list, we can take LinkedList *list and int value as input, and return bool , which is true if the node with data equal value was inserted successfully, and false otherwise.",
    "We are given a list sorted in ascending order according to the value of data .",
    "If we want to insert a node into an ordered linked list, we have to traverse the linked list till we find the node that has data greater than the data of the new node.",
    "Then, we can insert the new node before that node.",
    "In the function, we will traverse the linked list with a Node* pointer named current .",
    "We should stop at the node before inserting the new node.",
    "This is when current->next->data is greater than value .",
    "Then, we can insert the new node between current and current->next .",
    "We cannot stop current at the node with data > value , because we will lose access to the previous node after which we should insert our node.",
    "The following figure shows how we can traverse the linked list with the pointer current to stop at the node after which our new node will be inserted.",
    "Fig. 13.2  When traversing the linked list, we need to stop just before where we want to insert our node. The following figure shows where should we stop, when we insert a node between two nodes. #",
    "When current is pointing to the node after which we will insert the new node, we can now (i) link the next of new node to the next of current : newNode->next = current -> next , and (ii) link the next of current to the newNode: current->next = newNode; .",
    "Obviously, we need to first link the next of new node to the next of current , because we do not want to lose access to the node after current.",
    "Fig. 13.3  When  current  is pointing to the node after which we will insert the node, we can now (i) link the next of new node to the next of  current :  newNode->next   =   current   ->   next , and (ii) link the next of current to the newNode:  current->next   =   newNode; . #",
    "The following code shows how we can implement the function that inserts a node between 2 nodes into an ordered linked list.",
    "However, a segmentation fault would happen if we try accessing current->next->data when current is NULL or when current->next is NULL .",
    "This can happen in several cases:",
    "current will be NULL , when the linked list is empty and we will get segmentation fault if we do current->next .",
    "current->next will be NULL , when current is pointing at the last node in the linked list.",
    "This happens when current->next->data was always < value , and current is now pointing to the last node.",
    "We will get segmentation fault if we do current->next->data .",
    "current->next will be NULL , when current is pointing at the last node in the linked list.",
    "This happens when current->next->data was always < value , and current is now pointing to the last node.",
    "We will get segmentation fault if we do current->next->data .",
    "current->next will be NULL , when current is pointing at the first node and only node in the list.",
    "Special case 1: The linked list is empty.",
    "Before checking the condition of the while loop, which is current->next->data < value , we need to check if current is NULL .",
    "If current is NULL , we just make orderedList->head point to that new node.",
    "We need to create the node first and point to it by newNode , then make orderedList->head = newNode .",
    "We return true is the node is successfully created, false otherwise.",
    "This all can be made by calling insertAtFront or insertAtBack , since the list is empty.",
    "The following code shows how we can handle the case when the linked list is empty.",
    "Special case 2: The value of the new node is greater than the value of the last node in the linked list.",
    "This will make the present implementation in lines \\(9\\) to \\(12\\) loop till current points to the last node in the linked list.",
    "After that if we check the condition of the loop current->next->data , we get a segmentation fault since current->next is NULL .",
    "We can handle this case by checking if current->next is NULL before checking current->next->data .",
    "If current->next is NULL , we just make current->next point to the newNode : current->next = newNode .",
    "This is after creating the node first and point to it by newNode .",
    "We return true if the node is successfully created, false otherwise.",
    "The following figure shows what we can do to insert the node at the tail of the linked list, when the value of the new node is greater than the value of the last node.",
    "Fig. 13.4  When  current->next  is  NULL , we just make  current->next  point to the new node. #",
    "We can do these steps by stopping the while loop when current->next is NULL .",
    "The following code shows how we can handle the case when the value of the new node is greater than the value of the last node in the linked list.",
    "In line \\(8\\) , we check if current->next != NULL first, then only if true , current->next->data < value will be evaluated.",
    "Remember this is because in lazy evaluation if the first condition in an && is false , the second condition will not be evaluated.",
    "This is because the whole expression will be false anyway.",
    "Hence, if current->next == NULL , we will exit the loop without checking current->next->data < value .",
    "Before line \\(24\\) , newNode->next is set to NULL , and current->next will be NULL if we exited the while loop because current->next == NULL .",
    "Hence, in line \\(24\\) , when we do newNode->next = current->next; we are not doing anything, since newNode->next is already NULL .",
    "This line is mainly essential when we insert a node between two nodes, not when we insert at the tail of the linked list.",
    "In line \\(25\\) , we set current->next = newNode; to link the last node in the linked list to the new node.",
    "current->next can be NULL also if we have only one node in the list.",
    "If the data of the new node is larger than the data of the only node, we should insert the new node at the tail of the linked list.",
    "Our current implementation makes this happen.",
    "However, if the data of the new node is smaller than the data of the only node, we should insert the new node at the front of the linked list.",
    "Our current implementation does not handle this case.",
    "We will handle this case in special case 3.",
    "Special case 3: The value of the new node is less than the value of the first node in the linked list.",
    "If our new node is to be inserted before the first node, because value is smaller than the data of the first node, our code does not cover that.",
    "Before checking if the second node has a value greater than the value we want to insert using current->next->data , we need to check the first node data .",
    "If the value of the first node was larger than the value we want to insert, then we need to insert the new node at front.",
    "The following figure shows what we need to do to handle this case.",
    "Fig. 13.5  When the value of the new node is less than the value of the first node in the linked list, we need to insert the new node at front. #",
    "We can do this by checking if current->data > value before checking current->next->data .",
    "If true , we call insertAtFront function.",
    "The following code shows how we can handle the case when the value of the new node is less than the value of the first node in the linked list.",
    "Download the following code insertIntoOrderedList.c if you want to play with the code.",
    "13.3.7.  Exercise: Find a node in the linked list #",
    "Let’s practice finding a node with a particular value into an ordered linked list.",
    "We need to implement a function that takes the value of the node we want to find, and returns a pointer to the node with that value.",
    "If the node is not found, we return NULL .",
    "We also need to pass a pointer to LinkedList as a parameter that has a pointer to the head of the linked list.",
    "The following figure shows the function we need to implement to find a node with a particular value in the linked list.",
    "Download findFirstNode.c if you want to play with the code.",
    "Quiz",
    "0 Questions",
    "13.5.  Exercises #",
    "Many of these exercises are taken from past exams of APS105 Computer Fundamentals courses at University of Toronto.",
    "The solutions are provided in the answer boxes.",
    "Headings in this page classify the exercises into different categories: [Easy] , [Intermediate] , and [Challenging] .",
    "I suggest you start by easy exercises and work your way up to the challenging ones.",
    "Question 5 in Winter 2018 Final Exam [Easy]",
    "Complete the following C program, designed to search for an int-type item, called key , in a linked list, pointed to by head .",
    "Question 6 in Winter 2016 Final Exam [Easy]",
    "Consider the following code, where head points to the head of a linked list:",
    "Complete the following C function that returns a pointer to the node that precedes (comes before) searchNode , if it is found in the linked list.",
    "If searchNode is not found or the linked list is empty, the function should return NULL .",
    "Read the function carefully: you may need to add code in several locations.",
    "Question 13 in Winter 2018 Final Exam [Intermediate]",
    "The following C structure is used to define each node in a linked list:",
    "Write a C function called printDuplicates that receives a pointer to the first node ( head ) of a linked list as a parameter.",
    "The function should find and print the duplicate integers in the linked list.",
    "For example, if the linked list contains the integers \\(6\\) , \\(3\\) , \\(3\\) , \\(6\\) , \\(7\\) , \\(4\\) , then the printDuplicates() function should print:",
    "Note: In your solution, you may assume that a given integer occurs at most twice in the linked list.",
    "Question 12 in Winter 2016 Final Exam [Intermediate]",
    "The following C structure is used to define each node in a linked list:",
    "Assume that nodes in the linked list are maintained in order of their values, such that the value stored in each node is greater than or equal to the value in predecessor nodes.",
    "Write a C function:",
    "that deletes any duplicate items in the linked list.",
    "The parameter head is a pointer to the head node of a linked list.",
    "Note that the head node of the linked list will remain unchanged after the deletions are made.",
    "For example, if before calling simplify, the linked list contains:",
    "then after calling the function, the list should contain:",
    "Question 14 in Winter 2017 Final Exam [Challenging]",
    "The following C structure is used to define each node in a linked list:",
    "Write a C function, called buildJoinedList , that takes two linked lists called firstList and secondList as its parameters, and returns a new list that joins the two lists, with secondList at the front.",
    "Both firstList and secondList are pointers to the first node of a linked list.",
    "The function should return a pointer to a new list that is dynamically allocated.",
    "Note that the existing linked lists pointed to by firstList and secondList must not be modified in any way.",
    "An example of how the function should work is as follows: if firstList points to a linked list containing nodes storing the numbers \\(1\\) , \\(2\\) , \\(3\\) , \\(4\\) , \\(5\\) and secondList containing the numbers \\(6\\) , \\(7\\) , \\(8\\) , \\(9\\) , \\(10\\) , then the newly created list returned by the buildJoinedList function should contain nodes storing the numbers \\(6\\) , \\(7\\) , \\(8\\) , \\(9\\) , \\(10\\) , \\(1\\) , \\(2\\) , \\(3\\) , \\(4\\) , \\(5\\) .",
    "Question 14 in Winter 2022 Final Exam [Challenging]",
    "The Node structure in a linked list has been defined as follows:",
    "The LinkedList structure has also been defined to contain the head of a linked list:",
    "Write a C function called reorder , the prototype of which is given below, that reorders the nodes in a linked list such that nodes with a value of \\(0\\) appear at the front of the linked list and nodes with any other integer value appear at the end of the linked list, while maintaining the original order of non-zero nodes.",
    "Example 1:",
    "Example 2:",
    "Note: You are not allowed to copy or modify the data member in any of the nodes in the linked list.",
    "However, you can modify the next pointer in the nodes.",
    "Solution 1:",
    "Solution 2:",
    "13.1.  Why linked lists? #",
    "Let’s say we want to store a list of numbers that can decrease or increase.",
    "We decide to store the list in an array as follows:",
    "To add a new number to the array between two numbers, we can move all numbers on the left by one place and place our new number as follows:",
    "To delete a number from the array, we can move all numbers on the right by one place to the left to overwrite the number to be deleted as follows:",
    "To insert more numbers that the array size can handle, we have to create a new array, move all numbers to the new array, and then add the new numbers to the array as follows:",
    "However, these operations are all inefficient .",
    "The operations require us to move all elements or some to the right or left by one place or to a new array.",
    "Arrays are not flexible when it comes to changing the array, because the array elements are stored contiguously – next to each other – in the memory.",
    "For example, in the case of adding an element in the array, it would have been easier if we can just add the element in the middle without moving the elements to the right.",
    "In the figure below, we broke down the elements of the array into pieces to form a list of numbers.",
    "Each piece is stored any where in the memory (not contiguously as in arrays).",
    "We can add a new element in the middle of two elements by just adding the new element in the middle of the two pieces.",
    "This is much easier than moving all elements to the right by one place.",
    "In order to maintain the order of the elements, we need to have links between them to determine the first, last (and everything in between) elements .",
    "For example, links between all pieces of our array can look as shown in the figure below.",
    "We can now add a new element in the middle of two elements by changing the links to include the new element as shown in the figure below.",
    "This is much easier than moving all elements to the right by one place.",
    "Fig. 13.1  Deleting an element from the list can be easily done by changing the links as shown in the figure below. This is much easier than moving all elements to the left by one place. #",
    "Extending the list can also be easy by adding a new list to the end of the current list as shown in the figure below.",
    "This is much easier than moving all elements to a new array.",
    "This list of numbers that we linked is called a linked list .",
    "It is more flexible to add new elements, delete elements, and extend the list than arrays.",
    "We will discuss how to implement a linked list in C in the next section.",
    "Quiz",
    "0 Questions",
    "13.  Linked Lists #",
    "In this chapter, we discuss an alternative to arrays.",
    "Arrays are not flexible when we need to add elements that requires a larger size than we already have, delete elements, or insert elements in the middle of the array.",
    "Linked lists are a data structure that can be used to solve these problems, and we discuss in this chapter how can we do so.",
    "We also discuss how to implement a linked list in C, and how to use it to solve problems.",
    "13.2.  Form a linked list #",
    "13.2.1.  What is a node in the list? #",
    "To form a linked list, we need to define the data type of the node , which is an element, in a linked list.",
    "Since each node in the linked list contains a value/data and a link to the next node, the node has to be a data structure that holds two different type members.",
    "To represent the value, we can use an int , and to represent the link, we can use a pointer to a node.",
    "We can define the node as follows:",
    "To make it easier, we will create an alias for struct node as Node .",
    "This way, we can use Node instead of struct node when we define a variable of type Node .",
    "13.2.2.  Create a node #",
    "In the following code, we declare a node variable named nodeFirst and set it’s data to 1 and next to NULL .",
    "NULL is a special address value at address 0 .",
    "It is used to indicate that there is no next node.",
    "Then, to add another node in the list, we declare another node variable named nodeSecond and set it’s data to 2 and next to NULL .",
    "We link the two nodes by getting the address of nodeSecond and assigning it to nodeFirst.next .",
    "(*nodeFirst.next).data is the data stored in the node pointed to by nodeFirst.next , which is the data member in nodeSecond .",
    "As observed in the figure above, we had to declare a node with a new variable name for every node in the list.",
    "This is not very efficient for two main reasons:",
    "For many Node variables in the list, we need many variable names.",
    "If we were to declare a Node variable in a function, then return from that function, Once a function returns, its memory space gets freed for usage by other functions.",
    "Hence, the Node variable will be destroyed.",
    "This is because the Node variable will be local and stored on the stack.",
    "If we were to declare a Node variable in a function, then return from that function, Once a function returns, its memory space gets freed for usage by other functions.",
    "Hence, the Node variable will be destroyed.",
    "This is because the Node variable will be local and stored on the stack.",
    "If we were to declare a Node variable, and then decide to delete it from the list, we will change the links in the linked list to remove it.",
    "However, the Node variable will still be in memory.",
    "If we were to declare a Node variable, and then decide to delete it from the list, we will change the links in the linked list to remove it.",
    "However, the Node variable will still be in memory.",
    "The solution to these problems is to always declare a Node dynamically on the heap for linked lists.",
    "13.2.3.  Form a linked list dynamically #",
    "To declare the nodes in a linked list dynamically, we need to follow some conventions.",
    "The first node should always be pointed by a pointer we will name head .",
    "The last node should always have NULL as its next value to identify it as the last node in the list.",
    "We can change the code in the above figure as follows to dynamically allocate nodes.",
    "In line \\(9\\) , we dynamically allocate a memory space on the heap of size sizeof(Node) bytes and assign the address of that space to newNode .",
    "We set the data and next of that Node to 1 and NULL respectively in lines \\(10\\) and \\(11\\) .",
    "In line \\(12\\) , we make head point to what newNode points to.",
    "head is a pointer to a Node , and newNode is a pointer to a Node .",
    "Hence, we can assign newNode to head .",
    "In line \\(13\\) , we dynamically allocate a memory space on the heap of size sizeof(Node) bytes and assign the address of that space to newNode .",
    "We set the data and next of that Node to 2 and NULL respectively in lines \\(14\\) and \\(15\\) .",
    "In line \\(16\\) , we make (*head).next point to what newNode points to.",
    "(*head).next is a pointer to a Node , and newNode is a pointer to a Node .",
    "This links the node with data 1 to the node with data 2 .",
    "In lines \\(17\\) and \\(18\\) , we print the data of the node pointed to by head and the data of the node pointed to by (*head).next respectively.",
    "To free the dynamic memory, we free all the space allocated on heap, which is pointed to by head and head->next .",
    "The order of free is critical.",
    "In case, newNode is not pointing to the second node, and we free(head) first, then head will be pointing to a freed memory space.",
    "Hence, we won’t be able to access the next in head and do free(head->next) .",
    "Therefore, we should first free(head->next) then free(head) .",
    "It is silly to have to repeat code/statements to add or delete nodes to a linked list.",
    "We can write a set of functions that allow us to do operations on a linked list.",
    "In the next few sections, we will be developing functions to help us implement these operations.",
    "Quiz",
    "0 Questions",
    "Coding style #",
    "Indentation and white spaces #",
    "Variable naming conventions #",
    "Comments #",
    "Braces #",
    "Consistency #",
    "Line length #",
    "Debugging #",
    "Appendix: Additional Resources #",
    "This chapter is mainly an appendix of additional resources that may make your life easier while you learn programming.",
    "Set up Visual Studio Code #",
    "There are two approaches to creating, compiling and running C programs you will write.",
    "The first approach is to use a separate tool to perform each of these actions — a text editor to create the program file, a compile command to compile it, and another command to run it.",
    "The second approach is to use an Integrated Development Environment (IDE), which allows you to perform many tasks from a single, usually graphical, application.",
    "VS Code is the most popular IDE among developers in 2023 1 .",
    "For Windows Users #",
    "You can follow along the following video for steps on setting up VS Code on Windows.",
    "Brief steps are also provided below.",
    "[Step 1] Go to code.visualstudio.com , and download VS Code.",
    "It will take seconds.",
    "[Step 2] Click on the downloaded file to open it.",
    "Accept the agreement, and press Next and Install when appropriate.",
    "Make sure to tick Create a Desktop icon .",
    "It takes a few more seconds.",
    "Then press Finish.",
    "[Step 3] Follow the following steps taken from steps 1 to 6 in https://www.msys2.org/ .",
    "Download the installer by clicking msys2.exe",
    "Run/double click on the downloaded file",
    "When asked about the installer folder, choose C:\\msys64",
    "When done, make sure “Run MSYS2 now” is selected and click “Finish”",
    "In the black window that pops, type in pacman -S mingw-w64-ucrt-x86_64-gcc , and press “Enter”",
    "Press “Enter” again to proceed with installation.",
    "[Step 4] Additionally, you need to run the following command in the same MSYS2 UCRT64 terminal.",
    "This is taken from step 5 in https://code.visualstudio.com/docs/cpp/config-mingw .",
    "Press “Enter” to accept the default option.",
    "This will take a few minutes.",
    "[Step 5] In the MSYS2 UCRT64 terminal, type in the following commands to make sure the compiler and debugger are installed.",
    "If you do not see something similar to the expected output, do not proceed.",
    "Either repeat the steps or seek help.",
    "Command 1",
    "Expected output",
    "Command 2",
    "Expected output",
    "Command 3",
    "Expected output",
    "[Step 6] Go to Settings using the search at the bottom left.",
    "In {\\bf Find a setting}, search for “Edit environment variables for your account”.",
    "Click on Path , and click Edit .",
    "In the new window, press New on the right and add C:\\msys64\\ucrt64\\bin and click OK .",
    "Fig. 1  Edit Path #",
    "[Step 7] Open/Launch Visual Studio Code .",
    "For Mac/Linux Users #",
    "You can follow along the following video for steps on setting up VS Code on Windows.",
    "Brief steps are also provided below.",
    "[Step 1] Go to code.visualstudio.com , and download VS Code.",
    "It will take seconds.",
    "[Step 2] Once the download is complete, open the zip file downloaded by double-clicking the .zip file.",
    "It will extract the zip file and install the application.",
    "Drag and drop the produced Visual Studio Code Application into the Applications folder.",
    "[Step 3] Before being able to compile, run and debug your program, we need to install the necessary C compiler and debugger.",
    "To do so, click on Spotlight Search , type and select Terminal .",
    "[Step 4] Type in the following command in the terminal:",
    "Please note $ is not part of the command.",
    "It may appear as % instead on terminal.",
    "Click “Agree” if you are prompted to agree on a license.",
    "Installation will take time depending on your machine’s capacity and Internet connection.",
    "It took me \\(5\\) – \\(6\\) minutes.",
    "[Step 5] Check if your C compiler has been correctly installed by typing:",
    ", to see version number of gcc.",
    "If it is not installed, you will see",
    "[Step 6] Open/Launch Visual Studio Code .",
    "Using VS Code #",
    "[Step 1] To create a new folder, click on Explorer \\(\\rightarrow\\) Open Folder .",
    "Navigate to your desired folder \\(\\rightarrow\\) press New Folder .",
    "Name your folder aps105-labs and click Create \\(\\rightarrow\\) Open .",
    "Make sure your desired folder that contains aps105-labs does not contain any spaces in its path.",
    "[Step 2] Create a new folder in the aps105-labs folder, for example lab0 , by clicking on New Folder icon next to aps105-labs on the top left.",
    "[Step 3] Click on lab0 , and press the New File icon next to aps105-labs to create a new file.",
    "[Step 4] To compile using VS Code, we need to install two necessary extensions.",
    "Go to Extensions below the Explorer icon.",
    "[Step 5] Install C/C++ and C/C++ Runner extensions by clicking on ``Install’’ after you click on each of them.",
    "[Step 6] On the bottom left of your window, you should see Select Folder .",
    "This helps you select a particular working folder.",
    "In our case, we want to select aps105-labs/lab0 .",
    "[Step 7] Write a test code in lab0.c file.",
    "Turn on the option of Autosave , so that you do not need to worry about saving your C program every time you make a change.",
    "Go to File \\(\\rightarrow\\) Autosave .",
    "[Step 8] To compile your program, press the Compile button towards the bottom left of the screen.",
    "To run your program, press the Run button.",
    "Any output will be observed in the terminal to the lower half of your VS Code window.",
    "[Step 9] Consistent code is easy to read.",
    "Consistency appears in the proper indentation, spacing and appropriate line length.",
    "To automatically ensure your code is consistent, you can use the default formatter in VS Code.",
    "To do so, go to Settings by clicking on the gear at the bottom left of VS Code window.",
    "In the search bar, type “formatter”.",
    "Check the Editor: Default Formatter is set to None , and Editor: Format on Save is ticked.",
    "This will automatically format your code every time you save.",
    "In addition, in the search bar, type “format” and under Extensions \\(\\rightarrow\\) C/C++ , set the C_{Cpp}: {Clang}_{format}_{fallback} Style to Google .",
    "This will ensure that your code is formatted according to the Google C++ Style Guide.",
    "[Step 10] Walking through individual lines of your code step by step is called debugging.",
    "To debug your code, you need to add a breakpoint.",
    "A breakpoint is a line of code where your program will pause at when you click the Debug button at the bottom left next to Compile and Run buttons.",
    "To create a breakpoint, you need to hover over the line you want your code to pause at and click there.",
    "[Step 11] Click on the Debug button to start a debugging session.",
    "Your code will stop at your breakpoint without executing it, unless you press Step over button.",
    "As you step over, you will execute further lines and observe variable values changing on the left.",
    "If you want to continue running the program, without debugging further, you can press the Continue button.",
    "Stack Overflow Developer Survey 2023, Integrated Development Environment, 2023.",
    "Basic UNIX Commands #",
    "More Extensions in VS Code #",
    "In the Extensions on the left side of the VS Code window, you may find these extensions interesting.",
    "You can install them if you want to.",
    "Better Comments #",
    "You can install Better Comments to help you write consistent comments for functions.",
    "Before a function, you need to type \\** and press tab , it will fill in a template for you to fill in.",
    "The template requires description of the function and input and return parameters.",
    "You can also use it at the beginning of your file to describe the contents of the file.",
    "For example, an example of a function description is as follows:",
    "Error Gutters #",
    "Installing Error Gutters helps in bringing your attention to errors/warnings in your code.",
    "It will show a red cross on the left side of the lines where the error is and a yellow caution symbol next to lines that cause a warning.",
    "Fig. 2  Error Gutters in action #",
    "Error Lens #",
    "Error Lens is another extension that helps you identify errors in your code.",
    "It will show a red dot on the left side of the line where the error is.",
    "You can hover over the red dot to see the error message.",
    "1.2.  Binary representation in memory #",
    "The memory stores data and program instructions in binary format, i.e. 0s and 1s.",
    "How does this look like?",
    "Let’s take a closer look at what the memory has.",
    "Binary is a base-2 number system.",
    "It allows two states (0 and 1) to represent a digit.",
    "This is different from the decimal/base-10 number system that allows ten states (0 – 9) for each digit.",
    "The smallest unit of binary number is a bit .",
    "A bit can be a 0 or a 1 .",
    "Let’s start representing decimal numbers using bits.",
    "It is intuitive to represent a decimal 0 with a binary 0 and a decimal 1 with a binary 1 .",
    "How about other decimals?",
    "In the decimal number system, after 9 comes 10.",
    "This adds 1 to the ten’s digit, and the one’s digit is reset to 0.",
    "Similarly, we can add 1 to the next significant digit and set the lowest significant digit to 0.",
    "For example, we can represent a decimal 2 with a binary 10 .",
    "Higher significant numbers are towards the left, just like in decimal number system.",
    "Let’s name this higher significant bit “ two’s bit”, and the lowest significant digit “ one’s bit”.",
    "Representing a decimal 3 requires adding 1 to the ones significant bit.",
    "This gives us 11 .",
    "The following table summaries the binary representation of decimal numbers from 0 to 3.",
    "Decimal Binary",
    "0 00",
    "1 01",
    "2 10",
    "3 11",
    "For numbers greater than 3, again we need a 1 in another higher significant digit to the left – four’s bit.",
    "The remaining bits to the right (two’s and one’s digits) are set to 0.",
    "This gives us 100 , which is the binary representation of decimal 4.",
    "The same logic follows for more numbers.",
    "The following table shows the binary representation of decimal numbers from 0 to 7.",
    "Decimal Binary",
    "0 000",
    "1 001",
    "2 010",
    "3 011",
    "4 100",
    "5 101",
    "6 110",
    "7 111",
    "1.2.1.  How to know the decimal number from a binary number? #",
    "To convert a binary number to a decimal number, we need to know the value of each bit.",
    "In the previous section, we discussed the logic behind representing decimal numbers in binary.",
    "We can use the same logic to convert a binary number to a decimal number.",
    "In decimal numbers, we have the one’s digit, ten’s digit, hundred’s digit and so on.",
    "The value of each digit is the power of \\(10\\) .",
    "One’s digit is \\(10^0\\) , ten’s digit is \\(10^1\\) , hundred’s digit is \\(10^2\\) and so on.",
    "Similarly, in binary numbers, we have the one’s bit, two’s bit, four’s bit and so on.",
    "The value of each bit is the power of \\(2\\) .",
    "The value of the one’s bit is \\(2^0\\) , the value of the two’s bit is \\(2^1\\) , the value of the four’s bit is \\(2^2\\) and so on.",
    "To be able to get the decimal equivalent of a binary representation, we need to multiply each bit with its value.",
    "For example, the binary number 101 is equivalent to \\(1 \\times 2^0 + 0 \\times 2^1 + 1 \\times 2^2 = 5\\) .",
    "Another example is shown in the following figure.",
    "Fig. 1.2  Binary to decimal conversion example #",
    "1.2.2.  How to know the binary representation of a decimal number? #",
    "While we discussed earlier the logic of developing the binary representation from decimal numbers, we need to find a way to convert individual decimals to their binary representation.",
    "The main idea is the following: In the binary to decimal conversion, we had to multiply each bit with its value.",
    "To reverse this, in the decimal to binary conversion, we need to divide the decimal number by two repeatedly to know the value we need to put in each bit.",
    "The method.",
    "For example, we have 138 to convert to binary.",
    "We divide 138 by 2 and get a quotient of 69 and a remainder of 0.",
    "We continue dividing the quotient by 2, and keep track of remainders.",
    "This stops when the quotient reaches 0.",
    "The last remainder is the highest significant bit, and the first is the lowest significant bit.",
    "The following figure shows the steps of the conversion through an example.",
    "Fig. 1.3  Decimal to binary conversion example #",
    "1.2.3.  How many bits do we need to represent  \\(x\\)  numbers? #",
    "So far we used",
    "1- One bit to represent 2 numbers (0 and 1).",
    "2- Two bits (two’s and one’s bits) to represent 4 numbers (0 to 3).",
    "3- Three bits (four’s, two’s and one’s bits) to represent 8 numbers (0 to 7).",
    "We can see a pattern here.",
    "We need \\(n\\) bits to represent \\(2^n\\) numbers.",
    "A byte is a group of 8 bits.",
    "Hence, a byte can store \\(2^8 = 256\\) different numbers.",
    "To represent \\(x\\) numbers, we need \\(\\log_2(x)\\) bits.",
    "For example, to represent 256 numbers, we need 8 bits.",
    "To represent 512 numbers, we need 9 bits.",
    "To represent 1024 numbers, we need 10 bits.",
    "A byte is a group of 8 bits.",
    "A kilobyte (KB) is 1024 bytes.",
    "A megabyte (MB) is 1024 kilobytes.",
    "A gigabyte (GB) is 1024 megabytes.",
    "A terabyte (TB) is 1024 gigabytes.",
    "1.2.4.  How is the 0s and 1s of data memory organized? #",
    "The memory is organized in cells .",
    "Each cell stores a byte.",
    "Each cell has an address.",
    "This makes the memory byte-addressable .",
    "This means at each address only one byte is stored.",
    "Since the computer only understands 0s and 1s, we will use binary format to refer to the addresses.",
    "For example, the address 0000 refers to the first cell in the memory.",
    "The address 0001 refers to the second cell in the memory.",
    "The address 0010 refers to the third cell in the memory.",
    "Fig. 1.4  The byte addressable memory #",
    "How many bytes can be stored in the memory, if we use 32 bits to represent the address?",
    "We can use the formula \\(2^n\\) to calculate this.",
    "Since we have 32 bits, we can represent \\(2^{32}\\) numbers.",
    "This means we can store \\(2^{32}\\) bytes in the memory.",
    "How much is \\(2^{32}\\) bytes?",
    "Let’s breakup \\(2^{32}\\) into \\(2^2 \\times 2^{10} \\times 2^{10} \\times 2^{10}\\) .",
    "As we said before, \\(2^{10}\\) is 1024 bytes, which is a kilobyte.",
    "So \\(2^{10} \\times 2^{10}\\) makes 1024 \\(\\times\\) kilobyte = megabyte.",
    "And \\(2^{10} \\times 2^{10} \\times 2^{10}\\) makes 1024 \\(\\times\\) megabyte = gigabyte.",
    "So \\(2^{32}\\) bytes is 4 gigabytes.",
    "That’s not too much.",
    "Modern computers use 64-bits to represent their addresses.",
    "How many bytes can a 64-bit address represent?",
    "\\(2^{64}\\) bytes is 16 exabytes.",
    "That’s a lot of memory!",
    "Now, that we know how is the data represented inside the main memory and how is each byte addressed, let’s see the cycle of developing a program in C.",
    "Quiz",
    "0 Questions",
    "1.1.  The Basic Structure of Computers #",
    "A program is a sequence of instructions to be executed or performed by a computer.",
    "To be able to give some context on where does your C program fit in your computer, we will first discuss the basic structure of a computer.",
    "A computer system has software and hardware.",
    "The software consists of the applications running on your computer, such as your browser, computer games, Microsoft Office, and your C program which you will develop in this course.",
    "Another very important piece of software is the operating system, which provides an interface between the hardware and the applications running on your computer.",
    "The hardware consists of the physical components of your computer, such as the central processing unit (CPU), (main) memory, the hard drive, and the input and output devices.",
    "The two most important pieces of hardware that we will access using C is the keyboard (input device) and the monitor (output device).",
    "Fig. 1.1  The basic structure of a computer #",
    "The main memory stores data and the program we want to execute.",
    "The data and instructions are all stored in binary representation.",
    "The central processing unit (CPU) also referred to as the brain of the computer.",
    "It is responsible for executing the instructions in a program.",
    "An example of an instruction is adding two numbers.",
    "The CPU is made up of mainly two components: the arithmetic logic unit (ALU) and the control unit.",
    "The ALU is responsible for performing arithmetic and logical operations, such as addition, subtraction, multiplication, division, and comparisons.",
    "The control unit is responsible for controlling the execution of instructions.",
    "To execute instructions, the CPU fetches the instructions from the main memory, decodes them, and executes them.",
    "The instructions may require reading and writing data to the main memory.",
    "Also, the instructions may require access to input and output devices.",
    "Input and output (I/O) devices are used to communicate with the outside world.",
    "The most common input devices are the keyboard and the mouse.",
    "These take input from the user.",
    "The most common output devices are the monitor and the printer.",
    "These can display the output of the program.",
    "Quiz",
    "0 Questions",
    "1.  Introduction to Programming Computers #",
    "In this chapter, we will discuss what are computers and how to make them do what we want.",
    "In particular, we will look into the main components of a computer and how it interacts with the real world.",
    "We will also look into how programs are developed and how they are executed.",
    "1.4.  Write Simple C Programs #",
    "1.4.1.  Hello, world! #",
    "In this section, we will write our first C program.",
    "We will write a program that prints the message “Hello World!” on the screen.",
    "This is a tradition in programming.",
    "The program is very simple, but it will give you a taste of what programming is like.",
    "Download hello-world.c if you want to play with the code.",
    "Let’s examine each line:",
    "#include <stdio.h> gives access to functions that interface with input (like keyboard) and output (like monitor) devices.",
    "These functions include printf and scanf .",
    "// double forward slash is used when the programmer want to write a comment line.",
    "For example, // This program prints the message \"Hello World!\" on the screen.",
    "is a comment line.",
    "The compiler ignores the comment lines.",
    "Hence, comment lines are not executed.",
    "main is the entry point of the C program.",
    "All C programs require a main function.",
    "main is called when the program is executed.",
    "It returns an integer value.",
    "The value 0 indicates that the program executed successfully.",
    "Any other value indicates that the program failed.",
    "printf is a function that prints a string to the screen.",
    "The string is enclosed in double quotes.",
    "The \\n is a special character that indicates a new line.",
    "The \\ is called an escape character.",
    "It is used to indicate special characters.",
    "The printf function is defined in the stdio.h header file.",
    "return 0 if the main function is executed, and it reached the end, this means all previous statements were executed successfully.",
    "return 0 makes the main function report that it returned a zero and hence won’t show error messages related to issues with previous statements.",
    "return 0 will end the execution of the program.",
    "; every statement in C ends with a semicolon.",
    "1.4.1.1.  Bad coding style #",
    "If we remove spaces, indentation and formatting of the above program, it will look like this:",
    "However, it does not look easy to read and understand.",
    "For tips on better coding style, see Coding Style .",
    "1.4.2.  Prompt user for input #",
    "Write a C code that prompts the user to enter the number of pizzas they have.",
    "The program outputs the total number of slices they have.",
    "We are assuming each pizza has 8 slices.",
    "Download code in pizza.c if you want to play with the code further.",
    "Let’s examine each line:",
    "#include <stdio.h> again allows to access function interfaces with keyboard and monitor, specifically printf and scanf .",
    "int main(void){ is the entry point of any C program.",
    "Ideally, the function should return 0 if there were no problems encountered in executing the statements in the main function.",
    "int numPizzas, numSlices; declares two variables of type int .",
    "int is a data type that represents integers.",
    "The variables are named numPizzas and numSlices .",
    "This line indicates that the memory created a space for these two variables.",
    "printf(\"How many pizzas do you have?\\n\"); prints the string “How many pizzas do you have?” to the screen.",
    "The \\n indicates a new line.",
    "scanf(\"%d\", &numPizzas); will take the user input and assign it to numPizzas variable.",
    "scanf is a function that scans the keyboard for user input.",
    "%d is a format specifier that indicates that user input will be an integer.",
    "& is the address-of operator.",
    "It is used to get the address of a variable.",
    "&numPizzas is the address of the variable numPizzas .",
    "scanf will store the user input in the address of the variable numPizzas .",
    "scanf requires the address of the variable (not just the variable).",
    "In the chapter of pointers, we will discuss why scanf requires the address of numPizzas .",
    "numSlices = numPizzas * 8; will multiply the value in numPizzas (which was entered by the user in scanf ) by 8 and store the result value in numSlices .",
    "printf(\"You have %d slices in %d pizza.\\n\", numSlices, numPizzas); will print what is between quotes.",
    "In place of the first %d , it will print the first value after the comma , that is numSlices .",
    "In place of the second %d , it will print the second value after the second comma , that is numPizzas .",
    "return 0; will end the execution of the program.",
    "} indicates the end of the main function.",
    "It is the closing bracket of the opening bracket { of the main function.",
    "1.4.3.  Escape Sequences #",
    "Previously, we studied how to use the printf function to print text and values in variables.",
    "If you still did not get this question, how do we print \\n when we do not want it to print a new line?",
    "This is an issue with escape sequences.",
    "An escape sequence is a sequence of characters that may not represent itself.",
    "Instead, to be represented correctly, it needs to be preceded by another character.",
    "For example, \\n is an escape sequence that represents a new line.",
    "To print \\n , we need to add another \\ before it.",
    "Hence, printf(\"\\\\n\"); prints \\n .",
    "In general, for escapes sequences that start with \\ escape character, we add another \\ .",
    "For example, printf(\"\\\\n\"); will print \\n .",
    "\" is also an escape character.",
    "If we want to print \" , we add \\ before it.",
    "For example, printf(\"\\\"\"); will print \" .",
    "The following table lists how to print some of the escape sequences that are commonly used in C.",
    "Escape Sequence Prints",
    "\\\\n \\n",
    "\\\\ \\",
    "\\\\t \\t",
    "\\' '",
    "\\\" \"",
    "If you still did not get this question, how do we print % itself?",
    "% is an escape character too used to specify the format of the variable to be printed.",
    "To print % , we require another % .",
    "Hence, printf(\"%%\") prints % .",
    "Quiz",
    "0 Questions",
    "1.3.  Development Cycle #",
    "While data and instructions are stored in binary format, we do not write programs in binary.",
    "It is too difficult for humans.",
    "Fortunately, we use a programming language.",
    "There is a development cycle that we follow when we write a program.",
    "The cycle is as follows:",
    "Write the program in an Integrated Development Environment (IDE), e.g. Visual Studio Code.",
    "Check the Setup Visual Studio Code page for instructions on how to set up Visual Studio Code.",
    "Write the program in an Integrated Development Environment (IDE), e.g. Visual Studio Code.",
    "Check the Setup Visual Studio Code page for instructions on how to set up Visual Studio Code.",
    "Compile the program using a compiler like GCC.",
    "This converts the program from a human-readable format to a machine-readable format.",
    "Not surprisingly, the compiler is a program also written in a programming language (usually C).",
    "This can be invoked from the command line or from the IDE.",
    "Compile the program using a compiler like GCC.",
    "This converts the program from a human-readable format to a machine-readable format.",
    "Not surprisingly, the compiler is a program also written in a programming language (usually C).",
    "This can be invoked from the command line or from the IDE.",
    "Run the program.",
    "This executes the sequence of instructions in the program.",
    "This can be invoked from the command line or from the IDE.",
    "Check the Setup Visual Studio Code page for instructions on how to compile and run a program.",
    "Run the program.",
    "This executes the sequence of instructions in the program.",
    "This can be invoked from the command line or from the IDE.",
    "Check the Setup Visual Studio Code page for instructions on how to compile and run a program.",
    "Debug the program.",
    "This is the process of finding and fixing errors in the program.",
    "Some programs help in debugging, e.g. GDB.",
    "These allow programmers to view the execution state of their program step-by-step.",
    "This aids in finding errors.",
    "Debug the program.",
    "This is the process of finding and fixing errors in the program.",
    "Some programs help in debugging, e.g. GDB.",
    "These allow programmers to view the execution state of their program step-by-step.",
    "This aids in finding errors.",
    "It is vital to prepare the young generation of programmers for debugging.",
    "Most of your time (some people say 80% – 90%) will be spent on debugging.",
    "It is important to mentally prepare yourself that your code will fail in your first trials.",
    "Debugging gets easier with experience.",
    "Check ../appendix/setup-vscode.md and last section of each chapter starting Chapter 5 for detailed tips on finding and fixing errors.",
    "The following figure summarizes the development cycle.",
    "Fig. 1.5  The development cycle of a program #",
    "1.3.1.  Do not start by typing code! #",
    "Many beginners do the mistake of developing code as they type it.",
    "This is a bad habit.",
    "Ideally, programmers should first identify the problem, think of a solution, plan the structure of the program, and then write code.",
    "More details on this process will be discussed in the future.",
    "1.3.2.  Do not stop when your code works! #",
    "Several people (and probably you) will stop at the stage where your code works.",
    "As long as your code passes all the test cases, you are done.",
    "However, this is not the case in modern programming, where our lives depends on programs.",
    "You need to make two main things:",
    "Test your code extensively: In this course, you will be graded on the correctness of the functionality of your code.",
    "You must develop your own test scenarios to ensure your code is functional under all circumstances.",
    "Test your code extensively: In this course, you will be graded on the correctness of the functionality of your code.",
    "You must develop your own test scenarios to ensure your code is functional under all circumstances.",
    "Make sure that your code is readable, maintainable, and reusable: You will need to ensure that if someone else needs to use your code, they can do so easily .",
    "Throughout this course, you will learn briefly how to clean code .",
    "This is a building block of software engineering .",
    "Nowadays, employers need programmers who can clean code .",
    "Since this is a course for beginners, you won’t be penalized massively if you cannot clean code.",
    "Make sure that your code is readable, maintainable, and reusable: You will need to ensure that if someone else needs to use your code, they can do so easily .",
    "Throughout this course, you will learn briefly how to clean code .",
    "This is a building block of software engineering .",
    "Nowadays, employers need programmers who can clean code .",
    "Since this is a course for beginners, you won’t be penalized massively if you cannot clean code.",
    "Clean coding can easily be a course by itself.",
    "If you want to be someone hirable by a company, you need to have this skill of producing expandable code.",
    "If you want to learn more about clean coding, you can refer to the book on Clean Coding by Robert C.",
    "Martin [ 1 ] .",
    "Robert C.",
    "Clean Code: A Handbook of Agile Software Craftsmanship .",
    "Prentice Hall PTR, USA, 2008.",
    "Quiz",
    "0 Questions",
    "Principles of using this textbook #",
    "Embedded Code 💻 #",
    "You can also download the .c file of the program by clicking on file name in text.",
    "For example, download hello-world.c if you want to edit the code yourself.",
    "If it opens a new window with contents of the file, right-click on the page and select Save As. You can choose where you want to save the file.",
    "Please make sure it is saved as .c file not .txt file.",
    "Example or potential output to the code will be shown as in the following example.",
    "Exercises 🏋 #",
    "Every chapter will have an exercises section.",
    "This section will include past exams questions related to the concepts discussed in the chapter (or previous chapters).",
    "Some may be marked as [Easy] , [Intermediate] or [Challenging] .",
    "The difficulty level is subjective and may vary from person to person.",
    "I expect you to solve these exercises after we cover the chapter in the lectures.",
    "These exercises will have solutions that will be hidden and you need to click to show the answer.",
    "For example,",
    "An answer will appear here.",
    "Debugging 🐞 #",
    "In some chapters, there will be a section on debugging.",
    "It will discuss the most common mistakes programmers make related to the chapter.",
    "It may or may not include a YouTube video where I debug a code using concepts discussed in the chapter.",
    "Downloading 📥 #",
    "You can download a copy of each section by clicking on the top right most icon with an arrow.",
    "PDF should be your to-go option.",
    "Search 🔍 #",
    "You have a search box in the middle left of the page.",
    "You can search for a keyword or a phrase.",
    "It will search through the entire textbook.",
    "Suggestions and Feedback 📝 #",
    "This website/online e-book is still under development.",
    "If you have any suggestions or feedback, please email me at salma @ ece .",
    "utoronto .",
    "ca .",
    "You can also hover over the cat icon in the top right of this page, and click on open issue.",
    "This will take you to GitHub where you can easily describe what’s the issue.",
    "This requires that you sign-up for a GitHub account.",
    "What about programming? #",
    "Welcome to the first edition of Snefru: Learning Programming with C !",
    "What is programming? #",
    "Programming is a skill that allows you to tell a computer what to do.",
    "Programming involves writing a program.",
    "This program communicates a set of instructions that the computer can understand.",
    "The computer then executes these instructions to accomplish the task you want to do.",
    "To communicate these instructions, we use a programming language.",
    "A programming language is a set of rules that allow us to write instructions that the computer can understand.",
    "One of the most common programming languages is C .",
    "Why learn programming? #",
    "Now that you know what programming is, you might be wondering why you should learn programming.",
    "It seems like there are many engineering systems built in C, but how will this help you?",
    "There are many reasons to learn programming.",
    "Here are a few:",
    "Automate your tasks Programming can help you automate several day-to-day tasks, avoiding the need to do boring tasks that kill your creativity.",
    "Automating a task can arguably save you a lot of time.",
    "You will indeed initially spend more time to automate the task, but once automated, you will save a lot of time in the long run.",
    "A few years ago, one project went viral on GitHub.",
    "It has scripts written by an employee to automate jobs that took him more than 90 seconds.",
    "Tasks include fixing common problems caused by clients and texting his wife a “late at work” message randomly selected from a list of many reasons.",
    "My favorite script connects with the office coffee machine, and sends an order to the machine to start brew coffee before he gets to the machine from his desk.",
    "Warning Disclaimer: The authors are NOT responsible for any damage caused to your relationship or coffee machine if you use the referred code 😄",
    "Automate your tasks",
    "Programming can help you automate several day-to-day tasks, avoiding the need to do boring tasks that kill your creativity.",
    "Automating a task can arguably save you a lot of time.",
    "You will indeed initially spend more time to automate the task, but once automated, you will save a lot of time in the long run.",
    "A few years ago, one project went viral on GitHub.",
    "It has scripts written by an employee to automate jobs that took him more than 90 seconds.",
    "Tasks include fixing common problems caused by clients and texting his wife a “late at work” message randomly selected from a list of many reasons.",
    "My favorite script connects with the office coffee machine, and sends an order to the machine to start brew coffee before he gets to the machine from his desk.",
    "Disclaimer: The authors are NOT responsible for any damage caused to your relationship or coffee machine if you use the referred code 😄",
    "Acquire transferable skills Programming can help you learn how to think logically and solve problems.",
    "As you start working on larger projects with several lines of code, you will learn how break down a problem into smaller pieces and solve them.",
    "You will learn computational thinking.",
    "This is necessary not only to solve problems, but to also communicate your solutions to others.",
    "All these skills are important not only for an engineer, but for many other careers.",
    "Acquire transferable skills",
    "Programming can help you learn how to think logically and solve problems.",
    "As you start working on larger projects with several lines of code, you will learn how break down a problem into smaller pieces and solve them.",
    "You will learn computational thinking.",
    "This is necessary not only to solve problems, but to also communicate your solutions to others.",
    "All these skills are important not only for an engineer, but for many other careers.",
    "Allows a wide range of career opportunities Since programming involves learning several skills, there is a wide range of careers that you can choose from.",
    "For example, you can choose to be a software engineer, a data scientist, a web developer, or a game developer.",
    "Software can be used in psychology, medicine, music, film-making and many other fields.",
    "For example, in the Electrical and Computer Engineering Department, Professor Jonathan Rose has been using software to build chat-bots for mental health research, and Professor Steve Mann has been using software to build a wearable camera, referred to as EyeTap, that can capture your memories.",
    "Even if you are in a non-coding role, knowing how to code will help you collaborate with a programmer to revolutionize your field.",
    "If I told you 15 years ago that a taxi company will be worth 49B USD today, you would probably think I am crazy.",
    "But this is exactly what happened to Uber.",
    "The company was founded by two engineers who wanted to solve a problem they had with the taxi service in San Francisco.",
    "They wrote a program that matched drivers with passengers.",
    "This program was the foundation of the company that is now worth 49B USD.",
    "Allows a wide range of career opportunities",
    "Since programming involves learning several skills, there is a wide range of careers that you can choose from.",
    "For example, you can choose to be a software engineer, a data scientist, a web developer, or a game developer.",
    "Software can be used in psychology, medicine, music, film-making and many other fields.",
    "For example, in the Electrical and Computer Engineering Department, Professor Jonathan Rose has been using software to build chat-bots for mental health research, and Professor Steve Mann has been using software to build a wearable camera, referred to as EyeTap, that can capture your memories.",
    "Even if you are in a non-coding role, knowing how to code will help you collaborate with a programmer to revolutionize your field.",
    "If I told you 15 years ago that a taxi company will be worth 49B USD today, you would probably think I am crazy.",
    "But this is exactly what happened to Uber.",
    "The company was founded by two engineers who wanted to solve a problem they had with the taxi service in San Francisco.",
    "They wrote a program that matched drivers with passengers.",
    "This program was the foundation of the company that is now worth 49B USD.",
    "Why learn C? #",
    "Applicability: C is a general-purpose programming language that is used to write programs for a wide variety of applications.",
    "For example, the operating system on your computer, such as Windows, Linux, Mac OS X is mostly written in C.",
    "The programs that you use to browse the web and play games are also written in C.",
    "Even the compilers such as MINGW and Clang C, which are programs that translate your C code into machine code, are written in C!",
    "Programs running on embedded systems, such as the microcontrollers in your smart phone, your smart watch, and your smart fridge are written in C.",
    "Speed and Energy efficiency: Living in a world run by programs, energy efficiency and speed are important.",
    "C is known to be the best energy efficient programming language.",
    "Since C is a compiled language, it runs faster than interpreted languages such as Python.",
    "Flexibility: C is a low-level programming language.",
    "This means that it gives you more control over the computer.",
    "You can directly access the memory of the computer, and you can directly control the hardware of the computer – as we will see in this course.",
    "This allows you to write programs that are more efficient and faster.",
    "Transferable knowledge: C has a syntax that is very similar or close to many other programming languages.",
    "This will make it easy later on to learn other programming languages.",
    "How to program? #",
    "This is what we answer throughout this book.",
    "Let’s get started 💪.",
    "Who is this book for? #",
    "It is intended to be a resource for students in the first year of the University of Toronto’s APS105: Computer Fundamentals course.",
    "It is also intended to be a resource for students who are self-learning C.",
    "This website is under development.",
    "15.2.  Binary Search #",
    "Searching for an element in a sorted array is quick.",
    "Think of having a pile of booklets with names sorted in ascending order.",
    "Say you want to find the booklet with the name “Snefru”.",
    "You can start at the middle of the pile and check if the name is “Snefru”.",
    "If it is, you are done.",
    "If it is not, you can check if the name is before or after “Snefru”.",
    "If it is before, you can discard the second half of the pile.",
    "If it is after, you can discard the first half of the pile.",
    "You can repeat this process until you find the booklet with the name “Snefru”.",
    "This method that we just discussed is called binary search.",
    "It is called binary search because it searches the list in a binary fashion, checking the middle element of the list and then discarding half of the list based on the result.",
    "Given an array of seven elements named list as shown in the figure below, we want to look for item \\(9\\) .",
    "The algorithm for binary search is as follows:",
    "Define the limits of the array using variables low and high .",
    "We can do so by initially setting low = 0 and high = length of array - 1 .",
    "Since we want to look at the middle element, we can hold its index in middle = (low + high)/2 .",
    "Define the limits of the array using variables low and high .",
    "We can do so by initially setting low = 0 and high = length of array - 1 .",
    "Since we want to look at the middle element, we can hold its index in middle = (low + high)/2 .",
    "Since the value at index middle is not equal to item , which is 9 , we need to continue looking for item .",
    "We can check if list[middle] < item .",
    "If it is, we can discard the first half of the list.",
    "If it is not, we can discard the second half of the list.",
    "In our case, list[middle] is 7, which is less than item , which is 9 .",
    "Therefore, we can discard the first half of the list.",
    "We can do this by setting low = middle + 1 .",
    "Since the value at index middle is not equal to item , which is 9 , we need to continue looking for item .",
    "We can check if list[middle] < item .",
    "If it is, we can discard the first half of the list.",
    "If it is not, we can discard the second half of the list.",
    "In our case, list[middle] is 7, which is less than item , which is 9 .",
    "Therefore, we can discard the first half of the list.",
    "We can do this by setting low = middle + 1 .",
    "We can repeat step \\(1\\) and \\(2\\) but on the smaller right sub-array until we find item .",
    "In our case, low is 4 and high is 6 .",
    "This makes middle = 5 .",
    "Since list[middle] is 10 , which is less than item , which is 9 , next we can discard the second half of the sub-array (after middle).",
    "We can repeat step \\(1\\) and \\(2\\) but on the smaller right sub-array until we find item .",
    "In our case, low is 4 and high is 6 .",
    "This makes middle = 5 .",
    "Since list[middle] is 10 , which is less than item , which is 9 , next we can discard the second half of the sub-array (after middle).",
    "We can discard the second half of the sub-array by setting high = middle - 1 .",
    "After discarding the second half of the array, we have low = 4 and high = 4 .",
    "This makes middle = 4 .",
    "We can discard the second half of the sub-array by setting high = middle - 1 .",
    "After discarding the second half of the array, we have low = 4 and high = 4 .",
    "This makes middle = 4 .",
    "Since list[middle] is 9 , which is equal to item , we have found item in the array.",
    "When not found!",
    "If item in our example was 8 , we would NOT have found it at index 4 .",
    "However, the algorithm will continue with setting high = middle - 1 .",
    "This would make high = 3 , and low remains 4 .",
    "The algorithm should terminate when low > high .",
    "This means that the algorithm has searched the entire array and has not found item .",
    "15.2.1.  Pseudocode #",
    "To highlight the main steps of binary search, we can write the algorithm in pseudocode as follows:",
    "Set low = 0 and high to the length of the array - 1.",
    "Look at the element at index middle = (low + high)/2 .",
    "If the element at index middle is equal to item , return middle .",
    "If the element at index middle is less than item , the item could be in the right sub-array.",
    "Set low = middle + 1 to look at the right sub-array and go to step \\(2\\) .",
    "If the element at index middle is less than item , the item could be in the right sub-array.",
    "Set low = middle + 1 to look at the right sub-array and go to step \\(2\\) .",
    "Otherwise, set high = middle - 1 to look at the left sub array and go to step \\(2\\) .",
    "If low > high , return -1 to indicate that item was not found.",
    "15.2.2.  Implementation #",
    "To implement binary search, we need to write a function that takes in an array, size of the array and an item to search for.",
    "The function should return the index of the item if it is found in the array.",
    "If the item is not found, the function should return -1 .",
    "Download the following code binary-search.c if you want to play with it.",
    "In line \\(17\\) , we have exited from the while loop.",
    "This means that we have searched the entire array and have not found item .",
    "Therefore, we return -1 to indicate that item was not found.",
    "15.2.3.  Recursive Implementation #",
    "We can also implement binary search recursively.",
    "Thinking recursively , as we discussed in Section 11.2.1 , requires us to think about a smaller problem.",
    "In the case of binary search, we can think about the smaller problem of searching a smaller sub-array .",
    "This would be our recursive case.",
    "Our base/terminating case is when we have searched the entire array and have or have not found item .",
    "How would we reduce the size of the array from one function call to the next recursive function call?",
    "We did a similar thing when we implemented isPalindrome function recursively in Section 11.3.2 .",
    "The idea is to communicate with the next recursive function call the new limits of the array, i.e. the values of low and high .",
    "Similarly, in our recursive binary search implementation below, we pass the values of low and high to the next recursive function call.",
    "We can do so by passing the values of low and high as arguments to the recursive function call.",
    "In line \\(1\\) , we pass the array list , the values of low and high and the item to search for as arguments to the recursive function call.",
    "Initially, we can call the function to set low to 0 and high to the length of the array - 1.",
    "Lines \\(2\\) – \\(3\\) handle the base case.",
    "If high is less than low , we have searched the entire array and have not found item .",
    "Therefore, we return -1 to indicate that item was not found.",
    "Lines \\(6\\) – \\(7\\) handle another base case when we found item in the array.",
    "If item is equal to list[middle] , we return middle to indicate that we have found item in the array.",
    "Lines \\(9\\) – \\(10\\) handle the recursive case when item is less than list[middle] .",
    "In this case, we can discard the second half of the array by setting high = middle - 1 to the next recursive call.",
    "We can then call the recursive function to search the left sub-array by binarySearchHelper(list, low, middle - 1, item) .",
    "The return before the recursive function call is important.",
    "This ensures that the value returned by the recursive function call is returned by the function.",
    "You can drop the return statement if it was a void function, but since it should return an int , we need to return the value returned by the recursive function call.",
    "Lines \\(12\\) – \\(13\\) handle the recursive case when item is greater than list[middle] .",
    "In this case, we can discard the first half of the array by setting low = middle + 1 to the next recursive call.",
    "We can then call the recursive function to search the right sub-array by binarySearchHelper(list, middle + 1, high, item) .",
    "We can see that the values of low and high are updated in the recursive function call.",
    "This is how we reduce the size of the array from one function call to the next recursive function call.",
    "Reduce number of arguments I would like to point out that functions with several arguments passed is not ideal, as someone may forget how to call the recursive function.",
    "We can improve this! We can implement a function that takes three arguments, an array, the size of the array and an item to search for.",
    "The function can then call the recursive function with the values of low and high set to 0 and the length of the array - 1, respectively.",
    "This is what we do in the following implementation.",
    "Download the following code binary-search-recursive.c if you want to play with it.",
    "In lines \\(12\\) – \\(14\\) , we call the recursive function binarySearchHelper with the values of low and high set to 0 and the length of the array - 1, respectively.",
    "As a developer, you can later just sell this function to your users, and they can call it with just three arguments, an array, size of the array and an item to search for.",
    "The function will then call the recursive function with the values of low and high set to 0 and the length of the array - 1, respectively.",
    "Quiz",
    "0 Questions",
    "15.3.  Exercises #",
    "Many of these exercises are taken from past exams of APS105 Computer Fundamentals courses at University of Toronto.",
    "The solutions are provided in the answer boxes.",
    "Headings in this page classify the exercises into different categories: [Easy] , [Intermediate] , and [Challenging] .",
    "I suggest you start by easy exercises and work your way up to the challenging ones.",
    "Question 5 in Winter 2018 [Easy]",
    "Complete the following C program by inserting the condition of the while loop in the function search .",
    "The function is designed to search for an int-type item, called key , in a linked list, pointed to by head.",
    "Question 1.7 in Fall 2011 [Easy]",
    "Your task is to complete the function below so that it contains a non-recursive implementation of the binary search algorithm.",
    "The parameter values is an array of int type variables.",
    "The items in the values array have been sorted into descending (non-ascending) order.",
    "Parameter n is the number of elements in the values array.",
    "Parameter item is the item being searched for in the values array.",
    "The function should return -1 if item is not found in the array.",
    "Otherwise, the function should return the index position within the array at which item is found.",
    "Important: your function should assume that values is a sorted array in descending (non-ascending) order.",
    "Important: Your solution must not use recursion.",
    "15.1.  Linear/Sequential Search #",
    "Linear search is a very simple search algorithm.",
    "It is called linear search because it searches the list in a linear fashion, checking each element in sequence until the desired element is found or until all the elements have been searched and the desired element was not found.",
    "We discuss the algorithm on arrays, but it applies to any data structure.",
    "For example, the algorithm can be used to search a linked list.",
    "The algorithm for linear search is as follows:",
    "Start at index = 0",
    "Check if list[index] == desired element in variable item",
    "If found, return index",
    "Otherwise, increment index by 1",
    "Repeat steps \\(2\\) – \\(4\\) until index is equal to the length of the list (or the element is found)",
    "The algorithm is implemented in the following code snippet:",
    "If item is found, the algorithm returns the index of the element in the list in line \\(4\\) .",
    "If item is not found, the algorithm returns -1 in line \\(7\\) .",
    "In the following example, we look for the element 7 in the array.",
    "Download the following code sequential-search.c if you want to play with it.",
    "The minimum number of comparisons to find the desired element is 1, and the maximum number of comparisons is the length of the list.",
    "The average number of comparisons is \\(\\frac{n}{2}\\) , where \\(n\\) is the length of the list.",
    "This would mean if I have 1000 elements in my list, the worst case scenario would be 1000 comparisons.",
    "If I have 10000 elements in my list, the worst case scenario would be 10000 comparisons.",
    "This is not very efficient.",
    "Is there a more efficient way to search for a desired element?",
    "Yes, there is.",
    "We will discuss this in the next section.",
    "Quiz",
    "0 Questions",
    "15.  Searching #",
    "Several applications require that you search for items in a huge amount of data.",
    "In this chapter, we discuss two of the most common search algorithms: linear/sequential search and binary search.",
    "There are many other search algorithms, but since this is an introductory course, we will only cover these two.",
    "2.3.  Operations #",
    "Given that we have four main data types – int , double , char , bool , we will discuss what can we do with the variables of these data types.",
    "2.3.1.  Basic arithmetic operations #",
    "We can perform arithmetic operations on variables.",
    "These operations include addition + , subtraction - , multiplication * , division / , and modulus % .",
    "Precedence rule.",
    "In math, the precedence rule was summarized in BEDMAS (Brackets () , Exponents \\(a^2\\) , Division / , Multiplication * , Addition + , Subtraction - ).",
    "The precedence rule in C is:",
    "* / %",
    "+ -",
    "left to right if operators have same precedence, referred to as left-associative",
    "Example I",
    "The value stored in x is 23 because 10 * 2 is evaluated first, followed by 20 + 3 .",
    "Example II",
    "The value stored in x is 50 because (2 + 3) is evaluated first, followed by 10 * 5 .",
    "Example III",
    "The evaluation order is from left to right (left-associative), since / and * have the same precedence.",
    "The value stored in x is 4 because 10 / 5 is evaluated first, followed by 2 * 2 .",
    "2.3.2.  The more accurate data type is contagious #",
    "Example IV",
    "Evaluating from left to right, we have 50 / 3 , which is mathematically 16.6666667 .",
    "However, 50 is int , and 3 is int .",
    "Is it consistent that 50 / 3 evaluation yields a double?",
    "NO! In C, the result of an arithmetic operation is always the data type of the operand that is more accurate.",
    "In the case of 50 / 3 , both data types are int .",
    "Hence, the resulting data type is int , with truncated decimal places, i.e. 16 .",
    "The value stored in x is 16 .",
    "Example V",
    "If we have one (or both) of the operands as double , the result will be double .",
    "For example, 50 / 3.0 is now 16.6666667 as 3.0 is double .",
    "The value stored in x is 16.6666667 .",
    "We learned before in Think! , if a floating point number is stored in int , the decimal part will be truncated.",
    "This means that in int x = 50 / 3.0; , even if 50 / 3.0 is evaluated to 16.6666667, x will have to truncate 16.6666667 to 16.",
    "This is because x is int .",
    "Hence, x stores 16 .",
    "More examples",
    "int x = 1 / 5; 1 / 5 is mathematically \\(0.2\\) .",
    "Since 1 and 5 are int s, \\(0.2\\) would be truncated to 0 .",
    "This makes the result of 1 / 5 \\(\\rightarrow\\) 0 .",
    "x stores 0 .",
    "int x = 1 / 5;",
    "1 / 5 is mathematically \\(0.2\\) .",
    "Since 1 and 5 are int s, \\(0.2\\) would be truncated to 0 .",
    "This makes the result of 1 / 5 \\(\\rightarrow\\) 0 .",
    "x stores 0 .",
    "1 / 5 is mathematically \\(0.2\\) .",
    "Since 1 and 5 are int s, \\(0.2\\) would be truncated to 0 .",
    "This makes the result of 1 / 5 \\(\\rightarrow\\) 0 .",
    "x stores 0 .",
    "double x = 10 / 4; 10 / 4 \\(\\rightarrow\\) 2 .",
    "x stores 2.0000 .",
    "double x = 10 / 4;",
    "10 / 4 \\(\\rightarrow\\) 2 .",
    "x stores 2.0000 .",
    "10 / 4 \\(\\rightarrow\\) 2 .",
    "x stores 2.0000 .",
    "int x = 3 / -2 3 / -2 \\(\\rightarrow\\) -1 .",
    "x stores -1 .",
    "int x = 3 / -2",
    "3 / -2 \\(\\rightarrow\\) -1 .",
    "x stores -1 .",
    "3 / -2 \\(\\rightarrow\\) -1 .",
    "x stores -1 .",
    "double x = 4.2 / 2; 4.2 / 2 \\(\\rightarrow\\) 2.1 .",
    "x stores 2.1000 .",
    "double x = 4.2 / 2;",
    "4.2 / 2 \\(\\rightarrow\\) 2.1 .",
    "x stores 2.1000 .",
    "4.2 / 2 \\(\\rightarrow\\) 2.1 .",
    "x stores 2.1000 .",
    "int x = 10.6 / 3; 10.6 / 3 \\(\\rightarrow\\) 3.5333...",
    "x stores 3 .",
    "int x = 10.6 / 3;",
    "10.6 / 3 \\(\\rightarrow\\) 3.5333...",
    "x stores 3 .",
    "10.6 / 3 \\(\\rightarrow\\) 3.5333...",
    "x stores 3 .",
    "double x = 9 + 6.3; 9 + 6.3 \\(\\rightarrow\\) 15.3 .",
    "x stores 15.30000 .",
    "double x = 9 + 6.3;",
    "9 + 6.3 \\(\\rightarrow\\) 15.3 .",
    "x stores 15.30000 .",
    "9 + 6.3 \\(\\rightarrow\\) 15.3 .",
    "x stores 15.30000 .",
    "2.3.3.  What happens when we divide by 0? #",
    "In math, the result of dividing a number by 0 is undefined.",
    "What would undefined mean if a program divides a number by 0?",
    "If we were to divide an int 3 by int 0 , e.g. 3/0 , the compiler may or may not successfully compile your code.",
    "The trickiest part is that if your program compiles and you run it, the result of the division is undefined.",
    "Some computers may yield a weird number resulting from this illegal division.",
    "Hence, it is important to check if the denominator is 0 before you divide.",
    "On the other hand, dividing by 0 in a float division, e.g. 3.0/0 , may yield inf .",
    "Download zeroDivision.c to try the following code on your computer.",
    "2.3.4.  Modulo operator #",
    "Remember whenever we divide two numbers, we have a quotient and a remainder.",
    "For example, \\(10/3\\) has a quotient of \\(3\\) with a remainder \\(1\\) .",
    "Hence, \\(\\frac{10}{3}\\) can be written as a mixed fraction: \\(3 \\frac{1}{3}\\) .",
    "The modulo operator % gives us the remainder of a division between two integers.",
    "10 % 3 \\(\\rightarrow\\) 1",
    "10 % 4 \\(\\rightarrow\\) 2",
    "50 % 10 \\(\\rightarrow\\) 0",
    "55 % 10 \\(\\rightarrow\\) 5",
    "Some people find it mentally challenging to find the % quickly.",
    "For example, in 10 % 3 , find the largest number divisible by 3 that is less than 10 .",
    "In this case, it is 9 .",
    "Hence, 10 - 9 = 1 .",
    "1 is the answer.",
    "The remainder can only be between 0 and denominator - 1 .",
    "Try it!",
    "0 % 4 = ?",
    "1 % 4 = ?",
    "2 % 4 = ?",
    "3 % 4 = ?",
    "4 % 4 = ?",
    "5 % 4 = ?",
    "6 % 4 = ?",
    "0 % 4 = 0",
    "1 % 4 = 1",
    "2 % 4 = 2",
    "3 % 4 = 3",
    "4 % 4 = 0",
    "5 % 4 = 1",
    "6 % 4 = 2",
    "What would 3 % 0 be?",
    "It would have a similar behavior to 3 / 0 .",
    "There will be a compile-time warning, and a run-time undefined behavior.",
    "2.3.5.  Assignment operators #",
    "The assignment operator ( = , += , -= , *= , /= , %= ) assigns an evaluation/value to a variable.",
    "For example, in int x = 7 + 3; the = assigns the value of 7 + 3 to x .",
    "The precedence of assignment operators is after the other BEDMAS operators.",
    "Other assignment operators such as += , -= , *= , /= , %= mean that the variable is assigned to the variable plus/minus/multiplied/divided/modulo the value on the right.",
    "For example, x += 3 is equivalent to x = x + 3 and x %= 10 is equivalent to x = x % 10 .",
    "Tricky! If we have x *= 3 + 2 , it is equivalent to x = x * 5 .",
    "This implies that the BEDMAS operators are evaluated before the assignment operators.",
    "As discussed earlier in Basic arithmetic operations , BEDMAS operators if they have the same precedence, they are evaluated from left to right (left-associative).",
    "Assignment operators are the opposite , from right to left (right-associative).",
    "This means that x = y = z is equivalent to x = (y = z) .",
    "Here, y = z is evaluated first, it returns the value of y , then the value of y is assigned to x .",
    "An example code is shown below.",
    "However, for readability and to be able to easily spot bugs, we suggest having fewer operations in one line.",
    "2.3.6.  Increment and decrement operators #",
    "If we have i = i + 1; , this can be written as i += 1; , i++; and ++i; .",
    "Similarly, i -= 1; , i--; and --i; are equivalent to i = i - 1; .",
    "++ and -- are increment and decrement operators.",
    "They increment/decrement the value of the variable by 1.",
    "AVOID USING ++ AND -- IN A COMPLEX EXPRESSION!",
    "++ AND -- can be before or after the variable.",
    "For example, ++i and i++ are pre-increment and post-increment respectively.",
    "++i and i++ are equivalent to i = i + 1; if they are the only operators in the same statement.",
    "However, if there are other operators in the same statement, they are not equivalent.",
    "For example, in the following example ++i is pre-fix, i.e. incrementing happens in the statement.",
    "Hence, j = ++i; is equivalent to j = i = i + 1; .",
    "Evaluation is from right to left because of the assignment operator.",
    "While, i++ is post-fix, i.e. incrementing to i happens after the statement.",
    "This means that j = i++; is equivalent to j = i; i = i + 1; .",
    "You can download the code prefix-postfix.c to try the following code.",
    "It is confusing when the increment/decrement operator is used with other operators.",
    "Consequently, it is best to avoid using ++ and -- in a complex expression – with other operators.",
    "2.3.7.  Type casting #",
    "We mentioned earlier, the most accurate data type is contagious.",
    "In some cases, you may want to force a data type on an operand.",
    "For example, in double x = 3/ 2; , to have x store 1.5 , you can change 3 to double by changing it to 3.0 as in double x = 3.0/ 2; .",
    "The other way is to type cast 3 like double x = (double) 3 / 2; .",
    "This is called type casting.",
    "This changes the data type of 3 to double.",
    "Another example, in double x = 3/ 2.9; , you may want to force 2.9 to be int .",
    "You can do this by double x = 3/ (int) 2.9; .",
    "This will store 1.0 in x .",
    "The type casting operator is ( and ) .",
    "The data type is placed in between the brackets.",
    "For example, (int) 3.9 will evaluate as 3 .",
    "(double) 3 will evaluate as 3.0 .",
    "2.3.8.  sizeof()  operator #",
    "sizeof(<data type>) is an operator that evaluates the number of bytes required to store a data type on the operating computer.",
    "For example, sizeof(int) will evaluate as 4 , sizeof(double) will evaluate as 8 , and sizeof(char) will evaluate as 1 on my personal computer.",
    "2.3.9.  Summary of Precedence #",
    "(<type>) sizeof() ++ or -- (but we will avoid using ++ or -- with other operators)",
    "* / %",
    "+ - (2–4) if two operands with same precedence occur, they are evaluated from left to right (left-associative).",
    "+ -",
    "(2–4) if two operands with same precedence occur, they are evaluated from left to right (left-associative).",
    "= += -= *= /= %= (5) if two operands with same precedence occur, they are evaluated from right to left (right-associative).",
    "= += -= *= /= %=",
    "(5) if two operands with same precedence occur, they are evaluated from right to left (right-associative).",
    "Quiz",
    "0 Questions",
    "2.4.  Math library #",
    "In the previous section, we study simple arithmetic operations.",
    "Operations in real life will be more complicated, such as finding the logarithm of a number.",
    "In this section, we will learn about a math library that provides us access to complicated operations, such as \\(\\log\\) , \\(\\tan\\) , \\(\\sin\\) , \\(\\cos\\) and many more.",
    "2.4.1.  Complicated math operations #",
    "For example, we want to get the hypotenuse of a right-angled triangle with sides \\(a\\) and \\(b\\) .",
    "The hypotenuse is the longest side of the right-angled triangle.",
    "The hypotenuse is given by the formula: \\(c = \\sqrt{a^2 + b^2}\\) .",
    "Since, a square root is a complicated operation, we use the math library to get the square root of a number.",
    "We use sqrt function to get the square root of a number.",
    "A function has inputs and outputs.",
    "sqrt has input or receives a double and has output or returns the square root of the input in double type, as shown in the following figure.",
    "We can also say double sqrt(double x) to represent the input as double (between brackets), and output as double , written before sqrt .",
    "Fig. 2.2  sqrt  function in math library with prototype  double   sqrt(double   x) #",
    "Line 1 includes the math library, without which we can not use math library functions.",
    "Line 11 in the following code uses sqrt function to get the square root of \\(a^2 + b^2\\) .",
    "Download hypotenuse.c to get the following code.",
    "Want fewer lines?",
    "You can also write the above code in fewer lines as shown below.",
    "Line 7 shows us how can scanf allow entry of more than one variable at a time.",
    "This is given that the inputs are separated using a space, return or tab.",
    "For example, 2.5 ad 4.1 were separated using a space.",
    "The space, return or tab are called delimiters when they specify boundaries between separate values.",
    "2.4.2.  You can still use integer values #",
    "You can use sqrt in the following use cases:",
    "It can accept an int too.",
    "In line 4 in the following code, implicit type conversion from int 2 to double 2.0 will occur.",
    "The output will be Square root of 2 is 1.41 .",
    "Code #include <math.h> #include <stdio.h> int main(void){ printf(\"Square root of 2 is %.2lf\\n\", sqrt(2)); return 0; }",
    "It can accept an int too.",
    "In line 4 in the following code, implicit type conversion from int 2 to double 2.0 will occur.",
    "The output will be Square root of 2 is 1.41 .",
    "The output can be stored in an int too.",
    "In line 4 in the following example, the value returned from sqrt(3.0) – 1.73205… – will be truncated and stored in val as 1 .",
    "Code #include <math.h> #include <stdio.h> int main(void){ int val = sqrt(3.0); return 0; }",
    "The output can be stored in an int too.",
    "In line 4 in the following example, the value returned from sqrt(3.0) – 1.73205… – will be truncated and stored in val as 1 .",
    "2.4.3.  Other math library functions #",
    "Some of the relevant math library functions are listed below.",
    "Mathematical notation Function Prototype What does it do? Example",
    "\\(\\sqrt{x}\\) double   sqrt(double   x); returns the square root of  x sqrt(4)  returns  2.0",
    "\\(x^y\\) double   pow(double   x,   double   y); returns  x  to the power of  y pow(2,   3)  returns  8.0",
    "\\(e^x\\) double   exp(double   x); returns  e  – Euler’s number – to the power of  x exp(1)  returns  2.718281828459045",
    "\\(\\log_{10}x\\) 1 double   log10(double   x); returns the logarithm to the base 10 of  x log10(100)  returns  2.0",
    "\\(\\ln(x)\\) double   log(double   x); returns the natural logarithm of  x log(M_E) 2  returns  1.0",
    "\\(\\mid x \\mid\\) double   fabs(double   x); returns the absolute value of  x fabs(-2)  returns  2.0",
    "\\(\\sin(x)\\) double   sin(double   x); returns the sine of  x , where  x  is in radians (not degrees) sin(M_PI   *   2) 3  returns  0.0",
    "\\(\\cos(x)\\) double   cos(double   x); returns the cosine of  x , where  x  is in radians (not degrees) cos(M_PI   *   2) 3  returns  1.0",
    "\\(\\tan(x)\\) double   tan(double   x); returns the tangent of  x , where  x  is in radians (not degrees) tan(M_PI) 3  returns  0.0",
    "\\(\\sin^{-1}(x)\\)  or  \\(\\arcsin(x)\\) double   asin(double   x); returns the arc sine of  x  in radians (not degrees) asin(0.5)  returns  0.523599",
    "\\(\\cos^{-1}(x)\\)  or  \\(\\arccos(x)\\) double   acos(double   x); returns the arc cosine of  x  in radians (not degrees) acos(0.5)  returns  1.047198",
    "\\(\\tan^{-1}(x)\\)  or  \\(\\arctan(x)\\) double   atan(double   x); returns the arc tangent of  x  in radians (not degrees) atan(2)  returns  1.107149",
    "\\(\\max(x)\\) double   fmax(double   x,   double   y); returns the maximum of  x  and  y fmax(3.2,   -7.9)  returns  3.2",
    "\\(\\min(x)\\) double   fmin(double   x,   double   y); returns the minimum of  x  and  y fmin(-6.1,   -7.3)  returns  -7.3",
    "\\(\\lfloor x \\rfloor\\) double   floor(double   x); returns the greatest integer that is less than or equal to  x , i.e., rounds down  x floor(9.6)  returns  9.0",
    "\\(\\lceil x \\rceil\\) double   ceil(double   x); returns the smallest integer that is greater than or equal to  x , i.e., rounds up  x ceil(3.09)  returns  4.0",
    "\\(x \\mod y\\) double   fmod(double   x,   double   y); returns the remainder 4  of  x   /   y . Recall  %  operator is for  int  operands only, while  fmod  is for  double  operands too. fmod(5.3,   2.1)  returns  1.1",
    "\\(\\lfloor x \\rceil\\) double   rint(double   x); returns the nearest integer to x, i.e., rounds  x rint(-2.1)  returns  -2.0",
    "2.4.4.  Example use cases for math library functions #",
    "Exercise 1",
    "Write a program that takes in from a user a floating point number and rounds it to the nearest 10th, i.e. , first decimal place.",
    "Step 1: Toy example.",
    "To understand the problem, we need to start by thinking of a toy example .",
    "For example, \\(2.18\\) rounded to the first decimal place is \\(2.2\\) .",
    "Step 2: Think of a solution.",
    "However, rint function only rounds to the nearest integer, not to the nearest decimal places.",
    "So, we need to think of a solution that will round to the nearest decimal places.",
    "Step 3: Decompose solution into steps.",
    "The trick is to get the decimal place into the integer part.",
    "For example, we can move the first decimal to the integer part from \\(2.18\\) to \\(21.8\\) .",
    "Now, we can use rint to round to the nearest integer, which makes \\(22.0\\) .",
    "Moving the decimal back gets us \\(2.2\\) , which is what we want.",
    "Step 4 (optional, but very helpful): Draw your solution.",
    "Fig. 2.3  Trials into developing a solution for rounding to the nearest 10th. #",
    "Step 5: Make sure your steps works on other toy examples.",
    "For example, try testing your code with a negative number or a umber where the first decimal place is above \\(5\\) .",
    "Try whatever you think might break your code.",
    "E.g. \\(-1.87 \\times 10 = -18.7\\) , rint(-18.7) returns -19.0 , then finally \\(-19.0 / 10 = -1.9\\) , which is what we want.",
    "Step 6: Write the code.",
    "Download nearest10.c to get the following code.",
    "Exercise 2",
    "Canada does not have pennies.",
    "The lowest value coin is a nickel, which is worth 5 cents.",
    "Write a program that takes in from a user a floating point number price and rounds it to the nearest nickel.",
    "Step 1: Toy example.",
    "\\(2.94\\) when rounded to the nearest nickle is \\(2.95\\) .",
    "\\(2.92\\) when rounded to the nearest nickle is \\(2.90\\) .",
    "\\(1.98\\) is \\(2.00\\) .",
    "\\(7.83\\) is \\(7.85\\) .",
    "Step 2: Think of a solution.",
    "We can use a similar trick as in Exercise 1.",
    "However, if we do the same as in Exercise 1, we will round to the nearest dime, which is 10 cents.",
    "Example, \\(2.94 \\times 10\\) \\(\\rightarrow\\) \\(29.4\\) .",
    "29.4 is the number of 10 cents in \\(\\$2.95\\) .",
    "rint(29.4) \\(\\rightarrow\\) \\(29.0\\) \\(\\rightarrow\\) \\(29.0 / 10\\) \\(\\rightarrow\\) \\(2.9\\) .",
    "That is not what we want! We want to \\(2.95\\) .",
    "Step 3: Decompose solution into steps.",
    "We need to round to the nearest nickel, which is 5 cents.",
    "So, we need to get the number of nickles in \\(2.94\\) , and round that decimal number to the nearest whole nickle.",
    "For example, \\(2.94 \\times 100 / 5\\) \\(\\rightarrow\\) \\(58.8\\) .",
    "58.8 is the number of nickles in \\(\\$2.94\\) .",
    "rint(58.8) returns \\(59.0\\) nickles, which make \\(59.0 \\times 5 / 100\\) \\(\\rightarrow\\) \\(\\$2.95\\) .",
    "This is what we want!",
    "Step 4 (optional, but very helpful): Draw your solution.",
    "Fig. 2.4  Trials into developing a solution for rounding to the nearest nickle. #",
    "Step 5: Make sure your steps works on other toy examples.",
    "For example, where the nearest nickle changes the entire number as \\(1.98\\) .",
    "\\(1.98 \\times 100 / 5 = 39.6\\) , rint(39.6) returns 40.0 , which makes \\(40.0 / 100 \\times 5 = 2.0\\) , which is \\(1.98\\) rounded to the nearest nickle.",
    "Step 6: Write the code.",
    "Download nearest-nickle.c to get the following code.",
    "Quiz",
    "0 Questions",
    "To get the \\(\\log_{n}(x)\\) , \\(\\log\\) base \\(n\\) of \\(x\\) , where \\(n\\) is any number, recall you can always use the following \\(\\log_{n}(x) = \\frac{\\log_{10} (x)}{\\log_{10} (n)}\\) .",
    "In C, log10(x)/log10(n) to calculate \\(\\log_{n}(x)\\) .",
    "M_E is a constant defined in math library, denoting the value of constant \\(e\\) .",
    "It is approximately equal to 2.718281828…",
    "M_PI is a constant defined in math library, denoting the value of \\(\\pi\\) .",
    "It is approximately equal to 3.14159…",
    "How do we get remainders for floating point numbers?",
    "For example, \\(\\frac{5.3}{2.1}\\) yields \\(2.523...\\) .",
    "To get the remainder of this division, we remove the whole number \\(2\\) from \\(2.523...\\) , and we are left with \\(0.523...\\) .",
    "The remainder would be \\(0.523...",
    "\\times 2.1\\) .",
    "Hence, fmod(5.3, 2.1) is \\(1.1\\) .",
    "2.6.  Exercises #",
    "Many of these exercises are taken from past exams of APS105 Computer Fundamentals courses at University of Toronto.",
    "The solutions are provided in the answer boxes.",
    "2.6.1.  Math library Functions #",
    "2.6.1.1.  Practice 1 #",
    "Question 1 in Winter 2020 Final Exam",
    "Write a single C statement using no curly brackets that rounds a double-type variable named value to its nearest hundredths place, and assign the result to a new double-type variable named approximateValue .",
    "For example, rounding 0.843 to the nearest hundredth would give 0.84.",
    "You can use any of the C math library functions.",
    "Write your solution in the box below",
    "2.6.1.2.  Practice 2 #",
    "Modified Version of Question 3 in Fall 2014 Midterm",
    "Write a single C statement that will compute the value of r according to the following expression, and assign the value to r .",
    "\\(r = \\frac{x^n + 6 \\times x^4}{\\sin(y) + \\cos(z)}\\)",
    "You can assume that all the variables in the expression are already declared as double types, and that the math library (described by the header file math.h) is available, and that the value of y and z is in radians.",
    "2.6.1.3.  Practice 3 #",
    "Question 5 in Winter 2018 Midterm Exam",
    "The variable numApples is an int type variable representing the number of apples in a barrel.",
    "The owner of the apples is deciding whether to sell them in packages of \\(3\\) or \\(5\\) apples.",
    "Write a single C statement that declares and initializes an int type variable called leftover .",
    "leftover should be initialized to the minimum of two quantities: 1) the number of apples left over when the barrel of apples is packaged into groups of \\(3\\) ; 2) the number of apples left over when the barrel of apples is packaged into groups of \\(5\\) .",
    "Hint: Use a function in the math library",
    "2.6.1.4.  Practice 4 #",
    "Question 8 in Winter 2019 Midterm Exam",
    "If you have a certain number of US dollars and wish to convert them to Canadian dollars, you could use the Canadian dollar to US dollar exchange rate (for example: 1 Canadian dollar = \\(0.75\\) US dollar).",
    "Write a complete C program that prompts its user for the current Canadian dollar to US dollar exchange rate (e.g. \\(0.75\\) ) and a value in US dollars, and then prints the value in Canadian dollars, rounding to the nearest hundredth.",
    "Your program will print the value with \\(6\\) digits after the decimal point.",
    "Assume the user provides a valid exchange rate and US dollar amount.",
    "Here is an example run of your program:",
    "Download exercise-usd-to-cad.c to get the following code.",
    "2.6.2.  Random Number Generation #",
    "2.6.2.1.  Practice 1 #",
    "Question 2 in Fall 2018 Final Exam Write a single C statement that generates a random even number in the range of [-150, 150] (inclusive), and uses it to declare and initialize an int-type variable randomChoice .",
    "Get a range from -75 to 75.",
    "Then get from that 150, 148, …, -2, 0, 2, …, 148, 150.",
    "2.6.2.2.  Practice 2 #",
    "Question 2 in Winter 2017 Final Exam",
    "Write a single C statement that declares a double variable randomSelection , and initializes it with a number that is randomly selected from the following set: 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95.",
    "2.6.2.3.  Practice 3 #",
    "Question 2 in Fall 2022 Final Exam",
    "Write a single C statement that declares a char variable called randomCharacter , and initializes it to a random value draw from one of the three characters: ‘A’, ‘B’, ‘C’.",
    "2.  Data representation and operations #",
    "In the previous chapter, we covered the context of developing a program in a computer.",
    "In this chapter, we will dig deeper into the details of program development.",
    "More specifically, we will see different data types, how data is represented in the computer memory and how operations are performed on this data.",
    "2.1.  Double data type for real numbers #",
    "In the previous chapter, we developed a program to calculate the number of slices in a number of pizzas.",
    "The number of slices and pizzas were considered integers, i.e. whole numbers with no fractions.",
    "However, if a kid decided to take a bite and run 🏃‍♀️, we will be left with a fraction of a slice.",
    "At this point, we need fractional numbers/real numbers.",
    "Another example, if we want to convert temperatures from Celsius to Fahrenheit, or centimeters to inches, we need to use fractional numbers - with decimal component.",
    "In this section, we will see how to represent numbers using fractional in our programs.",
    "2.1.1.  Example: Convert Inches to Centimeters #",
    "Write a program that converts inches to centimeters.",
    "The program should prompt the user for a number of inches and then output the equivalent number of centimeters.",
    "The conversion factor is \\(2.54\\) centimeters per inch.",
    "Download inches-to-centimeters.c to get the following source code.",
    "Let’s understand what each line is doing.",
    "const double InchesToCm = 2.54; .",
    "const  is a keyword that indicates that the variable  InchesToCm  is a constant. The variable  InchesToCm  cannot be changed throughout the code. This will cause an error during compilation. \n \n Exercise: Change a constant variable \n When I added in line 8  InchesToCm   =   2.53; , which changes a  const  variable, the compiler gave me the following error. This is helpful because the  const  keyword guards against  mistakenly  changing a variable. \n \n \n \n Fig. 2.1  Changing a constant variable compilation error #",
    "const is a keyword that indicates that the variable InchesToCm is a constant.",
    "The variable InchesToCm cannot be changed throughout the code.",
    "This will cause an error during compilation.",
    "Exercise: Change a constant variable",
    "When I added in line 8 InchesToCm = 2.53; , which changes a const variable, the compiler gave me the following error.",
    "This is helpful because the const keyword guards against mistakenly changing a variable.",
    "Fig. 2.1  Changing a constant variable compilation error #",
    "double is a data type that indicates that the variable InchesToCm is a fractional number.",
    "Think! What would happen if a number with decimal is stored in an int 🤔?",
    "If a number with decimal is stored in an int , the decimal part will be truncated.",
    "For example, if we store 2.54 in an int , the value actually stored will be 2 .",
    "double is a data type that indicates that the variable InchesToCm is a fractional number.",
    "What would happen if a number with decimal is stored in an int 🤔?",
    "If a number with decimal is stored in an int , the decimal part will be truncated.",
    "For example, if we store 2.54 in an int , the value actually stored will be 2 .",
    "2.54 is the value assigned to the variable InchesToCm .",
    "double inputInches, outputCm; declares two variables of type double .",
    "The variables inputInches and outputCm are used to store the input and output values of the program.",
    "These inputs can be fractional numbers.",
    "printf(\"Enter the number of inches to convert to cm: \"); prints on the monitor a prompt to ask the user to enter inches to convert.",
    "scanf(\"%lf\", &inputInches); reads the input from the user and stores it in the variable inputInches .",
    "The %lf is a format specifier that indicates that the input is a fractional number.",
    "The & is the address-of operator that indicates the address of the variable inputInches .",
    "The address of a variable is the location in memory where the variable is stored.",
    "The scanf function will store the input in the memory location of the variable inputInches .",
    "outputCm = inputInches * InchesToCm; will multiply the value in inputInches and InchesToCm and store the result in outputCm .",
    "The * is the multiplication operator.",
    "printf(\"The number of centimeters is %.2lf\\n\", outputCm); prints on the monitor the value of outputCm with 2 decimal places.",
    "The %lf is a format specifier that indicates that the value is a fractional number.",
    "The .2 indicates that the value should be printed with 2 decimal places.",
    "2.1.2.  Summary #",
    "So far we discussed two data types in C:",
    "int : It stores a whole number/integer, either 0, negative or positive.",
    "For example, 0, -1, or 100 are all integers.",
    "Format specifier of int is %d .",
    "int : It stores a whole number/integer, either 0, negative or positive.",
    "For example, 0, -1, or 100 are all integers.",
    "Format specifier of int is %d .",
    "double : It stores a fractional number, which is any number on the number line.",
    "For example, -2.1, 0.0001, or 3.14 are all fractional numbers.",
    "Format specifier of double is %lf .",
    "double : It stores a fractional number, which is any number on the number line.",
    "For example, -2.1, 0.0001, or 3.14 are all fractional numbers.",
    "Format specifier of double is %lf .",
    "When you are planning your program, you must think of the variables you need and their data types.",
    "For example, if you have a variable storing:",
    "number of attendees: int",
    "price of a ticket: double",
    "number of protons in Calcium: const int",
    "value of \\(\\pi\\) : const double",
    "In the next section, we will see are these data types stored in the memory.",
    "Quiz",
    "0 Questions",
    "2.2.  Data types and representation #",
    "Different data types are stored differently in the memory, i.e. different variable types use different amounts of memory.",
    "2.2.1.  Integers #",
    "int are stored using 32 bits, and as we mentioned in How is the 0s and 1s of data memory organized?",
    ", each cell in the memory stores a byte.",
    "Hence, int variables use 4 bytes/cells of memory.",
    "31 of the bits are used to represent the integer itself and 1 bit is representing the sign.",
    "The sign bit is 0 for positive numbers or 0, and 1 for negative numbers.",
    "Since the number of bits is determined, there is a maximum range of numbers that can be represented using int .",
    "As we discussed in How many bits do we need to represent x numbers?",
    ", we can represent \\(2^n\\) numbers using \\(n\\) bits.",
    "Since one bit is reserved for the sign of the number, we have 31 bits left.",
    "We can represent \\(2^{31}\\) negative numbers, i.e. from \\(-2^{31}\\) to \\(-1\\) .",
    "For 0 and positive numbers we have \\(2^{31}\\) representations, i.e. from 0 to \\(2^{31} - 1\\) .",
    "There are other data types to represent integers, such as:",
    "short representation typically uses 16 bits, i.e. 2 bytes of memory.",
    "unsigned int representation typically uses 32 bits, i.e. 4 bytes of memory.",
    "The sign bit is not used, so the range of numbers is from 0 to \\(2^{32} - 1\\) .",
    "unsigned int representation typically uses 32 bits, i.e. 4 bytes of memory.",
    "The sign bit is not used, so the range of numbers is from 0 to \\(2^{32} - 1\\) .",
    "long representation typically uses 64 bits, i.e. 8 bytes of memory.",
    "long long representation typically uses 64 bits, i.e. 8 bytes of memory.",
    "For the purpose of this course, you are expected to only know int data type out of all integer data types.",
    "Format specifier for int is %d .",
    "2.2.2.  Floating point or real numbers #",
    "Floating point binary representation is similar to standard notation, e.g. \\(2.89 \\times 10^{14}\\) or \\(2.89e14\\) or \\(2.89E14\\) .",
    "Formally, the number is represented as \\(m \\times 10^e\\) , where \\(m\\) is the mantissa and \\(e\\) is the exponent.",
    "The mantissa is a number between 1 and 10, and the exponent is an integer.",
    "The sign of the number is represented by the sign of the mantissa.",
    "The floating point number in binary form represents the mantissa and the exponent separately.",
    "We do not need to know how.",
    "There are two data types to represent floating point numbers:",
    "float uses 32 bits, i.e. 4 bytes of memory.",
    "double uses 64 bits, i.e. 8 bytes of memory.",
    "Since double data types uses double the number of bits to represent the floating point number, it is more precise than float data type.",
    "Hence, double is referred to have “double precision” and float as “single precision”.",
    "double uses 64 bits, i.e. 8 bytes of memory.",
    "Since double data types uses double the number of bits to represent the floating point number, it is more precise than float data type.",
    "Hence, double is referred to have “double precision” and float as “single precision”.",
    "For the purpose of this course, we will be using double data type only.",
    "Format specifier for float is %f and for double is %lf .",
    "2.2.3.  Characters #",
    "To represent a single letter, symbol or digit, we can use the char data type.",
    "Example characters include A , B , … Z , a , b , … z , 0 , 1 , … 9 , @ , # , $ and other symbols.",
    "This code snippet would print S on the screen.",
    "The format specifier for char is %c .",
    "char is stored using 8 bits, i.e. 1 byte of memory.",
    "Each character is encoded into a unique number, and the number is stored in one cell of the memory.",
    "How does this unique number look like?",
    "The number is called American Standard Code for Information Interchange (ASCII) code.",
    "ASCII code is a standard encoding scheme for characters.",
    "It uses only 7-bits and the eighth bit is set to \\(0\\) .",
    "Since we are using 7 bits, then the ASCII code table has numbers between \\(0\\) and \\(2^7 -1\\) , which is 128 numbers.",
    "Part of the ASCII code table is shown below, but you are NOT expected to memorize it.",
    "Character ASCII code (Decimal) ASCII code (Binary)",
    "A 65 01000001",
    "B 66 01000010",
    "C 67 01000011",
    "⋮ ⋮ ⋮",
    "Z 90 01011010",
    "a 97 01100001",
    "b 98 01100010",
    "c 99 01100011",
    "⋮ ⋮ ⋮",
    "z 122 01111010",
    "0 48 00110000",
    "1 49 00110001",
    "2 50 00110010",
    "⋮ ⋮ ⋮",
    "9 57 00111001",
    "2.2.4.  Boolean #",
    "Boolean bool data type is used to represent a logical value, i.e. either true or false .",
    "In C, true is represented by 1 and false is represented by 0 .",
    "Sounds like we only need one bit for that nice data type in the memory, right?",
    "As much as bool requires only one bit, but we cannot organize the memory as we like.",
    "The memory is organized into cells, and each cell stores a byte.",
    "The smallest possible memory space we can use is a cell in the memory.",
    "So bool data type uses 1 byte of memory.",
    "Write a C code that prints a bool variable.",
    "Code in isRaining.c .",
    "There is no format specifier for bool specifically.",
    "We use %d to print the value (either 0 or 1) of a boolean variable.",
    "Hence, the above code prints Is it raining?",
    "1 NOT Is it raining?",
    "true .",
    "If you noticed, apart from #include <stdio.h> which gives us access to printf and scanf functions, we included another library for bool variables in #include <stdbool.h> .",
    "Without this library, the compiler won’t identify the bool variable type.",
    "2.2.5.  Declaring Vs. Initializing Variables #",
    "In your code, if you need to declare a variable, you do it as follows",
    "The compiler will understand that you declared a variable with int type and identifier var .",
    "When running your code, the computer will reserve a space for it in the memory.",
    "The question is, what is the value of this declared variable?",
    "The answer is not 0 .",
    "The variable is uninitialized .",
    "It is not holding any value.",
    "It is just a variable that is declared, but not initialized.",
    "To be more specific, if you try printing the value of the declared but uninitialized variable, you print the value that is there in the memory location of the variable.",
    "Probably this value was there before the program started running.",
    "It is a random value.",
    "Some people call it “garbage” value.",
    "For example, when I ran the code below on my computer, the value in var variable was 174739296 , because I never initialized var .",
    "However, when you run the code, you may get a different value.",
    "The value will be different for each run too.",
    "You can download from declare-vs-initialize.c to play with the code.",
    "If you compile the code above, you will get a warning stating: variable ‘var’ is uninitialized when used here [-Wuninitialized] .",
    "The compiler will also ask you to initialize var to silence the warning.",
    "This becomes a problem, if you are unaware of it.",
    "If you use an uninitialized variable later, your program’s behavior will be undefined.",
    "Therefore, it is best practice to declare a variable AND initialize it, e.g. int var = 0; .",
    "int var declares the var variable and = 0; initializes the var variable to 0 .",
    "2.2.6.  Taking in input from the user using  scanf #",
    "Given that we now know the format specifiers of int , double , char and bool data types, there are a few tricks you need to know as you use these to take input from the user using scanf .",
    "Take multiple numbers in multiple variables.",
    "You can take multiple numbers from the user in one single scanf .",
    "The scanf should separate the format specifiers by a space.",
    "The user should separate the numbers by delimiters .",
    "Delimiters can be a space, return or tab and are used to separate two different inputs.",
    "An example code that takes multiple numbers as input from user is shown below.",
    "Code #include <stdio.h> int main(void) { int num1 = 0, num2 = 0; double dnum1 = 0, dnum2 = 0; printf(\"Enter a number: \"); scanf(\"%d %lf %d %lf\", &num1, &dnum1, &num2, &dnum2); printf(\"Numbers entered: %d %lf %d %lf\\n\", num1, dnum1, num2, dnum2); return 0; }",
    "Take multiple numbers in multiple variables.",
    "You can take multiple numbers from the user in one single scanf .",
    "The scanf should separate the format specifiers by a space.",
    "The user should separate the numbers by delimiters .",
    "Delimiters can be a space, return or tab and are used to separate two different inputs.",
    "An example code that takes multiple numbers as input from user is shown below.",
    "Take numbers and characters.",
    "You can take numbers and characters in the same scanf line.",
    "The example code shown below takes in an ID from the user that begins with a character and is followed by a number.",
    "It does not require a delimiter between the character entered and the numbers.",
    "This is because the %c format specifier will take one character, and stop taking more input.",
    "The rest will be taken by %d .",
    "If the user enters a space between the character and the numbers it will be ignored.",
    "Code #include <stdio.h> int main(void) { char idChar; int idNum; printf(\"Enter your ID: \"); scanf(\"%c %d\", &idChar, &idNum); printf(\"ID entered: %c%d\\n\", idChar, idNum); return 0; } You can also write the code above with no spaces between %c and %d in scanf as follows.",
    "Code #include <stdio.h> int main(void) { char idChar; int idNum; printf(\"Enter your ID: \"); scanf(\"%c%d\", &idChar, &idNum); printf(\"ID entered: %c%d\\n\", idChar, idNum); return 0; } Code #include <stdio.h> int main(void) { char idChar; int idNum; printf(\"Enter your ID: \"); scanf(\"%d%c\", &idNum, &idChar); printf(\"ID entered: %c%d\\n\", idChar, idNum); return 0; }",
    "Take numbers and characters.",
    "You can take numbers and characters in the same scanf line.",
    "The example code shown below takes in an ID from the user that begins with a character and is followed by a number.",
    "It does not require a delimiter between the character entered and the numbers.",
    "This is because the %c format specifier will take one character, and stop taking more input.",
    "The rest will be taken by %d .",
    "If the user enters a space between the character and the numbers it will be ignored.",
    "You can also write the code above with no spaces between %c and %d in scanf as follows.",
    "Take in characters and ignoring leading spaces.",
    "If you want to take in character by character, but you are entering spaces or returns between them, what should you do?",
    "To ignore spaces between characters entered, you need to add a space between the format specifier %c .",
    "For example, the following code takes in the 4 letters and three numbers of a license plate in Ontario.",
    "If you do not add a space between the %c , any delimiter entered will be considered a character, and taken into the character variable.",
    "Code #include <stdio.h> int main(void) { char c1, c2, c3, c4, c5, c6, c7; printf(\"Enter license plate letters and numbers: \"); scanf(\"%c %c %c %c %c %c %c\", &c1, &c2, &c3, &c4, &c5, &c6, &c7); printf(\"Licence plate entered: %c%c%c%c-%c%c%c\\n\", c1, c2, c3, c4, c5, c6, c7); return 0; }",
    "Take in characters and ignoring leading spaces.",
    "If you want to take in character by character, but you are entering spaces or returns between them, what should you do?",
    "To ignore spaces between characters entered, you need to add a space between the format specifier %c .",
    "For example, the following code takes in the 4 letters and three numbers of a license plate in Ontario.",
    "If you do not add a space between the %c , any delimiter entered will be considered a character, and taken into the character variable.",
    "Common mistake: Spaces after format specifiers Do not include a space after a format specifier, if there is no format specifier after it in scanf , like scanf(\"%d \", &num); .",
    "This is because scanf will wait for a delimiter after you enter your number and another input too.",
    "Although it won’t put that second input into another variable.",
    "For example, the following code will not proceed with executing other statements unless you enter another input after your number.",
    "Code #include <stdio.h> int main(void) { double dnum1 = 0; printf(\"Enter a number: \"); scanf(\" %lf \", &dnum1); printf(\"Number entered: %.2lf\\n\", dnum1); return 0; }",
    "Common mistake: Spaces after format specifiers",
    "Do not include a space after a format specifier, if there is no format specifier after it in scanf , like scanf(\"%d \", &num); .",
    "This is because scanf will wait for a delimiter after you enter your number and another input too.",
    "Although it won’t put that second input into another variable.",
    "For example, the following code will not proceed with executing other statements unless you enter another input after your number.",
    "Quiz",
    "0 Questions",
    "2.5.  Random numbers #",
    "Throughout this chapter, we discussed different operations.",
    "Simple operations include + , - , / , * , % , = , += , -= , *= , /= , %= , and complicated operations from the math library like rint , fmax , fmin , ceil , floor .",
    "These operations were on different data types like int and double .",
    "In some cases, we need to generate a random number, e.g. if we were to develop a head or tail game, we would need to generate two random numbers, maybe \\(0\\) representing a head and \\(1\\) representing a tail.",
    "In this section, we will discuss how to generate a random number in C.",
    "2.5.1.  Generating a random number #",
    "We will need the rand function from stdlib.h library, which is referred to as the standard library.",
    "The prototype of the rand function is as follows:",
    "rand does not take as input anything.",
    "It produces an int value that can range from 0 to RAND_MAX , where RAND_MAX is a constant defined in stdlib.h library.",
    "It is the maximum +ve value that can be represented by an int .",
    "The value of RAND_MAX is \\(2^{31} - 1 = 2147483647\\) .",
    "Let’s try running the following code.",
    "Wait! I tried running the code again, and I got the same numbers.",
    "How is rand() then generating a random number?",
    "The answer is that rand() is generating pseudo -random numbers.",
    "A pseudo -random number is a number that appears to be random, but is actually not 🤯.",
    "Who decides these pseudo -random numbers?",
    "It is a pseudo-random number generator.",
    "As programmers, we can choose our pseudo-random number generator.",
    "We can do so by setting a seed .",
    "What on earth is a seed ?",
    "A seed is used to initialize a pseudo-random number generator.",
    "This generator is responsible for generating a set of random numbers every time rand is called.",
    "To choose a seed, we will use a function whose prototype is void srand(unsigned int); .",
    "It takes the seed with a type unsigned int as input and sets the seed of the pseudo -random number generator.",
    "I hear you saying “Salma (your author), I feel lost.” Don’t worry, I will explain it with an example.",
    "Let’s say we want to generate the set of random numbers from seed 1 in the following figure, i.e. , \\(16807, 282475249, 1622650073 ...\\) .",
    "In our code, a line of code with srand(1); will initialize a pseudo-random number generator with seed 1.",
    "Fantastic! Next, the first time rand() is called after srand(1); , it will return 16807 , which is the first random number in seed 1 in the figure below.",
    "The next time rand() is called, it will return 282475249 , which is the second random number in seed 1, and so on.",
    "The default seed if we did not set the seed using srand() is 1 .",
    "Fig. 2.5  setting a seed of 1 using  srand(1); #",
    "In your code, if you re -initialize the seed using srand(1); , you will get the same set of random numbers again when you call rand() .",
    "This means, you will again get 16807 in the next rand() call.",
    "This is why we only initialize the seed with srand once in our code.",
    "This is illustrated in the following figure.",
    "Fig. 2.6  The subsequent calls to  rand()  after  srand(1);  will return the same set of random numbers. #",
    "The following code illustrates the subsequent calls to rand() after srand(1); .",
    "Download seed.c to get the following code.",
    "2.5.2.  Are we generating random numbers? #",
    "So far we found a way to generate pseudo-random numbers, and how to generate the same set of random number every run.",
    "If you have srand(1) with a fixed seed or no srand(x) at all, your program will generate the same set of pseudo-random numbers.",
    "Can we get closer to really random numbers?",
    "Yes, we can.",
    "If we use the current time as a seed, every time we run our program, our seed will be different.",
    "Hence, the set of random numbers change with every run! Voilà.",
    "We can use the time function from time.h library to get the current time.",
    "The prototype of the time function is as follows:",
    "When the time is called like this time(NULL) , it returns the Unix time, which is the current time in terms of the number of seconds since January 1, 1970.",
    "Fun fact 😎",
    "The data type time_t is a signed 32-bit int type representing the number of seconds since January 1, 1970.",
    "Hence, the maximum number of seconds that can be represented is \\(2^{31} -1 = 2147483647\\) .",
    "This will be 03:14:07 UTC January 19, 2038.",
    "After that, the Unix time will overflow and be a negative number representing 20:45:52 on Friday, 13 December 1901 🤯😵‍💫.",
    "This is called the Unix time overflow or Year 2038 problem.",
    "No one knows what will happen after that.",
    "Vulnerable systems include some databases, which includes bank accounts.",
    "You may have guessed the solution.",
    "Solution is as simple as switching to a 64-bit time_t data type.",
    "The following code will now generate different random numbers every time you run it.",
    "Download time-seed.c to get the following code.",
    "Question: If we do srand(rand()); instead of srand(time(NULL)); , would this make the seed random?",
    "The answer is NO .",
    "The first call to rand() in srand() would return the same random number everytime we run the program.",
    "The default seed has a default of 1 .",
    "This makes srand(rand()); always pick a fixed seed.",
    "2.5.3.  Random numbers within a range #",
    "Random numbers generated by rand() range from 0 to RAND_MAX .",
    "What if I want to generate numbers between 0 and 1 representing heads and tails?",
    "Recall the handy modulo operator % .",
    "If we do rand() % 2 , it will always generate a number between 0 and 1 .",
    "The result of any modulo operation is between 0 and 2nd operand - 1 .",
    "For example, % 5 returns numbers between 0 and 4 .",
    "0 % 5 = 0",
    "1 % 5 = 1",
    "2 % 5 = 2",
    "3 % 5 = 3",
    "4 % 5 = 4",
    "5 % 5 = 0 (repeats)",
    "6 % 5 = 1",
    "To generate a number between 0 and 5 , we need to do rand() % 6; .",
    "While to shift this range from 0 – 5 to 1 to 6 , we can add 1 to the range and make it (rand() % 6) + 1; .",
    "In general to generate a number between [MIN, MAX] (inclusive), we need to rand() % (MAX - MIN + 1) + MIN .",
    "For example, let’s develop a code for rolling a dice 🎲! We expect that every time we run the program we do not get the same dice number.",
    "Download roll-dice.c to get the following code.",
    "Quiz",
    "0 Questions",
    "11.2.  Recursion in Patterns #",
    "In the previous section, we discuss recursion in functions, e.g. greatest common divisor using euclidean algorithm or the factorial function.",
    "In this section, we discuss recursion in patterns.",
    "In general, recursive functions will have the following structure:",
    "11.2.1.  Print a row of stars #",
    "Let’s start with a simple example.",
    "We want to print a row of stars recursively.",
    "The number of stars in the row is given as an input to the function.",
    "Since the function only prints, it does not return any values to the calling function.",
    "The function prototype is as follows:",
    "Think recursively! We need to “think recursively” to develop a recursive function.",
    "This means we need to think of doing a small task in printing the row, then calling the same function, but on a smaller row, for example.",
    "We can print one star then, call printRow(n - 1); .",
    "However, we need to remember this is only the recursive call .",
    "The terminating case could be the smallest possible row of stars, for example, a row of one star.",
    "Given that, the base case is when n == 0 .",
    "In this case, we print *\\n only.",
    "The following figure illustrates the recursive thought process.",
    "Fig. 11.5  Print a row of stars recursively. #",
    "The following code uses the recursive function printRow .",
    "Download printRow.c if you want to run the program yourself.",
    "Line \\(15\\) will be executed only once in the base case, when n == 1 .",
    "Lines \\(17\\) to \\(18\\) will be executed several times as they are part of the recursive call till n == 1 .",
    "What happens when printRow(4) is called?",
    "Let’s trace printRow(4) .",
    "In Fig.",
    "11.6 , we show the order of execution.",
    "printRow(4) is called in main .",
    "n == 4 is not equal to 1 , so line \\(12\\) is executed.",
    "printRow(3) is called on line \\(13\\)",
    "n == 3 is not equal to 1 , so line \\(12\\) is executed.",
    "printRow(2) is called on line \\(13\\)",
    "n == 2 is not equal to 1 , so line \\(12\\) is executed.",
    "printRow(1) is called on line \\(13\\)",
    "n == 1 is equal to 1 , so line \\(10\\) is executed.",
    "printRow(1) should return to printRow(2) at line \\(13\\) when it was called, but there is no more code to execute in printRow(2) , so printRow(2) should return to printRow(3) , and so on.",
    "Fig. 11.6  The order of execution of  printRow(4) . #",
    "What if we switch the order of printf(“*”) and printRow(n - 1)?",
    "If we switch the order of printf(\"*\") and printRow(n - 1) as in the following code, the order of execution of print statements will be different.",
    "In Fig.",
    "11.7 , we show the order of execution when the order of printf(\"*\") and printRow(n - 1) is switched.",
    "In this case, the recursive call printRow(n - 1) is executed for all n first, then the printf(\"*\") statements will be executed.",
    "This will make the first executed printf statement to be the one in the base case, and the last print statement to be the one in the recursive call with largest n .",
    "Fig. 11.7  The order of execution of  printRow(4)  when the order of  printf(\"*\")  and  printRow(n   -   1)  is switched. #",
    "11.2.2.  Print a triangle of stars #",
    "Let’s take one more advanced step.",
    "We want to print a triangle of stars, as shown below, recursively .",
    "The number of rows in the triangle is given as an input to the recursive function.",
    "Since the function only prints, it does not return any values to the calling function.",
    "The function prototype is as follows:",
    "Think recursively! We need to “think recursively” to develop a recursive function.",
    "This means we need to think of doing a small task in printing the triangle, then calling the same function, but on a smaller triangle, for example.",
    "We can print a row of stars then, call printTriangle(n - 1); .",
    "However, we need to remember this is only the recursive call .",
    "The terminating case could be the smallest possible triangle, for example, a triangle with one row.",
    "Given that, the base case is when n == 1 .",
    "In this case, we print *\\n only.",
    "The following figure illustrates the recursive thought process.",
    "Fig. 11.8  Thinking recursively to print a triangle of stars. #",
    "The following code snippet is one way to implement the recursive function printTriangle .",
    "The function printRow is the same as the one we used in the previous section.",
    "Here, if n == 1 , we print 1 star and return.",
    "If n > 1 , we print a row of stars, then call printTriangle(n - 1) .",
    "If n < 1 , we do nothing.",
    "Code snippet",
    "The following code shows another way to implement the recursive function printTriangle .",
    "The function printRow is the same as the one we used in the previous section.",
    "Here, if n > 0 , we print a row of n starts using printRow(n) and call printTriangle(n - 1) .",
    "If n was exactly 0 , we print a 1 star using printRow(1) , then call printTriangle(0) .",
    "If n <= 0 , we do nothing.",
    "Hence, technically, when n == 1 , we only print one star.",
    "The base case is n <= 0 .",
    "Download printTriangle.c if you want to run the program yourself.",
    "The following figure shows the order of execution of printTriangle(4) .",
    "Fig. 11.9  Tracing print triangle function with n = 4:  printTriangle(4) . #",
    "11.2.3.  Print an inverted triangle of stars #",
    "What should we do differently to implement a recursive function that prints the same triangle we printed before but inverted?",
    "The triangle we want to print is as follows:",
    "The following figure illustrates the recursive thought process.",
    "We understand from the following figure that we should first print a smaller sized triangle, then print a row of n stars.",
    "This is reversed order of steps compared to Fig.",
    "11.8 , where we first printed a row of stars then a triangle of smaller size.",
    "Fig. 11.10  Thinking recursively to print an inverted triangle of stars. #",
    "The following code snippet is one way to implement the recursive function printInvertedTriangle .",
    "The function printRow is the same as the one we used in the previous section.",
    "Download printInvertedTriangle.c if you want to run the program yourself.",
    "In the above code, notice that we switched the order of printRow(n) call and printInvertedTriangle(n - 1); call.",
    "This is because we want to print a smaller triangle first, then a row of stars.",
    "The following figure shows the order of execution of printInvertedTriangle(4) .",
    "Remember that printInvertedTriangle(0) will not execute anything, since n is 0 .",
    "Also, recall that calls to printRow function will recursively call printRow until n == 1 , then print * and return as we discussed in Section 11.2.1 .",
    "Fig. 11.11  Tracing  printInvertedTriangle  function with  n   =   4 :  printInvertedTriangle(4) . #",
    "11.2.4.  Print a pattern recursively #",
    "One final advanced step in this section is to print the pattern of stars in the following figure recursively, given the maximum number of stars in a row n .",
    "For example, the following pattern has n = 5 .",
    "Since the function only prints, it does not return any values to the calling function.",
    "The function prototype is as follows:",
    "Think recursively! We need to “think recursively” to develop a recursive function.",
    "This means to print a pattern, we need to think of doing a small task/s in addition to printing a smaller sized pattern.",
    "The following figure illustrates the recursive thought process.",
    "As shown, we can print a row of stars then, call printPattern(n - 1); , then print a row of stars again.",
    "However, we need to remember this is only the recursive call part of the function.",
    "The terminating case could be the smallest possible pattern, for example, a pattern with two rows of 1 star each enclosing no special pattern.",
    "Given that, the base case is when n <= 0 .",
    "In this case, we print nothing.",
    "Fig. 11.12  Thinking recursively to print a pattern of stars. #",
    "The following code is one way to implement the recursive function printPattern .",
    "The function printRow is the same as the one we used in the previous sections.",
    "Download printPattern.c",
    "Notice that lines \\(16\\) – \\(18\\) is the same order of statements illustrated in Fig.",
    "11.12 .",
    "The following figure shows the order of execution of printPattern(4) .",
    "Remember that printPattern(0) will not execute anything, since n is 0 .",
    "Also, recall that calls to printRow function will recursively call printRow until n == 1 , then print * and return as we discussed in Section 11.2.1 .",
    "Fig. 11.13  Tracing  printPattern  function with n = 4:  printPattern(4) . #",
    "Quiz",
    "0 Questions",
    "11.4.  Exercises #",
    "Many of these exercises are taken from past exams of APS105 Computer Fundamentals courses at University of Toronto.",
    "The solutions are provided in the answer boxes.",
    "Headings in this page classify the exercises into different categories: [Easy] , [Intermediate] , and [Challenging] .",
    "I suggest you start by easy exercises and work your way up to the challenging ones.",
    "Question 5 in Fall 2013 Final Exam [Easy]",
    "Consider the recursive C function factorial below.",
    "Give the printed output of the function that is produced if the function is called with an argument of 4.",
    "Question 10 in Fall 2013 Final Exam [Intermediate]",
    "Write a function called revStr that makes use of recursion to reverse the characters of a string.",
    "The reversal should happen two elements at a time, from the ends to the centre of the string.",
    "The function prototype is given below.",
    "Parameter str is the string to be reversed and parameter len is the length of the string.",
    "For example, if the function is called with the string \"Hello\" , it must reverse the characters so that the string contains \"olleH\" .",
    "Question 14 in Winter 2018 Final Exam [Easy]",
    "Consider the following function that returns the index of a char c in a string string ( i.e., the position of the first c in the string), or returns \\(-1\\) if c does not occur in string .",
    "Write a C function recursiveFindIndex(chatr *string, char c) that does not use any loops, yet behaves like the findIndex function above.",
    "Your function may have additional parameters, but at the minimum must include the parameters string and c .",
    "Question 11 in Winter 2022 Final Exam [Challenging]",
    "Write a recursive function called compareLines that compares two strings, lineOne and lineTwo and returns true if the strings are the same and false otherwise.",
    "When comparing the two strings, space characters ( ' ' ) and period characters ( '.' ) are not considered as valid characters and should be ignored.",
    "If the strings do not have the same number of valid characters, the function should return false .",
    "Example 1:",
    "If lineOne = \"Hello.everyone.\" and lineTwo = \"Hello ..every.one.\" , compareLines will return true as the valid characters are the same and existing in both lineOne and lineTwo .",
    "Example 2:",
    "If lineOne = \"Hello everyone\" and lineTwo = \"Hello! everyone\" , compareLines will return false as the valid characters are not the same.",
    "lineOne does not have a ! and lineTwo has a ! .",
    "Note: Solutions that do not use recursion will receive 0 marks.",
    "11.  Recursion #",
    "Engineer is problem solving at heart.",
    "When we discussed functions, we were approaching problem-solving by breaking a problem into smaller pieces, each problem was solved in a function.",
    "Each function solved a different problem, and eventually integrating the functions together lead to a solution to the bigger problem.",
    "In recursion, we break a problem into a smaller version of the same problem repeatedly till the problem is small enough to be solved easily.",
    "Solutions to smaller problems can be combined easily to form the solution of the bigger problem.",
    "For this to happen, we will observe a function calling itself but on a smaller problem/input.",
    "We discuss in this chapter what is recursion, why we need recursive functions, and how to write a recursive function.",
    "11.3.  Recursion in arrays #",
    "In this chapter, we will learn how to use recursion to solve problems involving arrays, including strings.",
    "11.3.1.  Recursion on strings #",
    "A string is an array of characters.",
    "To think of a string recursively, think of a string as",
    "a character followed by a smaller string.",
    "For example, the string \"hello\" can be thought of as 'h' followed by \"ello\" .",
    "a character followed by a smaller string.",
    "For example, the string \"hello\" can be thought of as 'h' followed by \"ello\" .",
    "a character preceded by a smaller string.",
    "For example, the string \"hello\" can be thought of as \"hell\" followed by 'o' .",
    "a character preceded by a smaller string.",
    "For example, the string \"hello\" can be thought of as \"hell\" followed by 'o' .",
    "two characters enclosing a string.",
    "For example, the string \"hello\" can be thought of as 'h' followed by \"ell\" followed by 'o' .",
    "two characters enclosing a string.",
    "For example, the string \"hello\" can be thought of as 'h' followed by \"ell\" followed by 'o' .",
    "The recursive call would be the same function called on the smaller problem/string, and the base case is when you have the smallest possible string, which is a string of length 1, or when you observe the '\\0' at the end of the string.",
    "11.3.2.  Exercise: Is a String a Palindrome? #",
    "Let’s write a recursive function to determine if a string is a palindrome, which is a string that reads the same forwards as backwards.",
    "For example, \"radar\" is a palindrome, but \"hello\" is not since \"hello\" is not the same as \"olleh\" .",
    "Think recursively! We need to compare the first and last characters of the string, and then compare the second and second-to-last characters of the string, and so on.",
    "With every iteration, the remaining characters in the string are two less than the previous iteration.",
    "Hence, in a recursive function, we need to compare the first and last characters of the string, and then call the function on the remaining characters in the string till there are not more characters to compare, which is the base case or terminating condition.",
    "We show in the following figure that we start by comparing the character at index low with the character at index high .",
    "If they are not the same, we return false .",
    "If they are the same, we call the function on the remaining characters in the string, which is the string from index low + 1 to index high - 1 .",
    "We should stop doing that when low >= high , which is the base case.",
    "Fig. 11.14  Steps to determine if a string is a palindrome. #",
    "We can translate these steps to write the function as follows:",
    "Note that the function prototypes takes in the values of low and high to communicate the latest indices of the string that we are comparing.",
    "This function now has three parameters to pass, which is not ideal.",
    "We can have a function with only one parameter that takes the string, and this function calls the function with three parameters.",
    "This function with three parameters is the recursive function that does the actual work.",
    "The following code shows how the recursive function can be called from a function with only one parameter using a \"helper\" that takes in three parameters.",
    "Download isPalindrome.c if you want to run the program yourself.",
    "More worked examples in-progress!",
    "Quiz",
    "0 Questions",
    "11.1.  Recursive functions by definition #",
    "Recursion is a method of solving a problem that requires first solving smaller instances of the same problem.",
    "In programming, recursion is when a function calls itself but on a smaller problem/input.",
    "The function calls itself repeatedly until a solution is found on the smallest problem, which is when the function returns a solution and stops calling itself.",
    "11.1.1.  Euclidean Algorithm for Fining Greatest Common Divisor #",
    "There are problems that have a solution defined recursively.",
    "For example, the Euclidean algorithm for finding the greatest common divisor (GCD) of two numbers is defined recursively.",
    "The Euclidean algorithm is a method for finding the greatest common divisor of two numbers.",
    "The algorithm is based on the following observation: if a and b are two positive integers, then the greatest common divisor of a and b is the same as the greatest common divisor of a and a - b , if a > b .",
    "Hence, the algorithm is as follows:",
    "If a > b , then the greatest common divisor (GCD) of a and b is the GCD of a - b and a .",
    "If a and b are equal, then the greatest common divisor of a and b is a (or b ).",
    "Mathematically, the Euclidean algorithm is defined as follows:",
    "Fig. 11.1  GCD of two numbers is defined recursively. #",
    "For example, the greatest common divisor of 20 and 8 is 4.",
    "To find the GCD using the formula above, \\(GCD(20, 8)\\) \\(\\rightarrow\\) \\(GCD(8, 20 - 8 = 12)\\) \\(\\rightarrow\\) \\(GCD(12, 8)\\) \\(\\rightarrow\\) \\(GCD(8, 12 - 8 = 4)\\) \\(\\rightarrow\\) \\(GCD(4, 8 - 4 = 4) = 4\\) .",
    "The Euclidean algorithm can be easily implemented recursively as follows.",
    "Download gcd.c if you want to run the program yourself.",
    "What really happens when we call gcd function?",
    "The following video explains what happens when we call the gcd function.",
    "As the video discusses, recursive functions use up a lot of memory.",
    "This is because the function calls itself and the function call is stored in the stack.",
    "This happens repeated till a solution is found.",
    "The space allocation also takes time to complete.",
    "The main advantage of recursive functions is that they are easy to implement in cases where the mathematical formula is given, e.g. the Euclidean algorithm.",
    "Given the disadvantages of recursive functions, it is important to know that we rarely use them in the real-world.",
    "11.1.2.  Factorial of a number #",
    "Previously, we discussed the factorial of a number in Section 5.2.1 .",
    "The factorial of a number is defined as follows:",
    "We implemented an iterative function to calculate the factorial of a number using a for loop as follows:",
    "In the same function call, we repeatedly multiply the factorial by the next number till the number reaches n , and factorial is returned.",
    "We can define the factorial of a number recursively .",
    "The factorial of a number is defined recursively as follows:",
    "Fig. 11.2  Factorial of a number can be defined recursively. #",
    "Given the mathematical definition, we can implement the factorial function recursively as follows:",
    "Code [Errorneous]",
    "The above code will not work.",
    "In Fig.",
    "11.3 , we call the factorial function with n = 4 , which calls the factorial with n = 3 , then n = 2 , then n = 1 , then n = 1 , then n = 0 , then n = -1 , and so on.",
    "The recursive call will never end.",
    "This is because the function does not have a base/terminating case.",
    "The smallest number of which the factorial is known is 0, and the factorial of 0 is 1.",
    "Hence, the function should return 1 when n = 0 .",
    "This is the base or terminating case.",
    "Fig. 11.3  A recursive factorial function without a base/terminating case can call itself infinitely, or till the space of the stack is exhausted. #",
    "A corrected factorial function looks as follows, or you can download factorial-recursive.c to play with the code yourself.",
    "Code [Correct]",
    "In Fig.",
    "11.4 , we show the order of execution of the recursive function calls of the factorial function.",
    "The function returns a value to the previous function instance when it reaches the base case of n = 0 .",
    "Fig. 11.4  A recursive factorial function with a base/terminating case will call itself until it reaches the end of the base case. This is when it will return a value to the previous function instance. #",
    "Lesson learned.",
    "All recursive functions must have a base/terminating case, along with a recursive call, as illustrated in the figure below.",
    "Base case is when the function returns a value without calling itself, and it happens only when we reached the smallest problem that we have a solution to.",
    "Recursive call is when the function calls itself on a smaller problem than the original.",
    "Recursive calls should move closer to the base case with every call.",
    "Quiz",
    "0 Questions",
    "8.2.  Exercises #",
    "Many of these exercises are taken from past exams of APS105 Computer Fundamentals courses at University of Toronto.",
    "The solutions are provided in the answer boxes.",
    "Headings in this page classify the exercises into different categories: [Easy] , [Intermediate] , and [Challenging] .",
    "I suggest you start by easy exercises and work your way up to the challenging ones.",
    "Question 4 in Winter 2018 Final Exam [Easy] Write a single C statement that declares a variable called intPtrArray , initialized to point to an array of 10 integers that is dynamically allocated.",
    "Question 2 in Fall 2015 Final Exam [Easy]",
    "Write one or more C statements that use malloc to dynamically allocate an array of \\(1000\\) elements of type double .",
    "The allocated array should be called list .",
    "8.1.  What is dynamic memory allocation? #",
    "Dynamic memory allocation is the allocation of memory space “on the fly” during runtime.",
    "The amount of memory to be allocated does not need to be known at compile-time.",
    "For example, as you write a program to get the average grades of a number of students taking a course, you decide to allocate a large-sized array, say int arr[10000]; .",
    "You thought to yourself, “the number of students will not be more than \\(10,000\\) .” Later, your program was used for APS 105, where we have 441 students, then only the first 441 elements of the \\(10,000\\) element array will be used.",
    "In this case, you allocated memory space that was wasted.",
    "The real-problem occurs if your program was used for a very large online class with \\(50,000\\) students.",
    "Your array will not be able to hold the grades of more than \\(10,000\\) .",
    "8.1.1.  Different options when array size is unknown at compile-time #",
    "If you do not know the size of the array when you write a program, you have the following options:",
    "Fixed size array.  Allocate a fixed  very large-sized array , for example,  int   array[10000000] . \n Problem.  If the size of the array is too large that there is no space in the memory for it, your program will not run, because there were not enough memory reserved for the very large array. \n To better understand the memory structure, the following figure shows the memory space for your program. It has four main segments. There is a segment that: \n \n Stores your code, \n Stores the constants and global variables of your program, \n Stores the dynamically allocated memory, and is called the  heap , \n Stores the local variables of a function, and is called the  stack . The stack is what we have observed throughout this book. It stores the local variables of a function, and if a function calls another function, this is where the local variables of that other function are stored. \n \n Creating very large arrays will take up a lot of space from the stack, and if the stack was exhausted, you may not be able to create your array or call another function. \n \n \n \n Fig. 8.1  Main memory reserved for a program is divided into four main segments. There is a place reserved for storing your code, global variables and constants, local variables within functions — called the  stack , and dynamically allocated memory — called the  heap . # \n \n \n As the above figure shows, there is no fine line between the stack and the heap. This is because the stack expands for every function call and every declaration of a local variable. Similarly, the heap expands with every dynamically allocated memory space. \n \n Fun fact about  Stack overflow ! \n Stack overflow , which is the name of the popular website for questions and answers on computer programming, was named after a common run-time error called “stack overflow”. As the name implies, the error means that the stack memory space is exhausted and there is no more space available in the stack. It usually happens when you keep calling functions within other functions without returning from those functions and exhausting the stack. We will dig deeper into this error when we discuss “recursion”.",
    "Fixed size array.",
    "Allocate a fixed very large-sized array , for example, int array[10000000] .",
    "If the size of the array is too large that there is no space in the memory for it, your program will not run, because there were not enough memory reserved for the very large array.",
    "To better understand the memory structure, the following figure shows the memory space for your program.",
    "It has four main segments.",
    "There is a segment that:",
    "Stores your code,",
    "Stores the constants and global variables of your program,",
    "Stores the dynamically allocated memory, and is called the heap ,",
    "Stores the local variables of a function, and is called the stack .",
    "The stack is what we have observed throughout this book.",
    "It stores the local variables of a function, and if a function calls another function, this is where the local variables of that other function are stored.",
    "Stores the local variables of a function, and is called the stack .",
    "The stack is what we have observed throughout this book.",
    "It stores the local variables of a function, and if a function calls another function, this is where the local variables of that other function are stored.",
    "Creating very large arrays will take up a lot of space from the stack, and if the stack was exhausted, you may not be able to create your array or call another function.",
    "Fig. 8.1  Main memory reserved for a program is divided into four main segments. There is a place reserved for storing your code, global variables and constants, local variables within functions — called the  stack , and dynamically allocated memory — called the  heap . #",
    "As the above figure shows, there is no fine line between the stack and the heap.",
    "This is because the stack expands for every function call and every declaration of a local variable.",
    "Similarly, the heap expands with every dynamically allocated memory space.",
    "Fun fact about Stack overflow !",
    "Stack overflow , which is the name of the popular website for questions and answers on computer programming, was named after a common run-time error called “stack overflow”.",
    "As the name implies, the error means that the stack memory space is exhausted and there is no more space available in the stack.",
    "It usually happens when you keep calling functions within other functions without returning from those functions and exhausting the stack.",
    "We will dig deeper into this error when we discuss “recursion”.",
    "Variable size array.",
    "Allocate the array size equal to what the user inputs, which is variable every time we run the program.",
    "We can use the user input as the size of the area.",
    "For example, #include <stdio.h> int main(void) { int size; printf(\"Enter size of array: \"); scanf(\"%d\", &size); int arr[size]; printf(\"Array allocated from %p to %p\", arr, arr+size); return 0; } Problem.",
    "However, again the array will be allocated on the stack.",
    "This means if the stack does not have enough space, the program will not run as expected.",
    "The problem is the same problem with the fixed size arrays .",
    "Note! If the fixed sized or variable sized array was created within a function, when the function reaches its end, the array will go out of scope and will no longer exist.",
    "This is because the array is a local variable that has a limited scope till the end of a function.",
    "Variable size array.",
    "Allocate the array size equal to what the user inputs, which is variable every time we run the program.",
    "We can use the user input as the size of the area.",
    "For example,",
    "However, again the array will be allocated on the stack.",
    "This means if the stack does not have enough space, the program will not run as expected.",
    "The problem is the same problem with the fixed size arrays .",
    "If the fixed sized or variable sized array was created within a function, when the function reaches its end, the array will go out of scope and will no longer exist.",
    "This is because the array is a local variable that has a limited scope till the end of a function.",
    "Dynamically allocate memory for the array.  Allocate the memory dynamically on the  heap , and check in your program if the memory was dynamically allocated or not. \n This requires using functions from the  stdlib.h :  malloc  and  free . \n \n malloc  stands for dynamic memory allocation. The prototype of  malloc  is \n void   * malloc ( size_t   size ); \n \n \n malloc takes in as input  size_t   size , which is similar to  int   size , where  size  is the number of byte  malloc  should allocate.  malloc  returns a pointer to the first byte in the array allocated in the heap. We need to  type cast  the return value of  malloc  to the type of the element that it is pointing to. For example to dynamically allocate  \\(5\\)  elements in an  int  array, do the following: \n int *   myArray   =   ( int * )   malloc   ( 5   *   sizeof ( int )); \n \n \n \n \n \n Fig. 8.2  Dynamically allocate  \\(5\\)  elements of an  int  array, and  myArray  points to the first element in the array. # \n \n \n Good news  is if the  malloc  failed to allocate memory in the heap, it returns  NULL . Hence, in your code, before using the return value of malloc, check that it did not return  NULL . \n \n Important! \n If the array was dynamically allocated within a function, when the function reaches its end, the array will remain there in the heap, but the pointer having the address of the first element in the array will go out of scope. Given that, you will need to  free  or deallocate the memory allocated when you are done — before returning from a function. \n For example, let’s write a program that takes in the size of the array from the user. In a function named  getAverage , the program dynamically allocates the array, takes in input numbers from the user, put these numbers in the array. Finally, the function will find the average of the numbers and returns this average to the  main  function. \n Code with Memory Leaks \n \n \n#include <stdio.h>\n#include <stdlib.h>\n \ndouble getAverage(int);\n \nint main(void) {\n  int size;\n  printf(\"Enter size of array:\");\n  scanf(\"%d\", &size);\n  double avg = getAverage(size);\n  printf(\"Average is %.2lf\\n\", avg);\n  return 0;\n}\n \ndouble getAverage(int size) {\n  int* myArray = (int*)malloc(size * sizeof(int));\n   \n  printf(\"Enter grades:\");\n  for (int index = 0; index < size; index++) {\n    scanf(\"%d\", &myArray[index]);\n  }\n  int sum = 0;\n  for (int index = 0; index < size; index++) {\n    sum += myArray[index];\n  }\n  return (double)sum / size;\n}\n \n \n In line  \\(2\\) , we include  stdlib.h  library to get access to  malloc  and  free . \n In line  \\(16\\) , we dynamically allocate an array of size  size , and myArray is a pointer having the address of the first element in the array in the heap. \n In line  \\(20\\)  and  \\(24\\) , please note that we deal with  myArray  just like a normal array identifier. \n In line  \\(26\\) , we finally return the average to the  main . When we return to the  main , all local variables including  myArray  will disappear from the stack.  However, the dynamically allocated memory will still exist in the heap.  We cannot access this array anymore because we lost the variable holding the address of the first element. There is truly no way we can reach this dynamically allocated space. This phenomena is referred to as  memory leak , where we lost access to a memory space that was reserved for a variable/array. \n Solution:  You need to free/deallocate the memory space before returning from the function, even if it were the  main  function. Otherwise, you will be using up the heap, and eventually exhausting it, and there will be no space left in the heap. \n \n \n free : To free dynamically allocated memory, you need to use  free  function from  stdlib.h . The prototype of free is: \n void   free ( void   * pointer ); \n \n \n free  takes in  void   *pointer  which is a pointer having the address of the first element/byte in the dynamically allocated memory that you want to deallocate. After this step, the memory allocated is freed. \n However,  pointer  will still have the address of the first element in the array. It will be incorrect to do  *(pointer)  as the address in  pointer  could now be used by another program on your computer. To avoid using  pointer  that has the old address of the freed memory space, it is good practice to set  pointer  to  NULL . \n Let’s re-write the code above with the  free . Download  dynamic-alloc-free.c  if you want to run the program yourself. \n Code with No Memory Leaks \n \n   \n  #include <stdio.h>\n  #include <stdlib.h>\n   \n  double getAverage(int);\n   \n  int main(void) {\n    int size;\n    printf(\"Enter size of array:\");\n    scanf(\"%d\", &size);\n    double avg = getAverage(size);\n    printf(\"Average is %.2lf\\n\", avg);\n    return 0;\n  }\n   \n  double getAverage(int size) {\n    int* myArray = (int*)malloc(size * sizeof(int));\n     \n    printf(\"Enter grades:\");\n    for (int index = 0; index < size; index++) {\n      scanf(\"%d\", &myArray[index]);\n    }\n    int sum = 0;\n    for (int index = 0; index < size; index++) {\n      sum += myArray[index];\n    }\n    free(myArray);\n    myArray = NULL;\n    return (double)sum / size;\n  }\n   \n   \n In line  \\(26\\) , we free the dynamically allocated memory before  myArray  goes out of scope. Now, there is no memory leak. \n In line  \\(27\\) , we set  myArray  to  NULL  as it is a good practice as mentioned before.",
    "Dynamically allocate memory for the array.",
    "Allocate the memory dynamically on the heap , and check in your program if the memory was dynamically allocated or not.",
    "This requires using functions from the stdlib.h : malloc and free .",
    "malloc  stands for dynamic memory allocation. The prototype of  malloc  is \n void   * malloc ( size_t   size ); \n \n \n malloc takes in as input  size_t   size , which is similar to  int   size , where  size  is the number of byte  malloc  should allocate.  malloc  returns a pointer to the first byte in the array allocated in the heap. We need to  type cast  the return value of  malloc  to the type of the element that it is pointing to. For example to dynamically allocate  \\(5\\)  elements in an  int  array, do the following: \n int *   myArray   =   ( int * )   malloc   ( 5   *   sizeof ( int )); \n \n \n \n \n \n Fig. 8.2  Dynamically allocate  \\(5\\)  elements of an  int  array, and  myArray  points to the first element in the array. # \n \n \n Good news  is if the  malloc  failed to allocate memory in the heap, it returns  NULL . Hence, in your code, before using the return value of malloc, check that it did not return  NULL . \n \n Important! \n If the array was dynamically allocated within a function, when the function reaches its end, the array will remain there in the heap, but the pointer having the address of the first element in the array will go out of scope. Given that, you will need to  free  or deallocate the memory allocated when you are done — before returning from a function. \n For example, let’s write a program that takes in the size of the array from the user. In a function named  getAverage , the program dynamically allocates the array, takes in input numbers from the user, put these numbers in the array. Finally, the function will find the average of the numbers and returns this average to the  main  function. \n Code with Memory Leaks \n \n \n#include <stdio.h>\n#include <stdlib.h>\n \ndouble getAverage(int);\n \nint main(void) {\n  int size;\n  printf(\"Enter size of array:\");\n  scanf(\"%d\", &size);\n  double avg = getAverage(size);\n  printf(\"Average is %.2lf\\n\", avg);\n  return 0;\n}\n \ndouble getAverage(int size) {\n  int* myArray = (int*)malloc(size * sizeof(int));\n   \n  printf(\"Enter grades:\");\n  for (int index = 0; index < size; index++) {\n    scanf(\"%d\", &myArray[index]);\n  }\n  int sum = 0;\n  for (int index = 0; index < size; index++) {\n    sum += myArray[index];\n  }\n  return (double)sum / size;\n}\n \n \n In line  \\(2\\) , we include  stdlib.h  library to get access to  malloc  and  free . \n In line  \\(16\\) , we dynamically allocate an array of size  size , and myArray is a pointer having the address of the first element in the array in the heap. \n In line  \\(20\\)  and  \\(24\\) , please note that we deal with  myArray  just like a normal array identifier. \n In line  \\(26\\) , we finally return the average to the  main . When we return to the  main , all local variables including  myArray  will disappear from the stack.  However, the dynamically allocated memory will still exist in the heap.  We cannot access this array anymore because we lost the variable holding the address of the first element. There is truly no way we can reach this dynamically allocated space. This phenomena is referred to as  memory leak , where we lost access to a memory space that was reserved for a variable/array. \n Solution:  You need to free/deallocate the memory space before returning from the function, even if it were the  main  function. Otherwise, you will be using up the heap, and eventually exhausting it, and there will be no space left in the heap.",
    "malloc stands for dynamic memory allocation.",
    "The prototype of malloc is",
    "malloc takes in as input size_t size , which is similar to int size , where size is the number of byte malloc should allocate.",
    "malloc returns a pointer to the first byte in the array allocated in the heap.",
    "We need to type cast the return value of malloc to the type of the element that it is pointing to.",
    "For example to dynamically allocate \\(5\\) elements in an int array, do the following:",
    "Fig. 8.2  Dynamically allocate  \\(5\\)  elements of an  int  array, and  myArray  points to the first element in the array. #",
    "Good news is if the malloc failed to allocate memory in the heap, it returns NULL .",
    "Hence, in your code, before using the return value of malloc, check that it did not return NULL .",
    "If the array was dynamically allocated within a function, when the function reaches its end, the array will remain there in the heap, but the pointer having the address of the first element in the array will go out of scope.",
    "Given that, you will need to free or deallocate the memory allocated when you are done — before returning from a function.",
    "For example, let’s write a program that takes in the size of the array from the user.",
    "In a function named getAverage , the program dynamically allocates the array, takes in input numbers from the user, put these numbers in the array.",
    "Finally, the function will find the average of the numbers and returns this average to the main function.",
    "Code with Memory Leaks",
    "In line \\(2\\) , we include stdlib.h library to get access to malloc and free .",
    "In line \\(16\\) , we dynamically allocate an array of size size , and myArray is a pointer having the address of the first element in the array in the heap.",
    "In line \\(20\\) and \\(24\\) , please note that we deal with myArray just like a normal array identifier.",
    "In line \\(26\\) , we finally return the average to the main .",
    "When we return to the main , all local variables including myArray will disappear from the stack.",
    "However, the dynamically allocated memory will still exist in the heap.",
    "We cannot access this array anymore because we lost the variable holding the address of the first element.",
    "There is truly no way we can reach this dynamically allocated space.",
    "This phenomena is referred to as memory leak , where we lost access to a memory space that was reserved for a variable/array.",
    "Solution: You need to free/deallocate the memory space before returning from the function, even if it were the main function.",
    "Otherwise, you will be using up the heap, and eventually exhausting it, and there will be no space left in the heap.",
    "free : To free dynamically allocated memory, you need to use free function from stdlib.h .",
    "The prototype of free is: void free ( void * pointer ); free takes in void *pointer which is a pointer having the address of the first element/byte in the dynamically allocated memory that you want to deallocate.",
    "After this step, the memory allocated is freed.",
    "However, pointer will still have the address of the first element in the array.",
    "It will be incorrect to do *(pointer) as the address in pointer could now be used by another program on your computer.",
    "To avoid using pointer that has the old address of the freed memory space, it is good practice to set pointer to NULL .",
    "Let’s re-write the code above with the free .",
    "Download dynamic-alloc-free.c if you want to run the program yourself.",
    "Code with No Memory Leaks #include <stdio.h> #include <stdlib.h> double getAverage(int); int main(void) { int size; printf(\"Enter size of array:\"); scanf(\"%d\", &size); double avg = getAverage(size); printf(\"Average is %.2lf\\n\", avg); return 0; } double getAverage(int size) { int* myArray = (int*)malloc(size * sizeof(int)); printf(\"Enter grades:\"); for (int index = 0; index < size; index++) { scanf(\"%d\", &myArray[index]); } int sum = 0; for (int index = 0; index < size; index++) { sum += myArray[index]; } free(myArray); myArray = NULL; return (double)sum / size; } In line \\(26\\) , we free the dynamically allocated memory before myArray goes out of scope.",
    "Now, there is no memory leak.",
    "In line \\(27\\) , we set myArray to NULL as it is a good practice as mentioned before.",
    "free : To free dynamically allocated memory, you need to use free function from stdlib.h .",
    "The prototype of free is:",
    "free takes in void *pointer which is a pointer having the address of the first element/byte in the dynamically allocated memory that you want to deallocate.",
    "After this step, the memory allocated is freed.",
    "However, pointer will still have the address of the first element in the array.",
    "It will be incorrect to do *(pointer) as the address in pointer could now be used by another program on your computer.",
    "To avoid using pointer that has the old address of the freed memory space, it is good practice to set pointer to NULL .",
    "Let’s re-write the code above with the free .",
    "Download dynamic-alloc-free.c if you want to run the program yourself.",
    "Code with No Memory Leaks",
    "In line \\(26\\) , we free the dynamically allocated memory before myArray goes out of scope.",
    "Now, there is no memory leak.",
    "In line \\(27\\) , we set myArray to NULL as it is a good practice as mentioned before.",
    "8.1.2.  Practice Problem #",
    "We receive two arrays from the user that are already sorted in ascending order.",
    "Our task is to merge these two arrays.",
    "At compile-time the size of the arrays is unknown.",
    "Therefore, you should dynamically allocate the size of the two arrays entered by the user, and dynamically allocate the array that will merge these two arrays.",
    "For example, the user enters two arrays \\(a\\) and \\(b\\) , where",
    "\\(a = {1, 7, 9, 15, 16}\\) and \\(b = {5, 10, 11, 12, 20, 22}\\) .",
    "We now define the merged array as:",
    "\\(m = {1, 5 , 7, 9, 10, 11, 12, 15, 16, 20, 22}\\)",
    "You are asked to write a function int *merge(int *size) , which receives two sorted arrays from the user input, and returns a pointer to the single-dimensional array that merged the two array.",
    "The merge() function has one parameter size, which is used to return the size of the merged array to the calling function.",
    "Your merge function is responsible for getting the array information from the user in the manner shown below.",
    "Note: Your implementation should have no memory leaks .",
    "In other words, any dynamically allocated memory that you use inside the function should be freed.",
    "The returned array from the merge() function will be freed by the calling function.",
    "Here is an example main() function that can be used to test your work:",
    "Starter Code",
    "Expected Output[^1]",
    "Step 1: Toy example.",
    "A toy example is shown in the expected output.",
    "The first array has {1, 4, 7} and the second array has {2, 3, 5, 10} , and the merged array should be {1, 2, 3, 4, 5, 7, 10}",
    "Step 2: Think of a solution! We will dynamically allocate memory for both arrays, and fill them using a loop.",
    "Then we will allocate a new empty array for the merged elements that has a size equal to the sum of the sizes of the two arrays.",
    "The main challenge is to merge the arrays.",
    "The following figure details the steps you may think of to merge two arrays.",
    "We have two int variables storing the indices of elements to be merged next: indexA for array a and indexB for array b .",
    "We compare element at indexA in a with the element at indexB at b : a[indexA] < b[indexB] .",
    "We copy a[indexA] to the merged array if a[indexA] is less than b[indexB] , else we copy b[indexB] .",
    "Fig. 8.3  These are steps to merge two ascending ordered arrays. #",
    "Please note that towards the end, when array a was all copied to the merged array, it was time to copy all remaining elements of array b .",
    "Step 3: Decompose into steps.",
    "There are several steps:",
    "Take input of the size of the first array a",
    "Dynamically allocate the first array",
    "Take in elements of the array from the user",
    "Repeat \\(1\\) – \\(3\\) for the second array b",
    "Dynamically allocate an array of size equal to the sum of the sizes of the two arrays to be merged",
    "Set indexA , indexB , index to \\(0\\)",
    "Copy a[indexA] to merge[index] , if a[indexA] < b[indexB] , else copy b[indexB]",
    "If indexA >= size of array a, copy b[indexB]",
    "If indexB >= size of array b, copy a[indexA]",
    "Increment indexA if a[indexA] was copied, or indexB if b[indexB] was copied",
    "Increment index any ways to copy to the next index",
    "Repeat \\(7\\) – \\(11\\) as long as the index of the merged array is lower than the size of the merged array, i.e. there are more elements to copy",
    "Step 4: Write code.",
    "Download merge.c if you want to run the program yourself.",
    "Note: In lines \\(73\\) – \\(76\\) , we free any memory space that we will not have access to in the main function.",
    "We do not free merge array, because we are returning a pointer to the first element of merge .",
    "Hence, it is not a memory leak since we will still have access to it in the main function.",
    "Step 5: Test your code.",
    "Test this code with one sized arrays, zero sized arrays, positive and negative integers in the array to make sure it works.",
    "Quiz",
    "0 Questions",
    "8.  Dynamic Memory Allocation #",
    "In the previous chapter, we discuss how the memory space of arrays were fixed, known at compile-time and does not change throughout the program, i.e. the array cannot be extended or shrunk.",
    "In this chapter, we will dynamically allocate (and deallocate/free) memory for arrays.",
    "This can be helpful when we do not know the size of the array at the time of compilation, or when we want the size of the array to change midway as the program runs.",
    "For example, a user may require an array of size \\(10\\) at some point, then later as the program runs, the user may request extra \\(5\\) elements.",
    "Dynamic memory allocation helps in dynamically changing the size of the array we are using.",
    "9.3.  Dynamic Memory Allocation of 2D Arrays #",
    "We discussed in Chapter 8 the dynamic memory allocation of 1D arrays.",
    "We said it is necessary to use when:",
    "We do not know the number of elements in an array before run-time , for example, the array size is taken as user input, or based on a calculation happening at run-time.",
    "It is better to allocate the array dynamically as this will allow us to check if the array was allocated or not on the heap.",
    "If heap does not have enough space, malloc returns NULL .",
    "We do not know the number of elements in an array before run-time , for example, the array size is taken as user input, or based on a calculation happening at run-time.",
    "It is better to allocate the array dynamically as this will allow us to check if the array was allocated or not on the heap.",
    "If heap does not have enough space, malloc returns NULL .",
    "We want the life-time of the array to be flexible and not dependent on the scope of the array.",
    "For example, if you declare an array in a function using int arr[10]; , the memory space for it will be destroyed when we return from the function.",
    "This is because arr variable was created on the stack.",
    "However, if you need the space of the array elsewhere in another function, you can always pass a pointer to the dynamically allocated space.",
    "The space of the array will only be destroyed by free function.",
    "We want the life-time of the array to be flexible and not dependent on the scope of the array.",
    "For example, if you declare an array in a function using int arr[10]; , the memory space for it will be destroyed when we return from the function.",
    "This is because arr variable was created on the stack.",
    "However, if you need the space of the array elsewhere in another function, you can always pass a pointer to the dynamically allocated space.",
    "The space of the array will only be destroyed by free function.",
    "To review dynamic memory allocation for 1D array, please see Chapter 8.1 .",
    "The question that we tackle in this section is how can we dynamically allocate a 2D array.",
    "There are three ways to do so.",
    "We will discuss one method in detail, and the other two are quite intuitive.",
    "For example, let’s dynamically allocate a 2D array of integers with 3 rows and 4 columns that looks like Fig.",
    "9.6 .",
    "Fig. 9.6  2D array example we want to allocate dynamically. #",
    "9.3.1.  Method 1: Dynamic Allocation of an array of pointers #",
    "The first method to dynamically allocate a 2D array is to allocate an array of pointers, and then have each of these pointers point to a dynamically allocated 1D array corresponding to a row in the 2D array.",
    "Step 1: Dynamically Allocate an Array of Rows Pointers.",
    "First, we dynamically allocate an array of pointers, where each of these pointers will later point to a row in the 2D array.",
    "Hence, the number of pointers we need is equal to the number of rows, which is \\(3\\) in this example.",
    "9.7 shows what we need to allocate and the pointer to the first element in the array will be arr .",
    "Fig. 9.7  Dynamically allocating a 1D array of pointers pointed to by  arr . #",
    "To do what Fig.",
    "9.7 requires, we need the following statement:",
    "Fig. 9.8  The statement to dynamically allocate a 1D array of pointers pointed to by  arr . #",
    "Step 2: Dynamically Allocate Each Row.",
    "Second, we dynamically allocate 1D arrays each corresponding to a row.",
    "We need to have each element in Fig.",
    "9.7 to point to each row as shown in Fig.",
    "9.9 .",
    "Fig. 9.9  Each  int*  in the array should point to a 1D array having elements of a row. #",
    "We can do so using the following for-loop in Fig.",
    "9.10 .",
    "Fig. 9.10  For each row, dynamically allocate 1D array having number of columns elements. #",
    "Note: It may be obvious to you that instead of *(arr + row) , you can also write it as arr[row] .",
    "Step 3: Assign a Value to Each Element.",
    "Fig. 9.11  To access the element at row index  \\(0\\)  and column index  \\(1\\) , you can either access it using  *(*(arr   +   0)   +   1)  or  arr[0][1] . #",
    "We can access each element in a nested for loop as shown in Fig.",
    "9.12 .",
    "Fig. 9.12  To access each element in the 2D array, you can either access it using  *(*(arr   +   row)   +   col)  or  arr[row][col] . #",
    "Step 4: Free Dynamically Allocated Space.",
    "To deallocate or free the dynamically allocated space, we need to free the space.",
    "We need to take care of the order of deallocation and number of deallocations.",
    "If we were to only do free(arr) only, we will still have the dynamically allocated three 1D arrays.",
    "Another incorrect way is to free(arr) first, then free(*(arr + 0)) , free(*(arr + 1)) and free(*(arr + 2)) .",
    "It is incorrect because we cannot access *(arr + 1) after free(arr) , since arr is freed.",
    "The correct way is to free the three 1D arrays using free(*(arr + 0)) , free(*(arr + 1)) and free(*(arr + 2)) , then free(arr) as shown in the following figure.",
    "Fig. 9.13  The correct way is to free the  three  1D arrays then the array of pointers. #",
    "Code Snippet",
    "Download 2D-dyn-mem-alloc.c if you want to run the following program yourself.",
    "9.3.2.  Method 2: Static Allocation of an array of pointers #",
    "First, statically allocate an array of pointers int* arr[3]; .",
    "The problem is this array will be on the stack, hence number of rows has to be known at compile-time.",
    "While in method 1, all the elements were on the heap except for arr pointer.",
    "Second, make each of these pointers in the array point to dynamically allocated 1D array corresponding to the row.",
    "Third, we can access the elements as any 2D array.",
    "Forth, we free only the dynamically allocated three 1D arrays.",
    "9.3.3.  Method 3: Dynamic Allocation of a 1D array #",
    "The last method is easy if you understand from Chapter 9: Section 9.1.2 how does a static 2D array looks like in the memory.",
    "We can dynamically allocate 1D array having rows \\(\\times\\) columns integer elements = \\(12\\) .",
    "To access elements, you cannot use arr[row][col] , because the number of the columns is unknown.",
    "Instead, you need to do *(arr + row * cols + col) to access the element at index row and column index col when the number of columns is cols .",
    "Finally, to free the dynamically allocated space, you only need to free(arr); which is a 1D array of int .",
    "Quiz",
    "0 Questions",
    "9.4.  Exercises #",
    "Many of these exercises are taken from past exams of APS105 Computer Fundamentals courses at University of Toronto.",
    "The solutions are provided in the answer boxes.",
    "Headings in this page classify the exercises into different categories: [Easy] , [Intermediate] , and [Challenging] .",
    "I suggest you start by easy exercises and work your way up to the challenging ones.",
    "Question 10 in Winter 2017 Final Exam [Intermediate]",
    "You are to write a function that sets a rectangular portion of a 2-dimensional array to a specific value.",
    "The function takes the following as input parameters: an integer 1000 \\(\\times\\) 1000 2-dimensional array called A , four integer parameters named rowStart , rowEnd , colStart , and colEnd and an integer parameter value .",
    "The purpose of the function is to set the value of the array elements in A beginning with A[rowStart][colStart] and ending with A[rowEnd][colEnd] to be the value value .",
    "The picture below illustrates that the shaded portion of the array should have its elements changed to value, for the specific example given:",
    "However, this function is to he used by students in a first year C programming course, and those students are well-known for writing code that has errors.",
    "For example, they often attempt to access elements of an array outside of its defined bounds, among other problems.",
    "Therefore, your function should check that the inputs to the function are correct before performing the above operation.",
    "You must determine, through the reading of this question, what would make the inputs rowStart , rowEnd , colStart , colEnd and value correct.",
    "(You can assume that the array A is passed in correctly.)",
    "The function should return a boolean result that is set to true if the inputs are valid, and false if they are not.",
    "In the case that the inputs are not valid, the setting of the values of the array should not be attempted.",
    "IMPORTANT: Your solution, in addition to the code for the function described above, should also show how you would call this function from the main function, and make use of its return value .",
    "That is, you should show the call to the function (with appropriately declared variables, and gathering input from the user for rowStart , rowEnd , colStart , colEnd and value ) and make appropriate use of the returned boolean value.",
    "Question 9 in Winter 2022 Final Exam [Intermediate]",
    "Write a C function called borderSum that adds all the border elements of the top-left 2D \\(n \\times n\\) square matrix inside a 2D square array.",
    "For example, for the array below, if n is 3 , we should add {1, 2, 3, 7, 11, 10, 9, 5} and return 48 .",
    "If n is 0 , the function should return 0 .",
    "If n is 1 , the function should return the top-left element, which is 1 for the array below.",
    "The header of the borderSum function is provided below, where 26 is the number of rows and columns in the 2D array mat , and n is the size of the square matrix to which we need to get the sum of its border.",
    "You can safely assume n \\(\\leq\\) 26 .",
    "Solution 1.",
    "Solution 2.",
    "Question 4 in Winter 2020 Final Exam [Intermediate]",
    "For artificial intelligence (AI) that uses recently developed “neural network” techniques, layers of “neurons” pass their values, weighted by multipliers, into the next layers.",
    "Finding those weights is, of course, the more difficult and computationally intensive part, but once you have them, the use is relatively simple array multiplication.",
    "Here we will work with two layers to do the last stages and to compute values for the output.",
    "For example, the output could be the likelihood that the inputs are from the picture of one of four animals: dog, cat, pig, beaver.",
    "This net will “recognize” which of these it is by choosing the output of highest value.",
    "Here is a diagram that represents what we are doing:",
    "You will generate the function to perform the operation shown starting with the code below that includes the w1 and w2 weight arrays and that takes an input array.",
    "The input is one-dimensional, size 6.",
    "w1 and w2 are two-dimensional: w1 is \\(6\\) by \\(7\\) .",
    "w2 is \\(7\\) by \\(4\\) .",
    "The output is one-dimensional and of size \\(4\\) .",
    "Note: To multiply a N \\(\\times\\) 1 array A , by an M \\(\\times\\) N array B , to get an M \\(\\times\\) 1 array C :",
    "Here is the function to finish:",
    "Here is an example use of the function.",
    "Question 11 in Fall 2015 Final Exam [Challenging]",
    "Pictures that come from a smartphone camera can be represented as a two-dimensional array of numbers, where each number corresponds to the colour of each pixel in the picture.",
    "These cameras suffer from various effects that cause errors in the colour they measure (this variation is often called ‘noise’) which makes the picture have poor quality.",
    "One way to reduce that noise is to average each pixel with the eight pixels that surround it.",
    "In this question, you will write a C-language function that takes in such an image as an array, A , of 100 by 100 of double-type numbers.",
    "It computes the ‘averaged’ array, B , which is a slightly smaller 98 by 98 array in which each element is the computed average of 9 pixels in the input array.",
    "The figure below illustrates the computation for a smaller example version of A (a 6 \\(\\times\\) 6 array) that would produce a 4 \\(\\times\\) 4 array B .",
    "(The reason that B is smaller than A by 2 is that, at the edges of A , there are not enough “surrounding” pixels to produce a full result for B ).",
    "The computation can also be described by these examples: the element B00 of the output array B is computed as the arithmetic average of the 9 elements of A that are shaded in the upper left corner of array A in the above figure.",
    "That is, B00 is the average the nine elements surrounding and including element A11 (i.e. A00 , A01 , A02 , A10 , A11 , A12 , A20 , A21 , A22 ).",
    "Similarly, B01 is the average of the 9 elements surrounding and including A12 .",
    "B02 is the average of the 9 surrounding/including to A13 .",
    "B10 is the average of the 9 surrounding/including A21 .",
    "As a final example, B33 is the average of the 9 surrounding/including A44 , the set of which is illustrated as the shaded section of the lower right hand set of values in the array A above.",
    "You are to write a C function with a prototype as follows:",
    "Where A is the input array, and B is the array that the function computes.",
    "A specific requirement is that you must use one or more loops to compute the average of the 9 elements of A.",
    "That is, you must not explicitly write out the sum of nine separate elements of A to compute each element of B .",
    "Question 15 in Fall 2014 Final Exam [Challenging]",
    "Consider the C program given, in part, below.",
    "It declares an integer array of dimensions SIZE \\(\\times\\) SIZE , where SIZE is a defined constant as shown.",
    "The first part of the main program calls the fillArray function which sets each element of the array to the value \\(0\\) , \\(1\\) , or \\(2\\) .",
    "The program then asks the user to provide a value, \\(n\\) , which must be an odd integer.",
    "(You can assume that the user does enter an odd number, and that n >= 1 and n <= SIZE .) The goal of the program is to find all patterns of crosses of size n in the array of all 1 or 2 .",
    "For example, in the array shown below the code, there is a cross of size n = 3 of 1 centered at indices row = 2 , column = 4 , a cross of size n = 3 of 2 centered at indices row = 5 , column = 8 , and another one centered at indices row = 6 , column = 2 .",
    "Example array:",
    "The output of program is as follows, if the array above was the input, and n = 3 :",
    "Your answer should consist of the code that goes inside the main program above, and additional functions.",
    "Your answer must make use of at least one function.",
    "You do not need to rewrite the C code provided to you in the space below.",
    "9.  Multi-dimensional Arrays #",
    "In the previous two chapters, we discuss one-dimensional arrays.",
    "One-dimensional arrays help in writing down a list of items that relate to one thing, for example, the grades of one student, or the grades of a class in one assignment.",
    "It is more powerful if we can write down the grades of all students in all course assessments.",
    "This would look like a multi-column table like this:",
    "Student Name 1 Lab 1 Lab 2 Lab 3 Lab 4 Lab 5",
    "Muhammad Ali 10 9 10 10 9",
    "Whitney Houston 7 10 1 9.5 8",
    "Elon Musk 4 8 7 3 6",
    "Melba Mouton 10 10 7 10 11",
    "Malala Yousafzai 9.5 9 9.5 8 7",
    "Steve Jobs 9.5 8 9 10 9",
    "Lionel Messi 10 10 10 10 10",
    "Mohamed Salah 11 11 11 11 11",
    "All names referred here are fictional character names, and any similarities between these names and reality is probably by coincidence.",
    "9.1.  Why and how to use 2D arrays? #",
    "Two-dimensional arrays are useful when information is better represented in form of rows and columns like a board in board games, pixel colors on a computer screen, database of course grades of all students, items on a shelf in the grocery store etc.",
    "Similar to 1D arrays, it is powerful to represent all the rows and columns using a single variable/identifier.",
    "9.1.1.  How to create a 2D array? #",
    "9.1.1.1.  Declaration Only #",
    "To only declare a 1D array, we define the number of elements it will hold, e.g. , int myArray[6]; .",
    "Similarly, to declare a 2D array , we need to define the number of rows and columns in the 2D array.",
    "Fig. 9.1  Declaring a 2D array with elements of  int  type, identifier/variable name is  myArray , number of rows is  \\(2\\)  and number of columns is  \\(3\\) . #",
    "To access and initialize elements in the 2D array, we can do:",
    "This would initialize a 2D array that looks like the following:",
    "Fig. 9.2  The indexing of the rows and columns in a 2D array. Accessing  myArray[1][0]   =   4;  will access the  second  row, and  first  column and assign 4 to it. #",
    "You can initialize a 2D array using a nested for loop.",
    "The outer loop will be responsible for looping over the row index and the inner loop can loop over the column indices for each row.",
    "For example, in the following code we initialize a 2D array using a nested for loop.",
    "Download initialize-2d.c if you want to run the program yourself.",
    "9.1.1.2.  Declaration and Initialization #",
    "1D arrays can be declared and initialized in the same statement by either defining or not defining the size of the array as follows.",
    "int myArray[6] = {1, 2, 3, 4, 5, 6};",
    "int myArray[] = {1, 2, 3, 4, 5, 6};",
    "On the other hand, we can declare and initialize the 2D array by defining the number of rows and columns , and enclosing each row and the entire array between curly brackets {} as follows:",
    "or without the {} that encloses each row,",
    "or without defining the number of rows.",
    "The number of rows is not required as the compiler will fill the array row by row , i.e. in “row major” order.",
    "For example, if the number of rows is unknown, the number of columns is \\(3\\) , and the array is initialized with \\(9\\) elements, the first row will have 3 elements, the second row will have 3 elements and so on.",
    "Hence, the number of rows can be easily deduced if the number of columns and the elements are defined.",
    "To better understand “row major” order, let’s dive deeper into how a 2D array is stored in the main memory.",
    "9.1.2.  What does a 2D array look like in memory? #",
    "The main memory is divided into cells.",
    "Each cell has an address, and it can store a byte.",
    "How is a 2D array stored in the 1D memory?",
    "Arrays are stored in “row major” order in the main memory.",
    "This means that the elements are stored row by row.",
    "For example, for",
    "the elements in the memory are stored as shown in Fig.",
    "9.3 , where all elements in the first row appears first, then all elements in the next row and so on.",
    "Fig. 9.3  Elements of a 2D array are stored in the memory sequentially row by row. This way of representing the elements of a multi-dimensional array is called  row major order . #",
    "&myArray[0][0] is the address of the first element of the array.",
    "The address of myArray[1][2] requires that we add to &myArray[0][0] \\(((1 \\times 3) + 2) \\times\\) sizeof(int) , where \\((1 \\times 3)\\) is to get to the second row, adding \\(2\\) is to get to the third column in the second row, and sizeof(int) is to multiply each step by the size of each int element.",
    "Generally, &myArray[i][j] is also &myArray[0][0] + (i * number of columns + j) * sizeof(int) .",
    "The remaining addresses of the remaining elements are shown in Fig.",
    "9.4 .",
    "Fig. 9.4  Addresses of the elements in a 2D array. #",
    "Array identifier in 2D array",
    "The array identifier of a 2D array is an alias for the address of the first element in the array, which is myArray[0][0] , like 1D arrays.",
    "We also discuss this in the next section, when we pass a 2D array to a function.",
    "Different from 1D arrays, the array identifier is also a pointer to the first row of the array.",
    "This can be confusing when you dereference a pointer to a 2D array (or array identifier), since it gives you a pointer to the first element of the first row of the array.",
    "For example, myArray holds the same value as *myArray , which is the address of myArray[0][0] , i.e. myArray \\(\\Longleftrightarrow\\) *myArray \\(\\Longleftrightarrow\\) &myArray[0][0] .",
    "If you would add 1 to the 2D array identifier, this gives a pointer to the first element of the second row, for example, *(myArray + 1) is same as myArray[row] .",
    "Then, to get to a particular column, you need to add the index of the column.",
    "For example, *(*(myArray + 1) + 2) is same as myArray[1][2] .",
    "The following figure illustrates how can you use the array identifier to access elements.",
    "9.1.3.  Exercise #",
    "Write a program that finds three horizontal consecutive \\(1\\) s in a \\(6\\) by \\(6\\) array.",
    "Step 1: Toy example.",
    "In Fig.",
    "9.5 , we show a toy example of a \\(6 \\times 6\\) array filled with \\(0\\) s and \\(1\\) s.",
    "We are required to find out that row, col \\(= 2, 1\\) , and \\(3, 2\\) and \\(5, 0\\) have a \\(1\\) that is the beginning of \\(3\\) horizontal consecutive \\(1\\) s on the right.",
    "Fig. 9.5  \\(6 \\times 6\\)  array filled with  \\(0\\) s and  \\(1\\) s. You are required to print the starting row and column indices at which there are two other consecutive 1s on the right. #",
    "Step 2: Think of a solution! We should loop over each element row by row in the 2D array from left to right.",
    "For each element, we will count how many \\(1\\) s we find in the current and the next two elements on the right.",
    "If the count is \\(3\\) , we should print the row and column indices at which we found the consecutive horizontal line of \\(1\\) s.",
    "Step 3: Decompose into steps.",
    "Given the \\(6 \\times 6\\) array is in an array named board .",
    "Set row = 0 and col = 0",
    "Set step = 0",
    "Set count = 0",
    "If board[row][col + step] == 1 , increment count by \\(1\\)",
    "Increment step by \\(1\\) to go to the next element on the next column",
    "Repeat \\(4\\) – \\(5\\) till step is \\(3\\) or if col + step >= 6",
    "If count == 3 , print row and col",
    "Go to next element, and repeat \\(2\\) – \\(7\\) till row = 6 and col = 6",
    "Step 4: Write code.",
    "Download initialize-2d.c if you want to run the program yourself.",
    "Step 5: Test and debug your code.",
    "You can test your code with different array with different positions of the consecutive \\(1\\) s.",
    "A common mistake is to forget to check that col + step is without the bounds of the array.",
    "If you don’t, you will be accessing an element outside the bounds of the array, which might raise a “Segmentation Fault” error, because you are not permitted to access this location.",
    "Another common mistake is to forget to reset the count to \\(0\\) for each element.",
    "This will result in counting all the 1’s observed while looping over all rows and columns.",
    "Quiz",
    "0 Questions",
    "9.2.  How do we pass a 2D array to a function? #",
    "When we want to pass a 2D array to a function, we follow a similar process as with 1D arrays by passing the pointer to the first element in the array.",
    "We need to pass the size of the array too, so that the function can use this information as needed.",
    "This includes the number of rows and columns of the 2D array.",
    "For example, let’s write down a function that receives a pointer to the first element in the 2D array, the number of rows and columns and does not return any values.",
    "It only changes the element at row index 4 and column index 5 to 6 .",
    "Code with Incorrect Syntax",
    "The problem is that to access any element in the 2D array using the pointer to the first element in the array, we need the number of columns.",
    "For example, to access arr2D[4][5] we need to dereference the address arr2D \\(+\\mbox{ }4 \\times \\mbox{number of columns} + 5\\) .",
    "The correct syntax requires that you specify the number of columns in the second dimension of arr2D as follows:",
    "Code with Partially Correct Syntax",
    "The remaining problem is that cols is used in int arr2D[][cols] before it is defined in the function header.",
    "Code with Correct Syntax",
    "9.2.1.  Exercise #",
    "Let’s write a program that uses a function to sum all elements of a 2D array.",
    "In line \\(3\\) , we write the function prototype such that int arr2D[][cols] has the number of columns defined and cols is defined before used in int arr2D[][cols] .",
    "In line \\(7\\) , sum2DArr(3, 4, arr2D); \\(3\\) is passed to rows and \\(4\\) is passed to columns in sum2DArr function, and arr2D as a pointer to the first element in the 2D array is passed to arr2D pointer in sum2DArr function.",
    "In line \\(11\\) , has the function header the same as the function prototype.",
    "In line \\(15\\) , we access the elements in the 2D array as we do with any other 2D array.",
    "Quiz",
    "0 Questions",
    "10.5.  Exercises #",
    "Many of these exercises are taken from past exams of APS105 Computer Fundamentals courses at University of Toronto.",
    "The solutions are provided in the answer boxes.",
    "Headings in this page classify the exercises into different categories: [Easy] , [Intermediate] , and [Challenging] .",
    "I suggest you start by easy exercises and work your way up to the challenging ones.",
    "Question 9 in Winter 2019 Final Exam",
    "Write a function, countLetters , that counts the number occurrences of each alphabetical letter found in a string.",
    "The function has two parameters: a string (i.e. char *) and an array of integers.",
    "The string should not be modified and can be any length.",
    "You may assume that the string is null-terminated and all letters are lower case.",
    "The string may contain characters that are not part of the alphabet (e.g., '0' , '1' , '!' , '&' , etc).",
    "The integer array has a size of 26, one for each letter in the alphabet.",
    "The first index corresponds to the letter 'a' , the second index to the letter 'b' , and so on.",
    "You may assume that, initially, all 26 elements in the array have a value of zero.",
    "You must abide by the following constraints.",
    "Failure to meet a constraint will result in a grade of zero for this question.",
    "You cannot modify the characters inside the string.",
    "You cannot create any other data structures (e.g., array, linked list, etc),",
    "Your function must only access valid indices of the array.",
    "You cannot call any functions in your implementation.",
    "An example of one run of the program is below.",
    "You only need to implement the countLetters function.",
    "Assume a main function (that reads in a string, calls your function, and outputs the integer array) already exists.",
    "Question 10 in Winter 2022 Final Exam [Intermediate]",
    "Write a function called lastStringInString , the prototype of which is provided below, that returns the pointer to the last occurrence of the string s1 in the string s2 .",
    "If the string s1 cannot be found in the string s2 , the function returns NULL .",
    "For example, if we are looking for the string \"is\" as s1 in the string \"This is a sample string\" as s2 , the pointer to the second \"is\" in the string \"s2\" will be returned by the function.",
    "Another example, if we are looking for the string \"the\" as s1 in the string s2 \"The apple\" , the function should return NULL .",
    "This is because 't' is lower case in \"the\" .",
    "Note: You can use any function from the library string.h , except for strstr() — you are not allowed to use it.",
    "Solution 1",
    "Solution 2",
    "Question 11 in Winter 2018 Final Exam [Intermediate]",
    "Write a C function called preamble that takes two parameters: a string str and an int-type integer n .",
    "The function will then return a new string that is dynamically allocated, and that contains at most the first n characters in the string str .",
    "For example, if str is \"Toronto\" , and n is 3 , then the function will return \"Tor\" (the first three characters in \"Toronto\" ).",
    "If str is \"Toronto\" and n is 8 , then the function will return \"Toronto\" .",
    "If str is NULL, the function will also return NULL .",
    "Solution 1",
    "Solution 2",
    "Question 11 in Winter 2017 Final Exam [Challenging]",
    "Write a function char *deleteSubString(char *source, char *substring) that takes two strings called source and substring as its parameters.",
    "It should return a new dynamically allocated string that is constructed from the strings source and substring .",
    "The newly created and returned string should be the same as the source string, but with the first occurrence of the string substring removed.",
    "For example, if the string source has the value \"my toronto\" , and the string substring has the value \"to\" , the function will return the string \"my ronto\" .",
    "You may use any of the string-related functions in the C standard library, and may assume that string.h has been included.",
    "Question 13 in Fall 2015 Final Exam [Challenging]",
    "Two strings are said to be anagrams of each other if they are of the same length, and contain the same characters in a (possibly) different order.",
    "For example, \"elvis\" is an anagram of \"lives\" , and \"the morse code\" is an anagram of \"here come dots\" .",
    "You are to write a C function isAnagram , with the prototype given below, that returns true if the two strings s1 and s2 are anagrams of each other; otherwise, it returns false .",
    "In your code, you may modify any of the characters in s1 and s2 , and may use any function in the string.h library.",
    "You can also assume that both strings will only contain characters from the alphabet (upper case and lower case) and the space character.",
    "Also, note that the upper case 'A' is NOT considered as the same character as lower case 'a' .",
    "Question 12 in Fall 2012 Final Exam [Challenging]",
    "Write a C function called checkPlagiarism , the prototype of which is given below, that returns true if the two suspected codes code1 and code2 have high similarity.",
    "High similarity is defined as matching exactly, but ignoring any spaces or newline character \\n .",
    "For example, the function checkPlagiarism returns true when comparing the example strings c1 and c2 below.",
    "You may assume that c1 and c2 are null-terminated strings.",
    "Hint: your code should return false as soon as it finds evidence of mis-match.",
    "10.4.  Array of Strings #",
    "In previous sections of this chapter, we show strings as a special array of characters that is null-terminated.",
    "If we were to have an array of strings, it can be created in two ways: a 2D array of characters each row is terminated by a '\\0' , where each row is a string, or a 1D array of char* , where each element is pointing towards a 1D array that is a string.",
    "The first",
    "10.4.1.  2D array of characters #",
    "We can declare a 2D array, where each row has a string holding a month name.",
    "For example, in the following code, in line 4, we declare a 2D array named months , with \\(10\\) columns.",
    "Recall, we must define the column size, and the row size is not necessary to define if we are initializing, as it will be known from the number of elements.",
    "Each row stores a month name.",
    "For rows that are not completely filled if the string size is smaller than 10, similar to str in char str[10] = \"Hi\"; , the remaining elements are filled with null-characters.",
    "This \\(12\\) by \\(10\\) array is shown in Fig.",
    "10.14 .",
    "The elements of the 2D array are all stored in the",
    "In Fig.",
    "10.14 , the elements of the 2D array are all stored in the stack of the main memory.",
    "This means we can change any of the characters in the 2D array.",
    "For example, in line \\(9\\) , we can change the first character of each month to the lower case.",
    "We can do so by subtracting the ASCII code of the first upper case letter in the alphabet 'A' then adding the ASCII code of the first lower case letter in the alphabet 'a' .",
    "This shifts the ASCII to lower case letters.",
    "In line \\(10\\) , we can print each string/row using %s .",
    "Fig. 10.14  2D array of characters where each row is a string — null-terminated array of characters. #",
    "Since months is a 2D array of characters, you cannot change an entire row in one line, e.g. months[0] = \"january\"; .",
    "This is because months[0] is an array identifier, not a pointer variable.",
    "Refer to notes in Section 10.1.1.3 for an explanation of what can and cannot be done, while dealing with strings.",
    "10.4.2.  1D array of  char* #",
    "The other way to declare an array of strings, we can declare an array of char* as we do in line \\(4\\) of the following code.",
    "To initialize element to point to a string, we can do it as in lines \\(6\\) – \\(17\\) .",
    "We can declare and initialize the array of character pointers as in line \\(4\\) – \\(6\\) of the following code.",
    "Code (Declare and Initialize)",
    "Here, months is a 1D array of character pointers and each pointer is pointing to a constant string in the constants segment of the main memory.",
    "This is illustrated in the following figure.",
    "Fig. 10.15  1D array of character pointers, where each pointer is pointing to a constant string. #",
    "Since months is a 1D array of character pointers and each pointer is pointing to a constant string in the constants segment of the main memory, you cannot change an individual element of the string, e.g. months[0][0] = \"j\"; .",
    "This is because months[0][0] is constant and cannot be changed.",
    "Instead, you can change what the pointer points to, e.g. months[0] = \"january\"; .",
    "Refer to notes in Section 10.1.1.3 for an explanation of what can and cannot be done, while dealing with strings.",
    "Quiz",
    "0 Questions",
    "10.  Strings #",
    "Throughout this book, we study different data types.",
    "None of the data types discussed before stores a word or sentence, because in C programming language there is no data type that stores a word/sentence.",
    "A word or sentence is considered a string, and to store a string in C programming language, we store it in an array of null-terminated characters.",
    "In this chapter, we discuss strings in C, how can we read strings from the user and print them to the user, and finally string functions that help us do operations on strings.",
    "10.1.  What are strings? #",
    "In C programming language, there is no data type that stores a word/sentence.",
    "Instead, we use strings to store a word or sentence.",
    "We did see strings before when we used to print sentences and words using printf .",
    "For example, in the printf statement below, \"Hello world!\\n\" is a string.",
    "Notice that words/sentences are enclosed between double-quotes: \"<words/sentences>\" .",
    "10.1.1.  Store a String #",
    "To store a string in a variable, we use an array of characters that is “null-terminated” .",
    "This means that the string is stored in a special array of characters that stores the word/s, and the last character is a null character.",
    "A null character is \\0 .",
    "It has an ASCII code of \\(0\\) .",
    "This means that \\0 is encoded using ASCII code to be stored in the main memory as \\(0\\) .",
    "You may refer to Chapter 2: Section 2.2.3 to refresh your memory on ASCII code.",
    "There are three ways we can set up a string in a null-terminated array of characters.",
    "10.1.1.1.  Method 1: Declare and Initialize #",
    "To declare a 1D array of characters, and initialize its elements to 'H' , 'e' , 'l' , 'l' , 'e' and finally a '\\0' , we can do the following.",
    "The statement will make myString array have \\(6\\) elements, where the first \\(5\\) elements store the characters in \"Hello\" , and the last element stores '\\0' as shown in the figure.",
    "Fig. 10.1  Declare and initialize a null-terminated array of characters — a string. #",
    "Although it is unnecessary to define the size of the 1D array when we declare and initialize it, we can still define the size as in the following statement.",
    "Notice here that we defined a size of \\(6\\) elements although \"Hello\" has \\(5\\) characters.",
    "This is because we want to leave an extra element for the null character.",
    "We can have the size of the array to be greater than the number of characters \\(+1\\) , for example \\(8\\) in the following statement,",
    "This will set the extra two characters to null '\\0' as shown in the figure below.",
    "Fig. 10.2  Extra elements are set to  '\\0'  at the time of declaration and initialization of a null-terminated array of characters. #",
    "Like any 1D array, you can change individual elements in a null-terminated array.",
    "For example,",
    "Fig. 10.3  Change upper case  'H'  to lower case  'h' . #",
    "10.1.1.2.  Method 2: Declare now and Initialize later #",
    "You may declare a 1D array of characters, then change it to a string later in other statements.",
    "For example, we can create an array of 4 characters.",
    "Then, change this array to store the string \"The\" as shown in the following statements.",
    "10.1.1.3.  Method 3: Declare a Pointer Pointing to a Constant String #",
    "We can declare a pointer of type (char*) and initialize it to point to the first character of a “constant string” as in the following statement.",
    "This would create a variable named pStr that can hold an address to a character.",
    "This same statement creates an array of characters having “Wow” terminated by null in the constants and global variables memory segment.",
    "We are also setting the address stored in pStr to be the address of the first character of the string “Wow” as shown in the figure below.",
    "Fig. 10.4  Pointer having the address of the first character in a constant string. #",
    "Cannot Change Individual Elements",
    "You cannot change individual elements in a const string.",
    "For example, you cannot do the following:",
    "This is because \"Wow\" string is stored as a constant, and you cannot change a constant.",
    "If you try doing it, your program may fail silently, which means the statement will fail and other statements in your program may not behave as expected, or give a “segmentation fault” error message, which means you are accessing or changing a memory space you are not permitted to access or change.",
    "Can change the value of the pointer",
    "However, pStr is not a constant, and hence you can always change what pStr points to and make it point to another string, like pStr = \"Cat\"; .",
    "Fig. 10.5  Change the value of  pStr  pointer to have the address of the first character of another constant string. #",
    "Since pStr is not a constant, it can point to the first character in an array of null-terminated characters, i.e. string, on the stack.",
    "Recall that the stack is a segment of the memory used to store local variables, which are not constants.",
    "For example, the following figure shows how the three statements are executed in the memory.",
    "Fig. 10.6  Change the value of  pStr  pointer to have the address of the first character of another string that is on the  stack . #",
    "Can access/change characters on the stack",
    "If pStr is now pointing to an array on the stack, the elements of the array can be changed like any other array.",
    "For example,",
    "Fig. 10.7  You can change the characters on stack pointed to by  pStr . #",
    "Cannot change the array identifier",
    "Although you can change what a pointer points to, e.g. by assigning pStr an address of different characters in previous examples, you cannot change an array identifier.",
    "For example, str in char str[] = \"Hello\"; is an array identifier and a pointer to the first character in the \"Hello\" string, but str itself is not assignable.",
    "For example, if you try compiling the following code, you would get a compile-time error: \"array type 'char[6]' is not assignable\" .",
    "10.1.2.  What is the usage of the  '\\0'  in a string? #",
    "The null character \\0 can be used to know the end of a string, if the size is unknown.",
    "It is very handy, whenever we pass strings to functions.",
    "For example, let’s write a function to count the number of spaces ' ' in a string.",
    "To pass a string to a function, we use the same syntax as 1D arrays.",
    "A string or 1D array can be received as either as char* or char[] , for example,",
    "Inside the function, we should check the elements at each index: from 0 to the index that has the last element.",
    "The last element here is the element having '\\0' .",
    "If an element is a space, we increment a counter than counts the number of spaces.",
    "We can write the code as follows, or you can download spacesCount.c if you want to run the program yourself.",
    "Quiz",
    "0 Questions",
    "10.2.  Input/Output Strings #",
    "10.2.1.  Output strings #",
    "10.2.1.1.  Using  printf #",
    "To be able to print a string to the user, we use printf .",
    "However, there are some considerations, we have to keep in mind.",
    "For example, in the following figure, we are printing a null-terminated array of characters — a string.",
    "printf uses %s format specifier, and it requires a pointer to the first character in the array.",
    "It will print from str[0] till (and not including) the first null character '\\0' .",
    "Printing happens from the first character pointed to by the pointer.",
    "This means that if we pass a pointer to the middle of the string, it will print the rest of the string.",
    "For example, if we pass str + 2 to printf , it will print llo .",
    "If we want to print a particular number of characters, we can use the %.*s format specifier and replace * by the number of characters to print.",
    "For example, if we want to print the first two characters of the string, we can use the following code.",
    "If the number of characters set to be printed is greater than the length of the string, it will print till '\\0' .",
    "Printing a character vs.",
    "a string",
    "If we want to print a string, we should use %s format specifier.",
    "If we use %c format specifier, we need to pass the character, not a pointer to the character.",
    "This is because %c expects a character, not a string.",
    "For example, the following code prints the second character of the string.",
    "10.2.1.2.  Using  puts #",
    "Another function.",
    "There is another function named puts that prints a string to the user.",
    "It is similar to printf , but it does not take a format string.",
    "It takes a pointer to the first character in the string.",
    "It prints the string and a newline character at the end.",
    "For example, the following code prints the string Hello to the user.",
    "10.2.2.  Input strings #",
    "10.2.2.1.  Using  scanf #",
    "To take a string as input from the user using scanf , we also use %s format specifier, and pass the pointer pointing towards the beginning of the string.",
    "In the following figure, we show an example of taking a string as input from the user.",
    "For example, the following code takes a string as input from the user and prints it back to the user.",
    "How does scanf work?",
    "scanf will ignore any leading white space.",
    "scanf will then read characters till a white space or endline is encountered.",
    "Good news: scanf will terminate the string with a null character '\\0' .",
    "For example, in the following code, white spaces before ABCD are ignored, and scanf reads the string ABCD and terminates it with a null character '\\0' .",
    "The remaining ff characters will be read by the next scanf call.",
    "To illustrate what happens to the array st with every scanf , we draw the contents of st after each scanf call in the following figure.",
    "Big Problem: What if the input string is longer than the array?",
    "For example, if the user input was ABCDEFGHIJ to the following program, what would happen?",
    "Undefined Behaviour Output",
    "At line \\(6\\) , the behavior of the program is undefined.",
    "The reason is that the input string is longer than the array.",
    "The input string is ABCDEFGHIJ , and the array is st[7 + 1] .",
    "The array can only hold 7 characters and a null character, but the input string is 10 characters long.",
    "This means that the last two characters of the input string will be written to the memory locations after the array.",
    "This may result in an undefined behaviour.",
    "The program may crash, print some random characters after ABCDEFGHIJ or behave normally if the computer allows writing IJ and a null character in elements beyond the size of the array.",
    "This phenomenon is called buffer overflow , where we mistakenly write to memory locations beyond the size of the array.",
    "10.2.2.2.  Using  fgets  to avoid buffer overflow in  scanf #",
    "How to fix the buffer overflow problem?",
    "There is a safer function for taking strings from the user, it is called fgets .",
    "You can now specify the maximum number of characters to be read from the user.",
    "For example, the following code takes a string of 2 characters as input from the user and prints it back to the user.",
    "fgets takes in three input parameters.",
    "In the above example, we have used the following values for the parameters.",
    "st : The pointer to the first element of the array of characters.",
    "3 : The maximum number of characters to be read + 1.",
    "The additional character is for storing a null character after the characters read from the user.",
    "3 : The maximum number of characters to be read + 1.",
    "The additional character is for storing a null character after the characters read from the user.",
    "stdin : The input stream.",
    "In this case, we are taking input from the user, which is stored in stdin — a file defined in stdio.h library.",
    "stdin : The input stream.",
    "In this case, we are taking input from the user, which is stored in stdin — a file defined in stdio.h library.",
    "If user enters fewer characters than the maximum number of characters to be read, what happens?",
    "If user enters fewer characters than the maximum number of characters to be read, for example, in the above example, if the user only enters 1 character and pressed , what happens?",
    "In the above example, fgets will read the characters till either the number of characters read is 2 or till the user enters a new line character.",
    "In the above example, if the user enters A and presses , fgets will read the character A and a new line character.",
    "The first element of the array st will be A .",
    "The second element of the array st will be a null character '\\0' .",
    "The remaining elements of the array st will be garbage values.",
    "The following is the output if the user enters A and presses .",
    "10.2.2.3.  Implement a  getStringSafely  function #",
    "We want to write a function that takes a string as input from the user and stores it in an array.",
    "The function should take in the array as a parameter, the number of characters to read from the user + 1, and return a pointer to the first element in the array of characters.",
    "Like fgets , if the user enters fewer characters than the maximum number of characters to be read, the function should terminate the string with a null character.",
    "If the user enters more characters than the maximum number of characters to be read, the function should read the first n - 1 characters and terminate the string with a null character.",
    "Step 1: Toy example.",
    "A toy example is shown in the figure below.",
    "The user input is ABCD , the maximum number of characters to read + 1 is 3 .",
    "The function should read 'A' and 'B' into the string st then put '\\0' after 'A' and 'B' .",
    "Step 2: Think of a solution! We need to read the string character by character and store it in the array.",
    "We need to stop reading the string when we have read n - 1 characters.",
    "We need to terminate the string with a null character.",
    "If the character entered is a new line character, we need to terminate the string with a null character.",
    "getchar() function",
    "getchar() function is a very handy function that reads a character from the user and returns it.",
    "It is defined in stdio.h library.",
    "It takes in no input parameters and returns the read character.",
    "For example, in the following code, we take a string from the user one character at a time and print each character on a new line till the user enters a new line character.",
    "Step 3: Decompose into steps.",
    "The function receives string s and maximum number of characters to read + 1 n .",
    "Set a charCount to 0 .",
    "Read a character from the user.",
    "If charCount < n - 1 and the character is not a new line character, store the character in the array s and increment charCount .",
    "Else, terminate the string with a null character and return the pointer to the first element in the array s .",
    "Repeat steps 2 to 4 till the user enters a new line character or charCount is greater than or equal to n - 1 .",
    "Step 4: Write a draft code.",
    "The following is a draft of the code for the function getStringSafely .",
    "Step 5: Test and debug your code.",
    "Let’s test the function with the following main function.",
    "Test with few characters.",
    "The following is the output if the user enters AB and presses .",
    "Partially Correct Code",
    "There were garbage values in the array st .",
    "This is because we probably had our null character in the wrong place.",
    "In line \\(21\\) , we set the last element in the array s to a null character, while we only entered 2 characters.",
    "Hence, our null character should be after the two characters.",
    "Instead of s[n] = '\\0'; , it is correct to have s[charCount] = '\\0'; in line \\(21\\) .",
    "This is because charCount is the number of characters we have read from the user.",
    "Test with many characters.",
    "In lines \\(9\\) and \\(10\\) of the following code, we try to see what is left in the input buffer after we read the string from the user.",
    "Partially Correct Code",
    "In the above output, we observe 'o' character is not printed in what’s left in the input buffer.",
    "There is probably a place in our function where we read the 'o' and later find that we have already read 6 characters.",
    "In getStringSafely function, in line \\(21\\) , we read the 'o' , regardless if our character count was n - 1 or not.",
    "We need to read the character only if charCount < n - 1 .",
    "In the following code, we fixed the code in line \\(21\\) .",
    "Correct Code",
    "Step 6: Improve style.",
    "The following is the final code for the function getStringSafely .",
    "We can improve the style of the code by reducing repetition of charCount < n - 1) condition, and getchar() function call.",
    "Since all what we need is to check if the character count is less than n - 1 , and only then read the next character, we can make use of lazy evaluation in the condition of the while loop.",
    "Basically, if we have (<LHS> && <RHS>) , if LHS is false , there is no need to evaluate the RHS .",
    "You may refer to the Chapter 3: Section 3.2.1.1. Lazy Evaluation section for more details.",
    "You may download getStringSafely.c the following code and try to run it to see the output.",
    "In line \\(18\\) , if (charCount < n - 1) was false we will never evaluate the right hand size condition after && , because the entire condition will be false .",
    "However, if (charCount < n - 1) was true , the right hand side condition should be evaluated.",
    "In the right hand side condition, ((c = getchar()) != '\\n') , we get the character in c = getchar() .",
    "Recall that in C, assignment operator = returns the value assigned to the variable.",
    "Hence, c = getchar() is evaluated to the character read from the user.",
    "We then check if the character is not a new line character.",
    "If it is not a new line character, we execute the while loop body.",
    "If it is a new line character, we exit the while loop.",
    "We now do not need the getchar outside of the while loop at line \\(16\\) previously, and we can remove the if statement and the getchar call previously in line \\(21\\) .",
    "Quiz",
    "0 Questions",
    "10.3.  String Functions #",
    "As you have seen in the previous sections, there is no string data type in C.",
    "Instead, C uses an array of characters to represent a string.",
    "The good news is that there is a string library that has several functions designed specifically to work on strings.",
    "In this section, we will look at some of the most commonly used string functions.",
    "You need to include the library string.h to use these functions: #include <string.h> .",
    "10.3.1.  Length of the string #",
    "The function strlen returns the length of a string.",
    "The function prototype is as follows:",
    "size_t is an unsigned integer type.",
    "For this course, you can think of size_t as int .",
    "The function returns the length of the string str counting number of characters starting at address str to the last character before \\0 .",
    "The following program demonstrates the use of strlen :",
    "10.3.1.1.  Implementation of  strlen #",
    "Let’s implement strlen .",
    "We will name it stringLength .",
    "This function should have a loop that loops over all the contents of the string.",
    "If the element is not '\\0' , we should increment a counter.",
    "Then we should return the counter indicating the number of non-null characters.",
    "The following shows a program that implements and uses stringLength function.",
    "Guard against changes to the string.",
    "Within the stringLength function, you should not change the contents of the string, since we are only required to count the number of characters.",
    "Recall that if you mistakenly change the string, you change this contents in the original string since the string is passed as a pointer.",
    "To guard against mistakenly changing the string inside a function, we can receive it as a constant string.",
    "This requires that you use const qualifier to indicate that the string passed should not be changed.",
    "If you were to change a const string, it will result in a compile-time error.",
    "A constant string has a type of const char* .",
    "The following is the revised implementation of stringLength , you may download it from here: stringLength.c .",
    "10.3.2.  Copy a string into another string #",
    "10.3.2.1.  strcpy #",
    "The function strcpy copies the contents of one string into another string.",
    "The function prototype is as follows:",
    "The function copies characters in src till and including the null character \\0 into dest .",
    "The function returns the address of the destination string dest .",
    "The following program demonstrates the use of strcpy :",
    "Why do we need strcpy?",
    "Why do we need strcpy , when we can assign a string to another string?",
    "The following program demonstrates the problem with assigning a string to another string.",
    "Code with Compile-time Error",
    "Note that the program above will not compile.",
    "The reason is that d is an array, and arrays are not assignable.",
    "10.3.2.1.1.  Implementation of  strcpy #",
    "Let’s implement strcpy .",
    "We will name it stringCopy .",
    "This function should have a loop that loops over all the contents of the source string.",
    "We should copy the all the elements to the destination string including the '\\0' at the end of the source string.",
    "Then, we should return the address of the destination string.",
    "To guard against any changes to the source string, we will use the const qualifier.",
    "The following is the implementation of strcpy , and you can download it here: stringCopy.c .",
    "Code using [] in stringCopy",
    "Implement stringCopy using pointers only, i.e. without using [] .",
    "Code without using [] in stringCopy",
    "To help with visualization, we will use the following diagram to show the values of pdest , pdestCopy and psrc after a few iterations of the while loop in stringCopy .",
    "Fig. 10.8  Showing the values of  pdest ,  pdestCopy  and  psrc  after a few iterations of the while loop in  stringCopy . #",
    "In line \\(15\\) , we check if the element at psrc is not the end of the source string.",
    "In line \\(16\\) , we copy the element at psrc to the element at pdestCopy .",
    "In line \\(17\\) , we increment pdestCopy to point to the next element in the destination string.",
    "In line \\(18\\) , we increment psrc to point to the next element in the source string.",
    "The while loop will exit when the element at psrc is the end of the source string.",
    "This is when the element at pdestCopy is the end of the destination string.",
    "In line \\(20\\) , we then assign the null character to the element at pdestCopy to terminate the destination string.",
    "In line \\(14\\) , we copied the address of pdest to pdestCopy .",
    "This is because we want to return the address of the destination string.",
    "We cannot return the address of pdestCopy because it will point to the last element in the destination string after the while loop exits.",
    "We want to return the address of the first element in the destination string stored in pdest .",
    "10.3.2.2.  strncpy #",
    "strcpy copies the entire source string into the destination string.",
    "This can cause problems if the destination string is not large enough to hold the source string.",
    "The function strncpy copies the first n characters of the source string into the destination string, or until it observes a '\\0' character in the source string.",
    "The function prototype is as follows:",
    "The function copies n characters in src into dest .",
    "If n is larger than the size of src , the function will copy characters in src till and including the null character \\0 in the src string, then it will put '\\0' for the remaining characters that should be copied into dest .",
    "The function returns the address of the destination string dest .",
    "The following program demonstrates the use of strncpy :",
    "In the above code, the function strncpy copies 6 characters into d , which is the 5 characters in \"Hello\" and the null character \\0 .",
    "Hence, when printing d , we only see the first 5 characters in \"Hello\" till the first null character.",
    "As the figure below shows, the other characters in \"Hello world!\" are not overwritten.",
    "Fig. 10.9  Copy 6 characters including the null character. #",
    "The function strncpy does not add any null character to the end of the destination string by default.",
    "For example, in the following code, the destination string d will not be null-terminated, because we only copy 5 characters from \"Hello\" into d .",
    "The figure below shows that the null character \\0 in \"Hello\" is not copied to d , hence, when printing d , all characters before the null-character were printed.",
    "Fig. 10.10  Copy 5 characters without the null character. #",
    "If n is larger than the size of src",
    "In the above example, if we were to copy more characters than the size of src into dest , the function will copy characters in src till and including the null character \\0 in the src string, then it will put '\\0' for the remaining characters that should be copied into dest .",
    "For example, in the following code, the 7th element of d will have a null character \\0 as shown in the figure below.",
    "This would cause a problem if d did not have enough space to hold the extra null characters \\0 .",
    "Fig. 10.11  Copy 7 characters with extra padding of  \\0 . #",
    "10.3.3.  Concatenating Strings #",
    "10.3.3.1.  strcat #",
    "The function strcat concatenates the source string to the end of the destination string.",
    "The function prototype is as follows:",
    "The function concatenates the source string src to the end of the destination string dest .",
    "This means the null character of the dest string is overwritten by the first character of src .",
    "The function returns the address of the destination string dest .",
    "The function assumes that the destination string dest has enough space to hold the concatenated string.",
    "The following program demonstrates the use of strcat :",
    "Fig. 10.12  Concatenates the source string to the end of the destination string. #",
    "10.3.3.2.  strncat #",
    "The problem with strcat is that it concatenates the entire source string to the end of the destination string.",
    "This can cause problems if the destination string is not large enough to hold the concatenated string.",
    "For example, in the following figure, we concatenate an array with 3 elements \"No\" to an array with 2 elements starting from the null-character.",
    "The function strcat will concatenate the 'N' and 'o' , but there is no space for the '\\0 ’, which will cause a buffer overflow.",
    "Fig. 10.13  Error!  Concatenates the source string to the end of the destination string, while the destination string does not have enough space #",
    "A safer option for concatenation is the function strncat that concatenates the first n characters, or until a '\\0' is observed, in the source string to the end of the destination string.",
    "The function prototype is as follows:",
    "The function concatenates the first n characters of the source string src to the end of the destination string dest .",
    "The null character of the dest string is overwritten by the first character of src .",
    "The function returns the address of the destination string dest .",
    "The function assumes that the destination string dest has enough space to hold the n characters.",
    "Opposite to strncpy , the function strncat adds a null character to the end of the destination string if it was not terminated by null.",
    "The following program demonstrates the use of strncat :",
    "If n is larger than the size of src , and dest has enough space, the function will copy characters in src till and including the null character \\0 in the src string, but opposite to strncpy , it will not put '\\0' for the remaining characters that should be copied into dest .",
    "10.3.4.  Comparing Strings #",
    "10.3.4.1.  strcmp #",
    "The function strcmp compares two strings.",
    "The function prototype is as follows:",
    "The function compares the two strings s1 and s2 , looking at their lexicographic order, which is the order of their appearance in the dictionary.",
    "The function returns an integer:",
    "less than zero, if s1 is found before s2 in the dictionary,",
    "equal to, if s1 is identical to s2 ,",
    "or greater than zero if s1 is found after s2 in the dictionary.",
    "The function compares the strings character by character, and stops comparing when characters are not matching or when a null character \\0 is encountered in either string.",
    "The function assumes that the strings are null-terminated.",
    "The following program demonstrates the use of strcmp :",
    "More examples",
    "10.3.4.2.  strncmp #",
    "The function strncmp compares at most the first n characters of two strings.",
    "The function prototype is as follows:",
    "The function compares at most the first n characters of the two strings s1 and s2 , looking at their lexicographic order, which is the order of their appearance in the dictionary.",
    "The comparison stops when characters are not matching or when a null character \\0 is encountered or after comparing n characters.",
    "Similar to strcmp , the function returns an integer that is less than zero, equal to zero, or greater than zero if s1 is found before, identical to, or after s2 in the dictionary, respectively.",
    "The following program demonstrates the use of strncmp :",
    "10.3.5.  Looking for something in a string #",
    "10.3.5.1.  strchr #",
    "The function strchr searches for a character in a string.",
    "The function prototype is as follows:",
    "The function searches for the first occurrence of the character c in the string s .",
    "The function returns a pointer to the first occurrence of c in s .",
    "If c is not found in s , the function returns NULL .",
    "The function assumes that the string s is null-terminated.",
    "The following program demonstrates the use of strchr :",
    "10.3.5.2.  strstr #",
    "The function strstr searches for a substring in a string.",
    "The function prototype is as follows:",
    "The function searches for the first occurrence of the string s2 in the string s1 .",
    "The function returns a pointer to the first occurrence of s2 in s1 .",
    "If s2 is not found in s1 , the function returns NULL .",
    "The function assumes that the strings s1 and s2 are null-terminated.",
    "The following program demonstrates the use of strstr :",
    "10.3.6.  Exercise using string functions #",
    "Let’s implement strstr function using string functions we mentioned in this section.",
    "Step 1: Toy example.",
    "Say we want to look for string \"Enjoy\" in string \"Note: Enjoy APS105!\" .",
    "Step 2: Think of a solution! We can do it in several ways.",
    "One way is to look for \"Enjoy\" in the first 5 characters of \"Note: Enjoy APS105!\" , then in the next 5 characters in \"Note: Enjoy APS105!\" , and so on.",
    "We can use strncmp to specify the number of characters to compare.",
    "The number of characters to compare can be found using strlen on \"Enjoy\" .",
    "We need a pointer to save the location of the next staring character in \"Note: Enjoy APS105!\" we want to compare with \"Enjoy\" .",
    "Step 3: Decompose into steps.",
    "Set char* temp to the first character of \"Note: Enjoy APS105!\" .",
    "Compare the first 5 characters of temp with \"Enjoy\" .",
    "If they are identical, return temp .",
    "If they are not identical, increment temp by 1.",
    "If character at temp is not \\0 , go to step 2.",
    "Otherwise, return NULL .",
    "If character at temp is not \\0 , go to step 2.",
    "Otherwise, return NULL .",
    "Step 4: Write a code.",
    "In line \\(16\\) , we set temp to point to the first character in s1 .",
    "In line \\(19\\) , we compare the first 5 characters of temp with \"Enjoy\" .",
    "If they are identical, we set found to true .",
    "If they are not identical, we increment temp by 1.",
    "In line \\(18\\) , as long as *temp is pointing at the last character in s1 , which is \\0 , and the string is not hence found is false , we continue to compare the first 5 characters of temp with \"Enjoy\" .",
    "In line \\(25\\) , when we exit the loop.",
    "found can be true or false .",
    "If found is true , temp will hold the position of the first character in s1 that is identical to substring s2 .",
    "If found is false , then we did not find s2 in s1 , hence we should return NULL .",
    "Alternative solution.",
    "We can also look for E in \"Note: Enjoy APS105!\" , then starting at 'E' compare the next substring of 5 characters in s1 with \"Enjoy\" .",
    "If they are identical, we can return the pointer to that 'E' .",
    "If they are not identical, we can look for the next E in \"Note: Enjoy APS105!\" and repeat the process.",
    "We can do so using strchr to find the next E in \"Note: Enjoy APS105!\" .",
    "In line \\(3\\) , we set foundChar to point to the first character in s1 that is identical to the first character in s2 .",
    "In line \\(5\\) , we compare the first 5 characters of foundChar with \"Enjoy\" .",
    "If they are identical, we set found to true .",
    "In line \\(8\\) , if they are not identical, we start from the next character in after the character in foundChar by incrementing foundChar , and look for the next E in \"Note: Enjoy APS105!\" .",
    "strchr will return NULL is the character E is not found, and foundChar will be set to NULL .",
    "In line \\(4\\) , if foundChar is not NULL , and found is still false , we continue to compare the first 5 characters of foundChar with \"Enjoy\" .",
    "In line \\(11\\) , we exit the loop when either found is true , hence foundChar will point to the first character of the substring found, or foundChar is NULL , hence we did not find s2 in s1 .",
    "Either ways, we should return foundChar .",
    "The following table lists the most commonly used string functions.",
    "Function Description",
    "strlen Returns the length of a string.",
    "strcpy Copies a string.",
    "strncpy Copies the first  n  characters of a string.",
    "strcat Concatenates two strings.",
    "strncat Concatenates the first  n  characters of two strings.",
    "strcmp Compares two strings.",
    "strncmp Compares the first  n  characters of two strings.",
    "strchr Searches for a character in a string.",
    "strstr Searches for a substring in a string.",
    "Quiz",
    "0 Questions",
    "3.4.  Exercises #",
    "Many of these exercises are taken from past exams of APS105 Computer Fundamentals courses at University of Toronto.",
    "The solutions are provided in the answer boxes.",
    "3.4.1.  Conditional Statements #",
    "3.4.1.1.  Practice 1 #",
    "Question 2 in Winter 2018 Midterm Exam",
    "Write a single C statement — which contains exactly one terminating semi-colon ( ; ), and does not contain brace brackets ( { or } ) — that declares a bool variable named isHighlighted , and sets its value to true if and only if the value stored in an integer variable named characterCount is an even positive number.",
    "Assume that the variable characterCount has already been declared and initialized.",
    "3.4.1.2.  Practice 2 #",
    "Question 2 in Winter 2019 Midterm Exam",
    "Write a single C statement that declares a boolean-type variable named divisible and assigns true to divisible if and only if the value stored in the int variable named numOfItems is exactly divisible by \\(5\\) or \\(7\\) .",
    "Assume that variable numOfItems has been declared and initialized.",
    "3.4.1.3.  Practice 3 #",
    "Question 7 in Winter 2018 Final Exam",
    "Evaluate the following relational expressions by circling the right answer.",
    "Expression true  /  false",
    "'\\O'   ==   0 ",
    "int   x   =   10   %   8; (x   >   0)   &&   (x   %   2   ==   0)   &&   !false ",
    "'c'   -   3   ==   'a' ",
    "int   w   =   rand()   %   75   *   2   -   99; (w   <   -99)   ||   (w   >   49); ",
    "Expression true  /  false",
    "'\\O'   ==   0 true , since  \\0  has ASCII code of zero",
    "int   x   =   10   %   8; (x   >   0)   &&   (x   %   2   ==   0)   &&   !false true , since  x  stores  \\(2\\)",
    "'c'   -   3   ==   'a' false , since  'c'   -   2   ==   'a'",
    "int   w   =   rand()   %   75   *   2   -   99; (w   <   -99)   ||   (w   >   49); false , since the range of random numbers in  w  is between -99 and 49 inclusive",
    "3.4.1.4.  Practice 4 #",
    "Question 3 in Winter 2022 Midterm Exam",
    "Suppose that x and y are int type variables, write a single C statement that is equivalent to the following statement, but is simpler, i.e. with fewer boolean and relational operators.",
    "3.4.2.  Nested-if Statements #",
    "3.4.2.1.  Practice 1 #",
    "Modified version of Question 7 in Winter 2019 Midterm Exam",
    "Write C program to find the median, which is the number at the middle, among three integers p , q and r .",
    "The program should prompt the user to enter three integers, which get stored in p , q and r .",
    "Your program should print the value of the number at the middle.",
    "For example, with integers \\(2\\) , \\(7\\) , and \\(5\\) as input, the function returns 5; with integers \\(6\\) , \\(4\\) , and \\(6\\) as input, the function returns \\(6\\) .",
    "Download median.c to get the following code.",
    "3.4.2.2.  Practice 2 #",
    "Modified Version of Question 4 in Winter 2022 Midterm Exam",
    "The following program finds the middle character, e.g., if we have a = 'a' , b = 'b' , and c = 'c' , the program prints b .",
    "Rewrite this function such that it only uses one printf and one nested if-else statement.",
    "3.  Decision-Making Statements #",
    "In the previous chapter, we discussed different data types and operations we can perform.",
    "A key ability of a computer is to take decisions based on a condition.",
    "In this chapter, we will discuss how to make decisions in C.",
    "We will discuss the if , else and else if statements.",
    "3.2.  Multiple Conditions #",
    "On top of our eligible-age.c program, we want to check if a user’s age is between 14 and 16 .",
    "If this is the case, the user is eligible to work only if it is not during school hours.",
    "You may guess that we can write the condition as (14 <= age <= 16) .",
    "However, it is not permitted to have two relational operators on one operand.",
    "This is technically two conditions not one, as (14 <= age <= 16) translates to (age <= 16) and (age >= 14) .",
    "How do we check for these multiple conditions?",
    "We can use logical/boolean operators to combine multiple conditions.",
    "For example, “and” can be written as && .",
    "Hence, (14 <= age <= 16) can be correctly written as (age >= 14 && age <= 16) .",
    "Back to extending our program! We can extend the block executed if the age is 14 or higher, which is the else block.",
    "There, we can check if the age is between 14 and 16.",
    "If it is, we need to print an extra warning message stating that it is only permissible to work outside of school hours.",
    "To extend our program, we write the highlighted code segment.",
    "The above code is still under development.",
    "In the Nested-if statements section, it will look better.",
    "3.2.1.  Logical/Boolean Operators #",
    "There are three logical operators: and \\(\\rightarrow\\) && , or \\(\\rightarrow\\) || , and not \\(\\rightarrow\\) ! .",
    "In the following table, A and B evaluate to true or false , i.e. are conditions or conditional expressions or boolean variables.",
    "The outcome of a logical operation between A and B is expressed in a truth table.",
    "The following table shows the truth table for the AND && and OR || operator.",
    "A B A   &&   B A   ||   B",
    "false false false false",
    "false true false true",
    "true false false true",
    "true true true true",
    "The following table shows the truth table for the NOT ! operator.",
    "A !A",
    "false true",
    "true false",
    "In summary, AND requires both A and B to be true to be true .",
    "OR requires either A or B to be true to be true .",
    "NOT reverses the value of A .",
    "Exercise: OR operator",
    "For example, let’s write a C code that checks if a character entered by the user is an upper case 'A' or lower case 'a' .",
    "If it is, we will print a prompt to the user saying so.",
    "Otherwise, we will print that it is not an 'A' or 'a' .",
    "Download upper-lowerA.c to get the following code.",
    "Exercise: NOT operator",
    "The NOT operator is typically used to reverse a condition, or create a more readable code.",
    "For example, if (done == false) can be written as if (!done) , where if done is true , the conditions are both false and vice versa.",
    "Another example, let’s write a C code that checks if the characters entered by the user is not an alphabet.",
    "Note: ASCII code of all upper case alphabets is smaller than lower case alphabets.",
    "To write this condition, we need to think of the range of ASCII codes of alphabets.",
    "Alphabets have their ASCII codes between 'A' and 'Z' or between 'a' and 'z' .",
    "If the character is not between these two ranges, it is not an alphabet.",
    "Find the figure below for an illustration.",
    "Fig. 3.1  ASCII code range of alphabets highlighted in blue. #",
    "One way is to write the condition for alphabets, as",
    "((letter >= 'A') && (letter <= 'Z')) || ((letter >= 'a') && (letter <= 'z'))",
    "then negate it using ! .",
    "This makes",
    "!(((letter >= 'A') && (letter <= 'Z')) || ((letter >= 'a') && (letter <= 'z'))) .",
    "Using the diagram above, you can also develop the condition as (letter < 'A') || (letter > 'Z' && letter < 'a') || (letter > 'z') .",
    "Both conditions are equivalent.",
    "However, the first one is easier to think of if you did not have a figure.",
    "Download not-alphabet.c to get the following code checking if a character entered by the user is an alphabet.",
    "NOT ! vs.",
    "NOT EQUAL !=",
    "! is a logical operator.",
    "It is not to be confused with a relational operator != .",
    "! is to be placed before a condition that is either true or false .",
    "For example, !(x > 5) is valid and it is true is x is not greater than 5 .",
    "While != compares two values and returns true if they are not equal.",
    "For example, (x != 5) is valid and it is true is x is not equal to 5 .",
    "3.2.1.1.  Lazy Evaluation #",
    "For example, you may have a condition that checks if x % y < 10 .",
    "As you know from What happens when we divide by 0?",
    "and Modulo operator , if y is 0 , the program’s behavior is undefined.",
    "Hence, your program needs to check if y is 0 before checking x % y < 10 .",
    "One way to do this is to check if y is 0 first, and then check x % y < 10 if y is not 0 .",
    "This is called nested-if .",
    "The code snippet below shows how to do this.",
    "Another way is to make use of lazy evaluation .",
    "For example, the following code snippet is equivalent to the previous nested-if above.",
    "Lazy evaluation is a technique that allows you to combine multiple conditions into one.",
    "The condition is evaluated from left to right.",
    "In this case, y != 0 would be evaluated first , if it is false , the whole condition is false since the logical operator is && .",
    "The program will not evaluate the second condition x % y < 10 .",
    "If y != 0 is true , the program will evaluate the second condition x % y < 10 .",
    "Lazy evaluation is useful when you have multiple conditions that are related to each other.",
    "The rule in lazy evalution is:",
    "<LHS> || <RHS> : the <LHS> will be evluated first, if true , the whole condition is true and the program will not evaluate the <RHS> .",
    "If <LHS> is false , the program will evaluate the <RHS> .",
    "<LHS> || <RHS> : the <LHS> will be evluated first, if true , the whole condition is true and the program will not evaluate the <RHS> .",
    "If <LHS> is false , the program will evaluate the <RHS> .",
    "<LHS> && <RHS> : the <LHS> will be evaluated first, if false , the whole condition is false and the program will not evaluate the <RHS> .",
    "If <LHS> is true , the program will evaluate the <RHS> .",
    "<LHS> && <RHS> : the <LHS> will be evaluated first, if false , the whole condition is false and the program will not evaluate the <RHS> .",
    "If <LHS> is true , the program will evaluate the <RHS> .",
    "3.2.1.2.  De Morgan’s Law #",
    "De Morgan’s Law is a rule that can be used to simplify a condition with logical operators.",
    "It is named after Augustus De Morgan, a British mathematician.",
    "For example, we have a C program with two variables x and y .",
    "Both x and y are used in a condition that is very difficult to read and understand in the following code snippet.",
    "De-Morgan’s Law can be used to simplify the condition.",
    "If A and B are conditional expressions that evaluate to either true or false , the rule is as follows:",
    "!(A && B) is equivalent to !A || !B",
    "!(A || B) is equivalent to !A && !B",
    "That is if there is a NOT operator outside, you can negate the two conditions inside and combine them with the logical operator that is AND, if it were an OR originally, or OR, if it were an AND originally.",
    "In this case, the condition !((x > 10) && (y < 5)) can be simplified by removing the ! outside the brackets, having x > 10 negated and y < 5 negated, and combining the two negated conditions with || instead of && .",
    "That is,",
    "!(x > 10) || !(y < 5)",
    "Then, we can get rid of the ! outside the brackets by getting the opposite of the condition of the two expressions inside the parentheses.",
    "The opposite of the relational expressions are shown in the table below.",
    "Relational operator Negation",
    "> <=",
    ">= <",
    "== !=",
    "This makes !(x > 10) \\(\\rightarrow\\) (x <= 10) and !(y < 5) \\(\\rightarrow\\) (y >= 5) .",
    "The final expression then would be (x <= 10 || (y >= 5)) .",
    "Steps to simplify the condition are shown in the following diagram.",
    "Fig. 3.2  Steps to simplify a condition using De Morgan’s Law. #",
    "3.2.2.  Summary of Precedence with relational and logical operators #",
    "! (<type>) sizeof() ++ or -- (but we will avoid using ++ or -- with other operators)",
    "* / %",
    "+ -",
    "< <= > >=",
    "== !=",
    "|| (2–8) if two operands with same precedence occur, they are evaluated from left to right (left-associative).",
    "(2–8) if two operands with same precedence occur, they are evaluated from left to right (left-associative).",
    "= += -= *= /= %= (9) if two operands with same precedence occur, they are evaluated from right to left (right-associative).",
    "= += -= *= /= %=",
    "(9) if two operands with same precedence occur, they are evaluated from right to left (right-associative).",
    "Common mistake in precedence!",
    "Since ! has higher precedence than relational operators, !(x > 10) is not equivalent to !x > 10 .",
    "In !x > 10 , !x is to be evaluated first, then (!x) > 10 .",
    "If x was 5, !x would be false as 5 is a non-zero number which is true as a condition.",
    "!x would be false , which is equivalent to 0.",
    "0 > 10 would evaluate to false as well.",
    "Hence, the condition !x > 10 is always false if x has non-zero number.",
    "The logic is illustrated in the following figure.",
    "Fig. 3.3  NOT  !  precedence example. #",
    "While in !(x > 10) , if x is 5, !(x > 10) would be !(false) which is true .",
    "Clearly, !(x > 10) is not equivalent to !x > 10 .",
    "A programmer needs to make sure enough parentheses are used to avoid such mistakes.",
    "Quiz",
    "0 Questions",
    "3.3.  Nested-if statements #",
    "In the previous section, we developed the following program that printed to the user if they’re eligible to work in Ontario, Canada based on their age.",
    "We wrote an if-else statement inside the else of another if-statement.",
    "This is referred to as a nested-if statement .",
    "Nested-if statements are useful when we want to check multiple conditions as we observed in the previous section.",
    "Not elegant code",
    "In the following code, we wrote a more elegant code.",
    "In line 9, we can see else if (<condition>) , which is evaluated only if the condition in the preceding if statement is false .",
    "This is also called a nested-if statement , but it is more readable and elegant.",
    "More elegant code",
    "3.3.1.  Longer nested-if statements #",
    "Let’s develop a C program that finds the maximum of three integers x , y and z and stores the maximum int in a variable named max .",
    "Step 1: Toy example.",
    "Let’s say we have x = 3 , y = 4 and z = 5 .",
    "The maximum is expected to be z .",
    "Step 2: Think of a solution.",
    "We can compare two integers first, and then the maximum of them can be compared with the third int.",
    "For example, we compare x and y , and the larger number gets compared with z .",
    "Fig. 3.4  The steps of comparing three numbers to find the maximum. #",
    "Step 3: Decompose solution into steps.",
    "First, we compare x and y .",
    "If x is larger, we compare x and z .",
    "If y is larger, we compare y and z .",
    "Second, we compare the maximum of x and y with z .",
    "If the maximum is larger, we print the maximum.",
    "If z is larger, we print z .",
    "Step 4: Draw your solution.",
    "The following flow chart shows the steps of the solution.",
    "Fig. 3.5  Flow chart of the steps of comparing three numbers to find the maximum. #",
    "Step 5: Make sure your steps works on other toy examples.",
    "Try a toy example with the maximum number in a different variable.",
    "For example, x = 5 , y = 3 and z = 4 .",
    "The maximum is expected to be x .",
    "Step 6: Write the code.",
    "The following code implements the steps of the flow chart.",
    "Download max-of-three-method1.c to get the following code.",
    "More elegant code can be written if we thought backwards.",
    "We can think of the condition that is true only if x is the maximum, i.e. , (x > y && x > z) and the conditions that is true only if y is the maximum, i.e. , (y > x && y > z) and else z is the maximum.",
    "The following code implements this idea.",
    "Download max-of-three-method2.c",
    "3.3.2.  Dangling else problem #",
    "The brackets {} in the if-statements are not necessary when the code block is one line.",
    "For example, the following code is valid without brackets {}.",
    "Code without brackets {}",
    "However, it is a good practice to use brackets {} to avoid an issue referred to as the dangling else problem .",
    "For example, in the following code, the else belongs to which if statement?",
    "By default, the else belongs to the if statement that is closest to it, if there were no brackets.",
    "Code with dangling else problem",
    "Quiz",
    "0 Questions",
    "3.1.  If-statements #",
    "Let’s develop a decision-making program! We want to develop a program that prompts the user to enter their age.",
    "If it was below the legal age to work in Ontario, Canada, the program prints “You are not yet eligible to work in Ontario.”, else it prints “You are eligible to work in Ontario.”",
    "In C, we use the if statement to make decisions.",
    "The if statement is a conditional statement that executes a block of code if a condition is true .",
    "The syntax of the if statement is as follows:",
    "If we want to execute another block of code if the condition is false .",
    "We can have an else to the if -statement.",
    "The syntax of the if-else statement is as follows:",
    "3.1.1.  What can this  condition  be? #",
    "The condition can be a bool variable.",
    "Recall bool variable takes either a true or false value.",
    "Note: if the bool variable is false , the true block of code will never be executed.",
    "If the bool variable is true , the false block of code will never be executed.",
    "Code #include <stdbool.h> #include <stdio.h> int main(void) { bool flag = true; if (flag) { printf(\"The flag is true.\"); } else { printf(\"The flag is false.\"); } return 0; }",
    "The condition can be a bool variable.",
    "Recall bool variable takes either a true or false value.",
    "Note: if the bool variable is false , the true block of code will never be executed.",
    "If the bool variable is true , the false block of code will never be executed.",
    "The condition can be a numerical value.",
    "Recall that true is stored as 1 , and false is stored as 0 as we discussed in Boolean section.",
    "To be more accurate, C is only strict in the representing false as 0.",
    "While true can be any non-zero number.",
    "In other words, any non-zero value in the condition makes the condition true .",
    "While a zero value in the condition makes the condition false .",
    "Code #include <stdio.h> int main(void) { if (3) { printf(\"The condition is true.\"); } else { printf(\"The condition is false.\"); } return 0; }",
    "The condition can be a numerical value.",
    "Recall that true is stored as 1 , and false is stored as 0 as we discussed in Boolean section.",
    "To be more accurate, C is only strict in the representing false as 0.",
    "While true can be any non-zero number.",
    "In other words, any non-zero value in the condition makes the condition true .",
    "While a zero value in the condition makes the condition false .",
    "The condition can be a “relational expression” that evaluates to true or false .",
    "Relational expressions have relational operators summarized in the table below.",
    "Relational Operator Meaning == Equal to != Not equal to < Less than > Greater than <= Less than or equal to >= Greater than or equal to For example, the code below is a program that prompts the user if they are eligible to work in Ontario, based on their age.",
    "Download eligible-age.c to get the following code.",
    "Code #include <stdio.h> int main(void) { int age = 0; printf(\"Enter your age: \"); scanf(\"%d\", &age); if (age < 14) { // Condition checking if age is less than 14 printf(\"You are not yet eligible to work in Ontario.\"); } else { printf(\"You are eligible to work in Ontario.\"); } return 0; } Another example, let’s write a program in C that identifies if a shape is rectangle or square based on the two sides given by the user.",
    "Download square-rectangle.c to get the following code.",
    "Code #include <stdio.h> int main(void) { int height = 0, width = 0; printf(\"Please enter the height and width of your shape: \"); scanf(\"%d %d\", &height, &width); if (height == width) { printf(\"The shape is a square.\"); } else { printf(\"The shape is a rectangle.\"); } return 0; } Equal to \\(==\\) Vs. Assignment \\(=\\) One of the most common mistakes is that people confuse the relational operator == with the assignment operator = .",
    "The relational operator == compares the right hand side with the left hand side and returns true if they are equal and false otherwise.",
    "The assignment operator = assigns the value on the right hand side to the variable on the left hand side.",
    "What would happen if you got confused and wrote if (x = 5) instead of if(x == 5) , for example?",
    "In if (x = 5) , 5 is assigned to x , which returns 5 (recall Assignment operators ).",
    "The condition here will always be true , since the numerical value in place of the condition is 5 .",
    "This is not your intention indeed.",
    "Your intention is to check if x is equal to 5 .",
    "To do this, you should write if (x == 5) .",
    "The condition can be a “relational expression” that evaluates to true or false .",
    "Relational expressions have relational operators summarized in the table below.",
    "Relational Operator Meaning",
    "== Equal to",
    "!= Not equal to",
    "< Less than",
    "> Greater than",
    "<= Less than or equal to",
    ">= Greater than or equal to",
    "For example, the code below is a program that prompts the user if they are eligible to work in Ontario, based on their age.",
    "Download eligible-age.c to get the following code.",
    "Another example, let’s write a program in C that identifies if a shape is rectangle or square based on the two sides given by the user.",
    "Download square-rectangle.c to get the following code.",
    "Equal to \\(==\\) Vs. Assignment \\(=\\)",
    "One of the most common mistakes is that people confuse the relational operator == with the assignment operator = .",
    "The relational operator == compares the right hand side with the left hand side and returns true if they are equal and false otherwise.",
    "The assignment operator = assigns the value on the right hand side to the variable on the left hand side.",
    "What would happen if you got confused and wrote if (x = 5) instead of if(x == 5) , for example?",
    "In if (x = 5) , 5 is assigned to x , which returns 5 (recall Assignment operators ).",
    "The condition here will always be true , since the numerical value in place of the condition is 5 .",
    "This is not your intention indeed.",
    "Your intention is to check if x is equal to 5 .",
    "To do this, you should write if (x == 5) .",
    "3.1.2.  What can we do with relational operators? #",
    "Using relational operators, we can:",
    "Compare the values of int and double variables, e.g. (3 >= 2) or (7.2 > 5.1) or (-3.2 <= 1) ,",
    "Mix arithmetic and relational operators, where arithmetic operations have higher precedence, e.g., in (x + 2 == 5) , x + 2 is evaluated first and compared with 5 to see if they are equal, and",
    "Compare the values of two char variables, where the ASCII codes of the characters are compared, e.g., 'a' < 'b' \\(\\rightarrow\\) true since the ASCII code of 'a' is lower than 'b' .",
    "Compare the values of char and int values, e.g., ('0' == 0) \\(\\rightarrow\\) false since '0' has an ASCII code of 48, which is not equal to 0 .",
    "Quiz",
    "0 Questions",
    "14.1.  Insertion Sort #",
    "The first sorting algorithm we discuss is insertion sort.",
    "Insertion sort is a simple sorting algorithm that builds the final sorted array (or list) one item at a time.",
    "It is much less efficient on large lists than more advanced algorithms such as quicksort.",
    "However, it is an excellent algorithm for learning about sorting and is often used to sort small lists or arrays.",
    "14.1.1.  Algorithm #",
    "The general idea of insertion sort is to iterate through the array, and insert each element into its correct position with respect to the elements that have already been sorted.",
    "For example, if the only the first 3 elements of the array are sorted, the forth element will be inserted into its correct position with respect to the first 4 elements.",
    "This happens by by shifting all elements that are greater than the forth element to the right, and inserting A[top] in place of the left most element greater than forth element.",
    "This places the forth element in its correct position with respect to the first four elements.",
    "Given the following example array named int A[] = {9, 2, 6, 5, 1, 7};",
    "Insertion sort works as follows:",
    "Insert the second element into it’s correct position, with respect to the first two elements.",
    "After the first iteration, the first two elements — as a sub-array — are sorted.",
    "Insert the second element into it’s correct position, with respect to the first two elements.",
    "After the first iteration, the first two elements — as a sub-array — are sorted.",
    "Insert the third element into it’s correct position, with respect to the first three elements.",
    "After the second iteration, the first three elements — as a sub-array — are sorted.",
    "Insert the third element into it’s correct position, with respect to the first three elements.",
    "After the second iteration, the first three elements — as a sub-array — are sorted.",
    "Insert the fourth element into it’s correct position, with respect to the first four elements.",
    "This happens by shifting all elements that are greater than A[top] to the right , and insert A[top] in its correct position with respect to the first 4 elements.",
    "After the third iteration, the first four elements — as a sub-array — are sorted.",
    "Insert the fourth element into it’s correct position, with respect to the first four elements.",
    "This happens by shifting all elements that are greater than A[top] to the right , and insert A[top] in its correct position with respect to the first 4 elements.",
    "After the third iteration, the first four elements — as a sub-array — are sorted.",
    "Insert the fifth element into it’s correct position, with respect to the first five elements by shifting all elements that are greater than A[top] to the right, and inserting A[top] in place of the left most element greater than A[top] .",
    "This places A[top] in its correct position with respect to the first 5 elements.",
    "After the fourth iteration, the first five elements — as a sub-array — are sorted.",
    "Insert the fifth element into it’s correct position, with respect to the first five elements by shifting all elements that are greater than A[top] to the right, and inserting A[top] in place of the left most element greater than A[top] .",
    "This places A[top] in its correct position with respect to the first 5 elements.",
    "After the fourth iteration, the first five elements — as a sub-array — are sorted.",
    "Do the same as step 4, but with the sixth element.",
    "After the fifth iteration, the first six elements — as a sub-array — are sorted.",
    "Do the same as step 4, but with the sixth element.",
    "After the fifth iteration, the first six elements — as a sub-array — are sorted.",
    "To implement insertion sort, we need to keep track of the index of the element that is currently being inserted into its correct position.",
    "This index is called top .",
    "We also need to keep track of the index of the element that is currently being compared to A[top] .",
    "This index is called ind .",
    "We also need to keep track of the value of A[top] so that we can insert it into its correct position.",
    "This value is called item .",
    "14.1.2.  Pseudocode #",
    "We write pseudocode for insertion sort as follows:",
    "Set top to 1 ,",
    "Set item to A[top] , and ind to top .",
    "If item is smaller than A[ind - 1] , then set A[ind] to A[ind - 1] and decrement ind .",
    "Repeat 3 until ind is 0 or when item is no longer smaller than A[ind - 1] .",
    "This shifts all elements that are greater than item to the right.",
    "Repeat 3 until ind is 0 or when item is no longer smaller than A[ind - 1] .",
    "This shifts all elements that are greater than item to the right.",
    "Now, chose the correct position for item by setting A[ind] to item .",
    "In the next iteration, set top to top + 1 , set item to A[top] , and ind to top .",
    "Repeat 3-6 until top is equal to listLength .",
    "14.1.3.  Implementation #",
    "The following code snippet shows the insertion sort function.",
    "Quiz",
    "0 Questions",
    "14.3.  Bubble sort #",
    "Bubble Sort is a simple sorting algorithm that works by repeatedly stepping through the list, comparing each pair of adjacent elements and swapping them if they are in the wrong order.",
    "The process is repeated until the entire list is sorted.",
    "The algorithm gets its name because the smaller elements “bubble” to the top of the list, while the larger elements “sink” to the bottom.",
    "14.3.1.  Algorithm #",
    "Bubble sort works as follows:",
    "In the first iteration, compare the first element with the second element.",
    "If the first element is greater than the second element, swap them.",
    "Otherwise, do nothing.",
    "Then, compare the second element with the third element.",
    "If the second element is greater than the third element, swap them.",
    "Otherwise, do nothing.",
    "The process repeats till the last element of the array.",
    "After the first iteration, the last element of the array is sorted, and is holding the maximum element of the array.",
    "We “bubbled” the last element to the end of the array.",
    "In the first iteration, compare the first element with the second element.",
    "If the first element is greater than the second element, swap them.",
    "Otherwise, do nothing.",
    "Then, compare the second element with the third element.",
    "If the second element is greater than the third element, swap them.",
    "Otherwise, do nothing.",
    "The process repeats till the last element of the array.",
    "After the first iteration, the last element of the array is sorted, and is holding the maximum element of the array.",
    "We “bubbled” the last element to the end of the array.",
    "In the second iteration, compare the first element with the second element.",
    "If the first element is greater than the second element, swap them.",
    "Otherwise, do nothing.",
    "Then, compare the second element with the third element.",
    "If the second element is greater than the third element, swap them.",
    "Otherwise, do nothing.",
    "The process repeats till the second last element of the array.",
    "After the second iteration, the last two elements of the array are sorted, holding the maximum two elements of the array.",
    "In the second iteration, compare the first element with the second element.",
    "If the first element is greater than the second element, swap them.",
    "Otherwise, do nothing.",
    "Then, compare the second element with the third element.",
    "If the second element is greater than the third element, swap them.",
    "Otherwise, do nothing.",
    "The process repeats till the second last element of the array.",
    "After the second iteration, the last two elements of the array are sorted, holding the maximum two elements of the array.",
    "In the third iteration, compare the first element with the second element.",
    "If the first element is greater than the second element, swap them.",
    "Otherwise, do nothing.",
    "The process repeats till the third last element of the array.",
    "After the third iteration, the last three elements of the array are sorted, holding the maximum three elements of the array.",
    "In our example, this is the last iteration because the array has only four elements.",
    "Hence, the maximum number of iterations is the size of the array minus one.",
    "In the third iteration, compare the first element with the second element.",
    "If the first element is greater than the second element, swap them.",
    "Otherwise, do nothing.",
    "The process repeats till the third last element of the array.",
    "After the third iteration, the last three elements of the array are sorted, holding the maximum three elements of the array.",
    "In our example, this is the last iteration because the array has only four elements.",
    "Hence, the maximum number of iterations is the size of the array minus one.",
    "Save iterations.",
    "To save iterations, we can stop the algorithm if the array is already sorted at any point in time.",
    "We can do this by keeping track of whether a swap has occurred in the current iteration.",
    "If no swap has occurred, we can stop the algorithm.",
    "14.3.2.  Pseudocode #",
    "We write pseudocode for bubble sort as follows:",
    "Set top to n - 1 , where n is the size of the array.",
    "Set index ind to 0 .",
    "Set sorted to false .",
    "Compare the element at index ind with the element at index ind + 1 .",
    "If the element at index ind is greater than the element at index ind + 1 , swap them.",
    "If we swap, this means the array wasn’t sorted and their were two elements out of order, so we set sorted to false .",
    "Otherwise, do nothing.",
    "Compare the element at index ind with the element at index ind + 1 .",
    "If the element at index ind is greater than the element at index ind + 1 , swap them.",
    "If we swap, this means the array wasn’t sorted and their were two elements out of order, so we set sorted to false .",
    "Otherwise, do nothing.",
    "Increment ind by 1 .",
    "Repeat steps \\(4\\) and \\(5\\) until ind is equal to top .",
    "If sorted is true , stop the algorithm.",
    "Otherwise, set top to top - 1 and go to step \\(2\\) .",
    "If sorted is true , stop the algorithm.",
    "Otherwise, set top to top - 1 and go to step \\(2\\) .",
    "14.3.3.  Implementation #",
    "We implement bubbble sort as follows.",
    "In lines \\(1\\) to \\(5\\) , we implement the swap function that swaps two int values.",
    "We implemented the swap function before in Section 6.3 .",
    "Download bubble-sort.c if you want to play with the code.",
    "Quiz",
    "0 Questions",
    "14.4.  Exercises #",
    "Many of these exercises are taken from past exams of APS105 Computer Fundamentals courses at University of Toronto.",
    "The solutions are provided in the answer boxes.",
    "Headings in this page classify the exercises into different categories: [Easy] , [Intermediate] , and [Challenging] .",
    "I suggest you start by easy exercises and work your way up to the challenging ones.",
    "Question 3 in Winter 2019 Final Exam[Easy]",
    "The following array of integers is the result of the first round of partitioning, used in the Quicksort algorithm to sort the array in ascending order.",
    "Identify the possible array element or elements that could have been used as the pivot in the first partitioning round.",
    "Justify your answer; guessing an answer with no justifications will result in a mark of zero.",
    "The pivot is 71, because all elements on its left are smaller than it {15, 6, 45, 60, 32} , and all elements on its right are larger then it {102, 81} .",
    "Question 5 in Winter 2019 Final Exam[Easy]",
    "We have a number of TAs who have carefully marked a large number of final exams and now must sort them alphabetically.",
    "[PLEASE NOTE that this question is not worth many marks, so answer with a phrase! Do not spend time elaborating.]",
    "(a) Here are some sorting methods you know about.",
    "Which ones would work well, and which not well to allow the TAs to most quickly sort the exams?",
    "Why or why not would the particular method work well or not?",
    "Method OK? Reason",
    "Insertion Sort  ",
    "Selection Sort  ",
    "Bubble Sort  ",
    "Quicksort  ",
    "Method OK? Reason",
    "Insertion Sort No All TAs have to work on looking for one element to place it at the end",
    "Selection Sort No All TAs have to work on looking for one element to place it at the end",
    "Bubble Sort No All TAs have to work on looking for one element to place it at the end",
    "Quicksort Yes Each TA can work on groups of exams",
    "(b) What may be a better sorting method?",
    "Each TA takes a stack of exams and sorts into alphabetic piles which are then sorted.",
    "Question 15 in Winter 2018 Final Exam[Intermediate]",
    "Write a C function called sortOddEven() that rearranges the order of the elements in an integer array such that all odd numbers are to the left of all even numbers.",
    "The function has two parameters: a pointer to the integer array and an integer specifying the number of elements in the array.",
    "The odd numbers can be in any order, as long as they are all to the left of any even number, and the even numbers can be in any order, as long as they are all to the right of any odd number.",
    "For example, if the elements of the array initially are:",
    "then after sortOddEven() processes the array, the elements may become:",
    "Note: In your solution, you may not declare or use another array",
    "Recall partition function from quick sort.",
    "We can use the same idea to partition the array into two parts: odd numbers and even numbers.",
    "The following code implements the partition function.",
    "Question 10 in Fall 2015 Final Exam[Intermediate]",
    "Consider the following C struct and typedef declarations:",
    "Write a complete C function bubbleSortRecords , for which the prototype is given below, that uses the bubble sort algorithm to sort an array of n elements of type Record .",
    "The function should sort the elements in ascending order of GPA , and in the event of a tie, should break ties in alphabetical order of name, where name is a pointer to a string.",
    "You may use a function from the string library, string.h , in your answer.",
    "Hint: use the library function to compare two strings.",
    "Question 13 in Winter 2017 Final Exam[Intermediate]",
    "Quicksort is considered one of the fastest sorting algorithms in practice.",
    "However, it turns out that insertion sort is faster than quicksort for smaller arrays; e.g., for arrays with 10 or fewer elements.",
    "Because of this, many implementations use a combination of both algorithms: they use quicksort when the size of the array segment to be sorted is larger than 10, but switch over to insertion sort when the size of the array segment to be sorted is less than or equal to 10.",
    "Your job is to implement quicksort for an array of double s that automatically switches over to insertion sort for the small array segments with less than or equal to 10 elements.",
    "To make your job easier, you can assume the following function is available:",
    "This function processes the segment of array list from index from to index to .",
    "It selects a pivot in a smart way, and then partitions all elements in the [from, to] segment so that all elements less than or equal to pivot are located to the left of the pivot element and all elements greater than or equal to pivot are located to the right of the pivot element.",
    "The function then returns the index of the array where the pivot is located.",
    "Hence, after you call",
    "you are guaranteed that",
    "list[i] <= list[pIndex] when from ≤ i ≤ pIndex",
    "list[i] >= list[pIndex] when pIndex ≤ i ≤ to",
    "Question 11 in Winter 2019 Final Exam[Challenging]",
    "In general, the bubble sort algorithm can be explained in two steps.",
    "For each pair of adjacent elements: if they are out-of-order, then swap.",
    "Repeat the first step until no swaps are done.",
    "Write a function, bubbleSortLinkedList , that sorts a linked list using the bubble sort algorithm.",
    "The function has one parameter: a pointer to a LinkedList (assume that this pointer is not NULL ).",
    "The function will modify the linked list in-place so that the values are in ascending order (i.e., 1 comes before 2 ).",
    "The definitions for a LinkedList and Node are shown below.",
    "You must abide by the following constraints.",
    "Failure to meet a constraint will result in a grade of zero for this question.",
    "Your function must not modify the next pointer of any node.",
    "You cannot create any other data structures (e.g., an array, another linked list, etc.).",
    "Your function cannot call any other functions.",
    "Your function must not cause a segmentation fault.",
    "14.  Sorting #",
    "Sorting puts elements of an array or linked list in order.",
    "The order can be ascending or descending.",
    "We can sort numbers in ascending or descending order, or characters or strings in lexicographical order.",
    "This helps in producing a list of items that we can easily search through, analyze, visualize and understand.",
    "Sorting is used in many applications, including database systems, word processors, and web browsers.",
    "There are several sorting algorithms, but will only focus on:",
    "Insertion Sort",
    "Selection Sort",
    "Bubble Sort",
    "Disclaimer: We discuss these sorting algorithms to sort integers in an array in ascending order.",
    "The same algorithms can be used to sort integers in descending order or to sort characters or strings in lexicographical order or to sort nodes in a linked list.",
    "However, we will not discuss these variations in this chapter.",
    "14.2.  Selection Sort #",
    "Selection sort is a simple sorting algorithm that finds the minimum or maximum element from the unsorted part of the list and swap it with the last element of the unsorted part.",
    "It is much less efficient on large lists than more advanced algorithms such as quicksort.",
    "14.2.1.  Algorithm #",
    "For sorting in ascending order, the general idea of selection sort is to iterate through the array, and find the maximum element from the unsorted part of the list, which is initially the entire array, then swap it with the last element of the unsorted array.",
    "This makes the last element of the array sorted, and the remaining elements of the array unsorted.",
    "The process repeats till the entire array gets sorted.",
    "For example, if only the last 3 elements of the array are sorted holding the maximum 3 numbers of the array, we will look at the maximum number in the remaining of the array excluding the last 3 elements.",
    "This element will be swapped with the last element from the unsorted array, excluding the last 3 elements.",
    "This makes the last 4 elements of the array sorted, and holding the maximum 4 numbers of the entire array.",
    "Given the following example array named int A[] = {9, 5, 18, 8, 5, 2};",
    "Selection sort works as follows:",
    "Find the maximum element from the unsorted part of the array, which is initially the entire array.",
    "Then swap it with the last element.",
    "After the first iteration, the last element of the array — as a sub-array — is sorted, and is holding the maximum element of the array.",
    "Find the maximum element from the unsorted part of the array, which is initially the entire array.",
    "Then swap it with the last element.",
    "After the first iteration, the last element of the array — as a sub-array — is sorted, and is holding the maximum element of the array.",
    "Find the maximum element from the unsorted part of the array, which is the remaining of the array excluding the last element.",
    "Then swap it with the last element of the unsorted array.",
    "top is holding the index of the last element of the unsorted array.",
    "After the second iteration, the last two elements of the array — as a sub-array — are sorted, holding the maximum two elements of the array.",
    "Find the maximum element from the unsorted part of the array, which is the remaining of the array excluding the last element.",
    "Then swap it with the last element of the unsorted array.",
    "top is holding the index of the last element of the unsorted array.",
    "After the second iteration, the last two elements of the array — as a sub-array — are sorted, holding the maximum two elements of the array.",
    "If the largest element is also the last element in the unsorted sub-array, we swap the element with itself.",
    "After that, the last three elements of the array — as a sub-array — are sorted, holding the maximum three elements of the array.",
    "If the largest element is also the last element in the unsorted sub-array, we swap the element with itself.",
    "After that, the last three elements of the array — as a sub-array — are sorted, holding the maximum three elements of the array.",
    "The process repeats till the entire array gets sorted.",
    "14.2.2.  Pseudocode #",
    "We write pseudocode for selection sort as follows:",
    "Set top to n - 1 , where n is the length of the array.",
    "Iterate elements from index 0 to top to find the largest element and place its index in indexOfLargest",
    "Swap element at index top with element at index indexOfLargest .",
    "This places the largest element at the end of the unsorted sub-array.",
    "Swap element at index top with element at index indexOfLargest .",
    "This places the largest element at the end of the unsorted sub-array.",
    "Decrement top by 1 .",
    "Repeat steps 2 to 4 till top is 0 .",
    "14.2.3.  Implementation #",
    "We implement selection sort as follows.",
    "In lines \\(8\\) to \\(12\\) , we implement the swap function that swaps two int values.",
    "We implemented the swap function before in Section 6.3 .",
    "Download selection-sort.c if you want to play with the code.",
    "Quiz",
    "0 Questions",
    "12.3.  Exercises #",
    "Many of these exercises are taken from past exams of APS105 Computer Fundamentals courses at University of Toronto.",
    "The solutions are provided in the answer boxes.",
    "Headings in this page classify the exercises into different categories: [Easy] , [Intermediate] , and [Challenging] .",
    "I suggest you start by easy exercises and work your way up to the challenging ones.",
    "Question 2 in Winter 2022 Final Exam [Easy]",
    "In a single C statement, define a data structure named Student that has three members: the name of the student as a string ( char* ), the id of the student as an int , and the grades of the student.",
    "The type of the grades of the student is a data structure already defined as follows:",
    "In the same statement, declare one Student variable named test and an array named allStudents of \\(500\\) Student elements.",
    "Question 1 in Winter 2020 Final Exam [Easy]",
    "In a single C statement create a data structure called AnimalSizes having two elements, a string name and a size length .",
    "This same statement should create an array of this type called snakes with two entries.",
    "Initialize each entry such that the first index has name \"Anaconda\" and length \\(3.7\\) , while the second index has the name \"Python\" and length \\(2.4\\) .",
    "You may do this in the same statement or using additional statements.",
    "Question 7 in Winter 2020 Final Exam [Intermediate]",
    "In various engineering applications, it is required to convert Polar to Cartesian coordinates.",
    "The polar coordinates \\((R, \\theta)\\) and rectangular coordinates \\((x, y)\\) are related as follows:",
    "Complete the code below, which defines the data structures and a function that takes polar coordinates of a point and return the rectangular coordinates.",
    "The angle is assumed to be in radians.",
    "Assuming the values passed to this function is in degrees, you need to convert the radian value using the constant D2R below.",
    "Question 3 in Winter 2018 Final Exam [Intermediate]",
    "Consider the following data structure definition:",
    "Assume that all 1000 elements in the employees array have been initialized and none of the pointers are NULL.",
    "Write a single C statement that declares a character variable c and assigns it the first character of the last name of the second employee in the employees array.",
    "The second employee is at index 1, so employees[1] .",
    "The name is at employees[1].emplName , which is a pointer to Name structure.",
    "To access the last name of the employee, we can use the arrow operator -> to access the lastname field of the Name structure, employees[1].emplName->lastname .",
    "The first character of the last name is at employees[1].emplName->lastname[0] .",
    "Question 3 in Deferred Exam of Winter 2022 Final Exam [Intermediate]",
    "In the following two lines we create two data structures petal and flower .",
    "Write a single C statement that declares a variable named Flower of type struct flower .",
    "In the same statement, initialize the name of the Flower to \"Rose\" , the num of petals to 39 and the color of the petals to \"red\" .",
    "Question 5 in Winter 2022 Final Exam [Challenging]",
    "The following C program takes in two names from the user and saves them in the array of data structures students .",
    "However, the code does not output the expected output.",
    "When the user enters two different last names, the output is the last entered name for both the elements in the array.",
    "This is the output of an example run:",
    "Re-write the getNames function only to have the following output:",
    "12.2.  Pointers to Data Structures #",
    "12.2.1.  Access members of data structures through pointers #",
    "We can have pointers to declared variables of data structures.",
    "For example, in the following code, we define a data structure struct Neuron , and create an alias for it named Neuron .",
    "Then, we declare a variable neuron of type Neuron , and a pointer pNeuron of type Neuron * .",
    "The address of neuron is assigned to pNeuron .",
    "The following figure shows the code, the memory layout, and the output.",
    "Fig. 12.1  Pointers to data structures. #",
    "Arrow operator vs.",
    "dereference operator and dot operator",
    "There are two ways to access the members of a data structure through a pointer.",
    "The first way is shown in Fig.",
    "12.1 , where we dereference pNeuron which is a pointer to neuron , then use the dot operator as usual to access the members in neuron .",
    "The second way is where we use the arrow operator -> to access the members of neuron through pNeuron .",
    "This is equivalent to (*pNeuron).input .",
    "12.2.2.  Dynamic memory allocation of data structures #",
    "We can also dynamically allocate memory for data structures.",
    "For example, we can allocate memory for a data structure Neuron using the malloc function.",
    "The following figure shows the code, the memory layout, and the output.",
    "Download the code dynamic-mem-data-struct.c if you want to play with it.",
    "Fig. 12.2  Dynamic memory allocation of data structures. #",
    "In the above example, the memory allocation happens on the heap through this expression (Neuron *)malloc(sizeof(Neuron)) .",
    "malloc function returns the address of that allocated space on the heap.",
    "pNeuron then holds the address of that allocated space.",
    "We can then access the members of the data structure through pNeuron .",
    "Using pNeuron -> input is equivalent to (*pNeuron).input .",
    "This accessed input member of the dynamically allocated data structure on the heap.",
    "In the above example, we set pNeuron -> input to 23.96 .",
    "When we are done with the dynamically allocated data structure, we can free the memory using the free function as we show in the above example.",
    "The benefits/usage of data structures in solving problems will all be discussed in the next chapter on linked lists, and again in the last chapter on binary search trees.",
    "Quiz",
    "0 Questions",
    "12.  Data Structures #",
    "So far, we have discussed data types like int , double , char and bool .",
    "We also discussed if we want to store a combination of variables of the same data type in an array.",
    "In this chapter, we discuss how can we also store a combination of variables of different data types in a data structure.",
    "12.1.  What are data structures? #",
    "In this section, we discuss what are data structures.",
    "A data structure is a way to store data of different types using same variable name.",
    "For example, we can store a combination of variables of different data types in a data structure.",
    "Let’s model a neuron in the brain.",
    "A neuron has a set of input signals, output signals, and the name of the area it exists.",
    "We can use a data structure to store all this information.",
    "12.1.1.  Define a data structure #",
    "12.1.1.1.  Method 1: Define the data structure and declare the variable separately. #",
    "To model a neuron, we can define the data structure using the keyword struct as follows.",
    "Note that this only defines a data structure, but does not create any variables.",
    "No memory is being allocated for that data structure yet, because we did not yet declare any variables of the data type of the data structure struct Neuron .",
    "To declare a variable of struct Neuron type, we can do the following.",
    "The variable neuron is of type struct Neuron and is declared in line \\(8\\) .",
    "12.1.1.2.  Method 2: Define the data structure and declare a variable in the same statement. #",
    "In the same statement, we can declare a data structure and define a variable.",
    "For example, in the following figure we define struct Neuron and declare a variable neuron of type struct Neuron .",
    "How does neuron look like in memory?",
    "Let’s look at the following figure.",
    "The variable neuron is of type struct Neuron that contains four members: neuronNum of type int , input1 of type double , input2 of type double , and areaName of type char[] .",
    "12.1.2.  Access members of a data structure #",
    "To access members/fields of a data structure, we can use the dot operator.",
    "For example, in the following code we access the members of the data structure struct Neuron using the dot operator.",
    "12.1.3.  Initialize a data structure #",
    "When we declare a data structure variable, we can initialize all its members in the same statement.",
    "This is by using the curly brackets as with arrays {} .",
    "The order of the members in the curly brackets should be the same as the order of the members in the data structure definition.",
    "For example, in the following code we initialize the data structure variable globalNeuron and ``neuron` in the same statement as we declare them.",
    "12.1.4.  Creating an alias for a data structure #",
    "We can create an alias (another name) for a data structure or any other data type using the keyword typedef .",
    "In other words, it helps us to create a new name for an existing data type.",
    "typedef takes in two arguments: the existing data type and the new name of the data type.",
    "The syntax would be as follows:",
    "For example, to change the name of the data type char to byte , we can do the following:",
    "Now, we can use byte instead of char in our code.",
    "In the following code in lines \\(6\\) and \\(7\\) , we use byte instead of char in our code.",
    "typedef is beneficial to redefine the name of the data structure we had, which was struct Neuron to just Neuron .",
    "For example, in the following code we create an alias/another name Neuron for the data structure struct Neuron .",
    "We can define a data structure and create an alias for it in the same statement.",
    "For example, in the following code we define the data structure struct Neuron and create an alias Neuron for it in the same statement.",
    "The following figure summarizes the two methods of defining and redefining a data structure.",
    "Please note that this does not declare any variable of this data type.",
    "Instead, it defines the data structure and creates an alias for it.",
    "It is only when we declare a variable of this data type that the data structure is actually created, e.g. Neuron neuron creates a variable of Neuron data type.",
    "Quiz",
    "0 Questions",
    "6.1.  Why do we need pointers? #",
    "In the previous chapter, we discussed one way to communicate with a function.",
    "This was through passing several arguments and only get one value in return.",
    "In this section, we discuss why is this a problem.",
    "6.1.1.  Communicate from a function using  return #",
    "We can communicate from a function by returning a value.",
    "For example, in the following code, we have a function named isPerfectSquare that checks if the value in x is a perfect square.",
    "A perfect square is a number resulted from a rational number multiplied by itself.",
    "A rational number is a whole number, without a fractional part.",
    "\\(1\\) , \\(4\\) and \\(25\\) are all examples of perfect squares as they are a result of \\(1 = 1 \\times 1\\) , \\(4 = 2 \\times 2\\) and \\(25 = 5 \\times 5\\) .",
    "To check if x is a perfect square, the function isPerfectSquare checks that the integer part of the square root of x is the same as the square root of x .",
    "This would mean that \\(\\sqrt{x}\\) has no fractional part.",
    "isPerfectSquare would return either yes or no depending on if x is a perfect square.",
    "Multiple returns in one function is not neat! As you develop your code with if-statements, you may mistakenly forget to consider a condition where you had to return a value.",
    "To avoid such issues, we suggest that you have one return statement that is not part of any loop or if-statement.",
    "This is to ensure that it will be definitely executed and the function will return a value.",
    "For example, we can re-write isPerfectSquare function as follows, where it returns true if the int part of sqrt(x) is equal to sqrt(x) , i.e. there is no fractional number resulting from sqrt(x) , and returns false otherwise.",
    "Download perfect-square.c if you want to run the program yourself.",
    "Code snippet",
    "Another important usage of return is that we pass value to function by calling by value .",
    "Recall when we previously discussed Call by value , whenever a parameter is passed to a function, a copy of the value is sent to the function not the variable itself.",
    "This means that whatever change happens to the value passed to the function, it wouldn’t affect the variables in the caller function.",
    "For example, in the following simple code, even though p is changed in simple function, the value of p in main remains 12 .",
    "For details on why p in main function does not change refer to Call by value .",
    "If we want to pass the value of p in simple function after dividing it by \\(2\\) , we have to return p from simple function.",
    "For example, the following code highlights the lines we changed to return the value of p in simple function.",
    "6.1.2.  Limitation of being only allowed to  return one value #",
    "The problem happens when we want to communicate two or more values to the caller function.",
    "We cannot do so because we can only return one value, and calling by value only allows passing the values of the variables not the variables themselves.",
    "Hence, any change in the variables inside the function, it is only visible inside the function.",
    "Is there a case where we need to communicate to the caller function two or more variables?",
    "Yes! For example, let’s write a function that takes in two int variables and swaps them.",
    "How can we swap the values in assigned to two variables, x and y ?",
    "Step 1 We can store the value of x in a temporary variable",
    "Step 2 Change x with the value of y",
    "Step 3 Then assign y the value of the temporary variable",
    "The following image helps in understanding what happens in the swap function.",
    "Fig. 6.1  The steps of swapping two variables,  x  and  y . #",
    "The following video traces the code that swaps two variables in a function.",
    "Unfortunately, as you will see in the video the values of a and b were not swapped after the function call.",
    "This is because we are swapping the variables in the swap function, not the main function.",
    "The code discussed in the video is available below.",
    "Solution!! Instead of passing just the values of a and b , we can pass the addresses of a and b in the main function memory space in the main memory.",
    "This way any changes to a and b in swap function happens in main function too.",
    "This is possible if we use pointers .",
    "This is what we discuss in the next section.",
    "Quiz",
    "0 Questions",
    "6.6.  Exercises #",
    "Many of these exercises are taken from past exams of APS105 Computer Fundamentals courses at University of Toronto.",
    "The solutions are provided in the answer boxes.",
    "Headings in this page classify the exercises into different categories: [Easy] , [Intermediate] , and [Challenging] .",
    "I suggest you start by easy exercises and work your way up to the challenging ones.",
    "Question 9 in Fall 2013 Midterm Exam [Easy]",
    "Determine the values of the variables W , X , Y and Z after the function SumEm executes in the main program of the following C program:",
    "Question 1 in Winter 2017 Final Exam [Easy]",
    "Find and correct all compile-time errors (mistakes that would cause compilation or that would cause the ‘build’ to fail) in the following C program.",
    "Your answer should both identify what the error is, and what the correction should be.",
    "Marks will be deducted if you identify correct items as compile-time errors.",
    "Corrected condition and increment fields:",
    "*i < 10, *i = *i + 1 to *i < 10; *i = *i + 1",
    "Question 1 in Fall 2014 Midterm Exam [Easy]",
    "What will be printed when the following C program is executed?",
    "Question 6 in Winter 2017 Midterm Exam [Easy]",
    "Consider the following code, which uses pointers:",
    "What are the values of the variables a and b after this code is executed?",
    "a is 28 and b is 34.",
    "Question 5 in Winter 2018 Midterm Exam [Intermediate]",
    "Write the output of the following program.",
    "Modified version of Question 6 in Winter 2018 Midterm Exam [Intermediate]",
    "Identify the potential runtime error in the following code and briefly explain how you would fix it.",
    "Problem: In the function, pointer is assigned to a standard variable.",
    "Question 9 in Winter 2019 Midterm Exam [Intermediate]",
    "There are \\(0.3048\\) metres in a foot, \\(100\\) centimetres in a metre, and \\(12\\) inches in a foot.",
    "Write a program that will accept, as input, a length in feet and inches.",
    "You do not have to check for valid input – assume the user enters positive, non-fractional values for the feet and inches.",
    "The program will output the equivalent length in metres and centimetres (rounded to the nearest centimetre) .",
    "Your code should include four functions: one for input, one for output, one to perform the calculation, and main.",
    "The function prototypes are below.",
    "For full marks, your code should not use any global variables.",
    "An example of one run of the program is below:",
    "Question 13 in Winter 2014 Midterm Exam [Challenging]",
    "In this question, you are to complete the code for a function and its calling in a main program.",
    "The function is called sumAndProductOfMultiples .",
    "It takes integers multiple1 and multiple2 , and a maximum bound max as input, and computes both the sum and the product of all the positive integers less than max that are multiples of either multiple1 or multiple2 .",
    "For example, if multiple1 = 3 , multiple2 = 5 , and max = 10 , the positive integers less than \\(10\\) that are multiples of either \\(3\\) or \\(5\\) are \\(3\\) , \\(5\\) , \\(6\\) , \\(9\\) .",
    "Their sum is \\(23\\) , and their product is \\(810\\) .",
    "The function must return the sum and product values via pointer parameters sumPtr and productPtr , as implied in the skeleton code below.",
    "In the code skeleton below, you are given most of the main function, but you must give the call to the sumAndProductOfMultiples function.",
    "After that you are given just the declaration line of the function, and you must write the remainder of the function.",
    "Question 5 in Winter 2022 Midterm Exam [Challenging]",
    "In the box provided below, write the output generated after the following program is completely executed.",
    "6.  Pointers #",
    "In the previous chapter, we discussed functions, and how can we pass to a function one or more values and only return one value .",
    "We mentioned that variables within each function can only be accessed within a function, and only values were passed to and from functions.",
    "In this chapter, we discuss how can we access variables in other functions, and enhance the communication between functions more.",
    "6.2.  What are pointers? #",
    "As we discussed earlier, every variable in our code is stored in the main memory.",
    "A pointer is a variable that holds the address of another variable.",
    "In the following figure, we have two variables: a int variable named x and is set to \\(7\\) , and a pointer to a int named p that holds an address to a int .",
    "Fig. 6.2  int  and pointer to  int  ( int* ) variables in code and memory. #",
    "As we learned before, declaring a variable without initializing it makes the variable hold a garbage value, i.e. in the above program, the variable p holds a garbage address.",
    "How do we assign an address to a pointer?",
    "Using the reference operator & , we can get the address of a variable.",
    "For example, &x gets the address of variable x , which is \\(2\\) in the following figure.",
    "Then, we can assign this address \\(2\\) to p as in the following code.",
    "Fig. 6.3  assign  p  the address of  x . #",
    "How do we get the value stored in an address?",
    "Using the de reference operator * on a pointer variable, we can get the value stored at an address.",
    "For example, *p gets the value stored at address \\(2\\) , which is equal to \\(7\\) .",
    "Fig. 6.4  Assign contents pointed by  p  to  y . #",
    "Deep-dive Let’s look a little closer on the addresses and values stored in some addresses.",
    "In the following code, we print addresses and values stored in int s x and y , and in int* p .",
    "A format specifier for a pointer is %p .",
    "Download reference-deference.c if you want to play with the code yourself.",
    "Key observations from the printed statements:",
    "The variable x and y are stored in different places, but have the same value \\(7\\) .",
    "The pointer variable p has a different address from the address it stores.",
    "This is pointer p has the nature of storing addresses.",
    "The pointer variable p has a different address from the address it stores.",
    "This is pointer p has the nature of storing addresses.",
    "* gets us the value stored at an address, and & gets us the address of a variable, even if the variable is a pointer.",
    "This would mean *(&x) would mean x , as * and & cancel each other.",
    "* gets us the value stored at an address, and & gets us the address of a variable, even if the variable is a pointer.",
    "This would mean *(&x) would mean x , as * and & cancel each other.",
    "6.2.1.  Tracing exercise #",
    "Let’s trace the code below to get a better understanding of how pointers work.",
    "A short video that goes over a program with pointers line by line is posted below.",
    "We dive deeper into what happens in the main memory as we execute the program.",
    "Quiz",
    "0 Questions",
    "6.3.  How to use pointers to communicate more with functions? #",
    "Now that we know what are pointers and how to use them, we will use pointers to solve the issue with swapping two variables in a function.",
    "In the following figure, we highlight the additions we made to the source code where we called swap function by value (not by pointers).",
    "Source code can be downloaded from here: swapping.c , and can be copied from below.",
    "Fig. 6.5  Highlight additions in code when we changed the swap function to call it by pointers, not by value. #",
    "In the following video, we trace the program to see how it works.",
    "In line \\(3\\) , we changed the prototype to pass pointers as input parameters.",
    "The pointers data types are written as int* .",
    "In line \\(8\\) , instead of swap(a, b); , we are passing the addresses of a and b using swap(&a, &b); , because swap function now takes pointers that stores addresses, not int values.",
    "In lines \\(14\\) to \\(17\\) , we are dealing with the values stored in the addresses of x and y , hence we have to dereference x and y .",
    "*x accesses the value of a in the main function memory space in the main memory.",
    "Similarly, *y accesses the value of b stored in the main function memory space.",
    "6.3.1.  What is the size of the pointer variable? #",
    "We discussed before that old machines represent addresses using 32 bits, while modern machines use 64 bits.",
    "Let’s test what does my computer uses.",
    "I tried running the following code, where I print the size of pointers to main data types we use such as int* , double* , char* and bool* .",
    "All pointers require 8 bytes to store the values of addresses, i.e. 64 bits.",
    "Try out the code by downloading size-of-pointer.c , and can be copied from below.",
    "6.3.2.  Can a pointer hold the address of another pointer? #",
    "A pointer can hold the address of another pointer, since they are all addresses.",
    "However, if we have a pointer that holds address of an int its type is int* , and the type of the pointer that holds the address of that int* pointer is int** – an additional * is added.",
    "For example,",
    "In the main memory, the values of i , pi and ppi are shown in the following figure.",
    "Please note that addresses are arbitrary addresses.",
    "Fig. 6.6  How does a pointer to a pointer look like in the memory? It just holds another address. #",
    "It is important to note that int* pi; is equivalent to int *pi; , and",
    "is equivalent to",
    "6.3.3.  Can a function return a pointer? #",
    "Let’s write a function that returns a pointer to the variable with the maximum value.",
    "The function takes in two pointers to two double variables and returns one pointer to the largest double .",
    "6.3.4.  Initialization Vs. Declaration of a pointer variable #",
    "As we discussed earlier in Declaring Vs. Initializing Variables , if you declare a variable without initializing it as in int var; , it is unknown what is the value of var .",
    "var holds a “garbage” value.",
    "Similarly, with pointers, if you declare a pointer without initializing it, it holds a “garbage” address.",
    "For example, in the following program, we try using an uninitialized pointer.",
    "The warning message printed is “warning: variable ‘p’ is uninitialized when used here” as shown in the figure.",
    "Fig. 6.7  Warning message when using an uninitialized pointer variable. #",
    "Why is this an issue?",
    "The problem is if you ignore this error, and try to dereference p as in line 5 *p = 5; , you will be dereferencing a garbage address that may (or may not) exist.",
    "The behavior of your program is undefined.",
    "If the address exists, but your program can not access or does not have permission to access, the operating system will raise an error named “Segmentation Fault” error.",
    "If the address exists, and your program can access it (rarely happens), it may change a value of another variable in your program.",
    "If the address does not exist, your program may fail silently.",
    "This means it may not print statements in a printf , or it may not take input from the user in a scanf .",
    "If the address does not exist, your program may fail silently.",
    "This means it may not print statements in a printf , or it may not take input from the user in a scanf .",
    "In short, do not use an uninitialized pointer.",
    "This is why the compiler recommends you set the address of the pointer to NULL when you declare it.",
    "What is NULL ?",
    "NULL is defined pointer constant, which corresponds to \\(0\\) .",
    "In other words, NULL pointer is not pointing to any valid address.",
    "What happens if you dereference a NULL pointer?",
    "The behavior of your program is undefined.",
    "Then what is the benefit of initializing my pointer to NULL?",
    "The benefit of initializing a pointer to NULL is that before you dereference it, you can check if it is NULL or not.",
    "If it is NULL, then it does not have a valid address, and you shouldn’t dereference it.",
    "Otherwise, you can dereference it.",
    "For example, the following program checks if a pointer is NULL or not before dereferencing it.",
    "This good practice of checking if a pointer is NULL or not will be handy when we discuss “Linked Lists”.",
    "6.3.5.  Practice Problem solved Winter 2018 Midterm Exam Q7 #",
    "What is the output of the following program?",
    "The solution is discussed in the video above.",
    "Quiz",
    "0 Questions",
    "6.4.  Rules defining scope of variables #",
    "Given that now we understand the basics of the C programming language, especially loops, functions and pointers, we can discuss the topic of “scope” in details.",
    "The scope of a variable is the set of C statements where the variable is defined/visible/usable.",
    "In this section, we cover (revise) the cases where variables have limited scope.",
    "6.4.1.  Variables can only be used after they are declared. #",
    "For example, the error you will get if you run the following code is “error: use of undeclared identifier ‘i’”.",
    "Fig. 6.8  Using  i  variable before declaring it is not allowed, and will cause compile time error as  i  is undefined at  i   =   1;  line. #",
    "Variables declared in a function, can only be used in that function.",
    "These variables are referred to as local variables or internal identifiers .",
    "For example, in Fig.",
    "6.9 and Fig.",
    "6.10 , we observe the scope of the variables start from the moment they get declared till only the end of the function, even the main function.",
    "Fig. 6.9  The scope of  x  and  y  in  func  function starts from where they get declared till the end of the function. #",
    "Fig. 6.10  The scope of  x  in  main  function starts from where it gets declared till the end of the function. #",
    "6.4.2.  Use a variable declared in a compound statement #",
    "If you declare a variable within {} , also referred as within a compound statement , and use the variable after the } closing bracket, it is undefined.",
    "In other words, the scope of a variable is defined only within the closest {} .",
    "For example, the following figure shows a code that uses a variable outside its scope, which is within {} .",
    "Fig. 6.11  Using  x  variable outside the compound statement where it was declared. This causes a compile time error as  x  is undefined at line 10. #",
    "Code causing compile-time error",
    "6.4.3.  External identifiers/global variables #",
    "The external identifiers or global variables are defined at the top of the .c file outside the main function, and all other functions.",
    "Its scope is the entire program.",
    "However, it is not good practice to use them, as it can be error-prone.",
    "If several functions in your program are using the global variable, and each function is changing it can be difficult to manage/track the value of this global variable.",
    "Hence, it is not advisable to use global variables.",
    "6.4.4.  Overlapping scope #",
    "You can have a variable with the same name that has an overlapping scope.",
    "For example, the following code has two i variables.",
    "Their scope is illustrated in the following figure.",
    "Fig. 6.12  The overlapping scope of two variables named  i . #",
    "6.4.5.  Practice problem #",
    "In the following figure, we show the scope of different variables in a function.",
    "Check your knowledge looking at this figure.",
    "Fig. 6.13  Scope of different variables in a function. #",
    "Quiz",
    "0 Questions",
    "6.5.  Goldbach conjecture #",
    "In this section, we will write a longer program that checks for a given number if the Goldbach conjecture is verified or rejected.",
    "6.5.1.  Problem Statement #",
    "A conjecture is a proposition/opinion/observation that is not proven yet.",
    "For example, the Goldbach conjecture states:",
    "Every even integer greater than \\(2\\) can be written as the sum of two prime numbers.",
    "A prime number is a number divisible only by two distinct numbers: 1 and itself.",
    "For example, \\(2\\) , \\(3\\) , \\(5\\) , \\(7\\) , \\(11\\) , \\(13\\) , \\(17\\) .",
    "Keep in mind that \\(1\\) is not a prime number because it is divisible by \\(1\\) only, not two distinct numbers.",
    "Let’s write a program that asks for the user to input a number that is even and greater than \\(2\\) , and then checks if this number verifies or rejects the Goldbach conjecture.",
    "6.5.2.  Divide Problem into sub-problems #",
    "Let’s list the tasks to be done by this program:",
    "Take input number from the user",
    "Verify if the number is even and greater than \\(2\\)",
    "Test the Goldbach conjecture",
    "Print if the number verifies or rejects the conjecture",
    "Next, we tackle each task and decide if we can put it in a separate function or if it requires multiple functions.",
    "This helps us in easily managing a larger piece of software.",
    "6.5.2.1.  Take input from the user #",
    "As we take input from the user, we need to validate that it is even and greater than \\(2\\) before proceeding with testing the Goldbach conjecture.",
    "Loop type.",
    "As we discussed in Do-while loop vs.",
    "while loop , taking input from the user and validating it requires repetition until a valid input is made.",
    "Doing so requires that we first take the input from the user then validating it.",
    "This is what a do-while loop is best fit for.",
    "This is because a do-while loop will run its statements before checking the condition.",
    "Similarly, we want to take input from the user before checking it is even and greater than \\(2\\) .",
    "Function prototype.",
    "The following code is a function that takes the address of an int variable, i.e. int* , then the value at that address is changed to the input of the user.",
    "This is why we received a pointer int* to the function and return void .",
    "Code in-progress",
    "In line 6, we are using scanf without an & because number is already an address to the int we want to change.",
    "In line \\(8\\) , we are referring to the int variable that number has it’s address.",
    "This is why we dereference number to get to the int it is pointing to.",
    "Test with main function",
    "Currently, the prompt message is not telling the user why is their first and second input invalid.",
    "To have a clarifying prompt message after the user enters an invalid input, we can have a bool variable that indicates if it is the first time the user enters an input.",
    "We can use this bool variable to better explain to the user what is the expected input.",
    "The modified function is shown below.",
    "We added lines \\(17\\) , \\(19\\) – \\(22\\) .",
    "Improved getUserInput function",
    "6.5.2.2.  Test the Goldbach conjecture #",
    "Step 1: Toy example.",
    "For example, if the user enters \\(12\\) .",
    "Logically, we can think that 12 can be written as \\(12 = 5 + 7\\) .",
    "Step 2: Think of a solution and decompose into steps! The user entered \\(12\\) which is a sum of two int prime numbers, x and y , i.e. \\(12 = x + y\\) .",
    "To find x and y , we can",
    "Get the first prime number in x , which is \\(2\\) .",
    "Then get y , which is \\(y = 12 - x\\) .",
    "Check if y is prime.",
    "If y , is not prime, we increment x to the next prime number.",
    "Then we repeat steps \\(2\\) – \\(4\\)",
    "We stop repeating till we find y is prime or if the conjecture is rejected .",
    "When is the conjecture rejected?",
    "We stop repeating till we find y is prime or if the conjecture is rejected .",
    "When is the conjecture rejected?",
    "For example, in Fig.",
    "6.14 , we show the steps/iterations to verify the Goldbach conjecture for \\(12\\) .",
    "The conjecture gets rejected when we continue looking for x and y , but realize they will never be both prime numbers.",
    "This happens when x prime numbers start to surpass the values of y .",
    "This is also around when x becomes greater than the half of \\(12\\) , which is the number we are testing.",
    "Fig. 6.14  The steps of  verifying  or  rejecting  a conjecture. #",
    "Summary! We stop iterating and looking for x and y prime numbers either: (i) when the conjecture is verified ( x and y are prime) or (ii) when x becomes greater than y and we have never verified the conjecture before!",
    "Step 3: Write a pseudo-code.",
    "We can write the pseudo-code of the above steps.",
    "Pseudo-code is an informal language used to write code.",
    "It is intended to simplify a piece of code by writing it in plain English language mixed with a program language too.",
    "For example, we can translate the above steps to the following pseudo-code.",
    "Step 5: Write the code.",
    "There are two tasks in the previous pseudo-code that require a few lines of code to accomplish.",
    "These are: (i) if y is prime, and (ii) to get the next prime number after x .",
    "These two will be completed by different functions.",
    "We can define their function prototypes before proceeding with writing the code for testing Goldbach conjecture.",
    "Check if a number is prime.",
    "This can be a function that returns true is a number is prime and false if the number is not prime.",
    "The only input this function requires is the int value it will check.",
    "This makes the function prototype: bool isPrime(int);",
    "Check if a number is prime.",
    "This can be a function that returns true is a number is prime and false if the number is not prime.",
    "The only input this function requires is the int value it will check.",
    "This makes the function prototype:",
    "bool isPrime(int);",
    "Get the next prime number.",
    "There are many ways to advance to the next prime number.",
    "All what you need is to pass the address of x to that function, and the function will change the value of x and return void .",
    "This makes the function prototype: void nextPrimeNumber(int*);",
    "Get the next prime number.",
    "There are many ways to advance to the next prime number.",
    "All what you need is to pass the address of x to that function, and the function will change the value of x and return void .",
    "This makes the function prototype:",
    "void nextPrimeNumber(int*);",
    "In the following code, we convert the pseudo-code to a function written in C programming language.",
    "In line \\(7\\) , we check if rejected and verified are both false .",
    "This is by adding a ! before rejected and ! before verified and ANDing them: !rejected && !verified .",
    "In line \\(9\\) , we immediately use isPrime as we know it returns either true if y is a prime number or false otherwise: isPrime(y) .",
    "In line \\(14\\) , we use nextPrimeNumber by passing the address of x to it, and inside the function we will shortly implement the advancement of x to the next prime number: nextPrimeNumber(&x) .",
    "6.5.2.3.  Get the Next Prime Number #",
    "To implement void nextPrimeNumber(int*); , we need to first think of how to find the next prime number.",
    "Step 1: Toy example.",
    "For example, the next prime number after \\(3\\) is \\(5\\) .",
    "Step 2: Think of a solution and decompose into steps.",
    "The next number after \\(3\\) is \\(4\\) , but it is not prime number.",
    "We can continue advancing to \\(5\\) and then checking if it is prime! Given that, the steps to get the next prime number are",
    "Add \\(1\\) to that value",
    "Check if it is prime",
    "Repeat \\(1\\) – \\(2\\) till value becomes a prime number",
    "Step 3: Write the code.",
    "The following code implements the steps discussed.",
    "Caution! We are receiving the address of a int , which is int* .",
    "In line \\(5\\) , we check if value is prime or not using isPrime function, which we know it will return true if value is prime and false otherwise.",
    "!isPrime(value) is true as long as value is not prime.",
    "Once value is prime, !isPrime(value) becomes false , and we exit the loop.",
    "In line \\(8\\) , we are not returning any values because nextPrimeNumber does not return any number.",
    "Instead, we change the value at address px to the prime number we found next.",
    "Step 4: Test your code in isolation.",
    "You should be testing your code when called only by the main function to see if it works.",
    "6.5.2.4.  Find If a Number Is Prime or Not #",
    "To implement bool isPrime(int); , we need to first think of how to know if a number is prime.",
    "Step 1: Toy example.",
    "For example, \\(12\\) is not a prime number.",
    "Step 2: Think of a solution and decompose into steps.",
    "We know that a prime number num is divisible only by \\(1\\) and num .",
    "This means that between \\(2\\) and the num - 1 there are no divisibles of num .",
    "We can do the following steps to see if num is prime:",
    "Denominator denom is set to \\(2\\)",
    "Find if num / \\(2\\) gives no remainder , i.e. num % denom == 0",
    "If num % denom == 0 , then num is not prime, because it is divisible by denom .",
    "Otherwise, add \\(1\\) to denom",
    "Repeat \\(2\\) – \\(4\\) , until either you found out num is not prime, or when num % denom == 0 has been checked on all denom values from \\(2\\) to num - 1 and was never true .",
    "This is when num is true .",
    "Repeat \\(2\\) – \\(4\\) , until either you found out num is not prime, or when num % denom == 0 has been checked on all denom values from \\(2\\) to num - 1 and was never true .",
    "This is when num is true .",
    "Step 4: Write pseudo-code.",
    "Step 3: Write the code.",
    "To implement the bool isPrime(int); , we will convert the pseudo-code into code.",
    "Step 4: Test your function in isolation.",
    "Think of numbers to test your function.",
    "Numbers less than, greater than or equal to 2.",
    "Does the function work with numbers less than 2 ?",
    "Line \\(6\\) will set prime to false .",
    "Does the function work with numbers less than 2 ?",
    "Line \\(6\\) will set prime to false .",
    "Does the function work with 2 ?",
    "In line \\(8\\) , denom starts from \\(2\\) , and then denom is checked with num - 1 .",
    "The condition denom <= num - 1 is false if num is set to \\(2\\) .",
    "Hence, the function will return the preset value of prime , which is true .",
    "Does the function work with 2 ?",
    "In line \\(8\\) , denom starts from \\(2\\) , and then denom is checked with num - 1 .",
    "The condition denom <= num - 1 is false if num is set to \\(2\\) .",
    "Hence, the function will return the preset value of prime , which is true .",
    "Does the function work with numbers above 2 ?",
    "In lines \\(8\\) – 10, the function will set prime to false if num is divisible by another number between \\(2\\) and num - 1 .",
    "It will exist the loop because this condition denom <= num - 1 && prime becomes false .",
    "The function will not change prime value if the loop tries over all denom values from \\(2\\) to num - 1 and does not find num to be divisible.",
    "Hence, prime will continue to be true .",
    "Does the function work with numbers above 2 ?",
    "In lines \\(8\\) – 10, the function will set prime to false if num is divisible by another number between \\(2\\) and num - 1 .",
    "It will exist the loop because this condition denom <= num - 1 && prime becomes false .",
    "The function will not change prime value if the loop tries over all denom values from \\(2\\) to num - 1 and does not find num to be divisible.",
    "Hence, prime will continue to be true .",
    "6.5.2.5.  Print If the Conjecture Is Verified #",
    "We need a function that prints if the Goldbach conjecture is verified or rejected! This function can simply call testGoldbach .",
    "If testGoldbach returns true , the function prints the number verifies the conjecture, and prints the number rejects the conjecture otherwise.",
    "These simple steps can be written as follows:",
    "6.5.3.  Integrate all pieces/functions #",
    "In the previous sections, we have divided the steps into two main ones: getting input through getUserInput and printing if the conjecture is verified through printConjResult .",
    "This eases the task of writing the main function.",
    "The main function should only call getUserInput and printConjResult .",
    "This is shown in the following code.",
    "Output 1",
    "Please refer to goldbach-conjecture.c if you want to view the entire program and test it yourself.",
    "Quiz",
    "0 Questions",
    "Inputs to programs are in bold .",
    "7.2.  What are arrays, and how are they stored? #",
    "When you declare an array using the C programming language, all the elements in the array are stored contiguously in the main memory.",
    "For example, in the following figure, an array of \\(3\\) elements is stored in the main memory.",
    "We can see the addresses of each element is separated by \\(4\\) , while we claim that variables are stored contiguously (one after the other).",
    "This is because a int variable is stored using \\(4\\) bytes.",
    "Hence, if x[0] is stored at address \\(72\\) , it will take address \\(73\\) , \\(74\\) and \\(75\\) to store the contents of x[0] .",
    "Then, x[1] will start at address \\(76\\) .",
    "Fig. 7.5  Array elements are stored contiguously in a the main memory. Since the array is byte addressable, if the address of the first element is  \\(72\\) , the address of the second element is  \\(4\\)  bytes after that at  \\(76\\) . Why  \\(4\\)  bytes? This is because a  int  variable is stored in  \\(4\\)  bytes, and if variables will be contiguous, their addresses will be separated by  \\(4\\)  bytes. #",
    "In the figure above, we also say that x is not just the identifier of the array, instead it is also a pointer to the first element in the array.",
    "This means that x is equivalent to &x[0] .",
    "Hence, if we dereference x , we get the first element of the array *x \\(\\rightarrow\\) *(&x[0]) \\(\\rightarrow\\) x[0] .",
    "We can refer to the second element in the array, if we add \\(1\\) to the address of the first element x , i.e. x+1 is equivalent to x[1] .",
    "The following figure summarizes how can x be used as a pointer to different elements in the array.",
    "Fig. 7.6  x  is the identifier of the array, but it can also be used as a pointer to the first element in the array. #",
    "Given that x is a pointer to the first element in the array, we can pass this pointer to a function, and be able to access elements in the array!",
    "7.2.1.  Pointer Arithmetic #",
    "Given that we now understand that an array identifier is also a pointer to the first element in an array.",
    "Within the context of arrays, pointer arithmetic plays an important role in understanding how elements in an array are contiguously stored in the main memory.",
    "For example, if I have an array of \\(3\\) elements, int x[] = {1, 7, 3}; , the addresses in the main memory will look something like in the following figure.",
    "Fig. 7.7  If we get the difference between two addresses of two elements, the result is the difference between the addresses divided by  sizeof(<data   type>)  stored in the address. For example,  dist   =   (80   -   72)   /   sizeof(int)   \\(\\rightarrow\\)   dist   =   8   /   4   =   2 . #",
    "In the above figure, we have in line 6 int *q = &x[2]; .",
    "So q is holding the address of x[2] , which is \\(80\\) .",
    "In line 7, int dist = q - x; , where x is also the address of x[0] .",
    "Hence, dist = &x[2] - &x[0] .",
    "However, we don’t just get the difference between the two addresses.",
    "Instead, we divide the result by sizeof(int) , which is the size of the data stored at these two addresses.",
    "Given that, dist = (80 - 72) / sizeof(int) \\(\\rightarrow\\) dist = 2 .",
    "7.2.2.  Practice Problem #",
    "The following question was question 5 in Winter 2022 midterm exam for APS 105 in the University of Toronto.",
    "The question requires that you print the output of the following program.",
    "In line \\(3\\) , first = 1 , second = 2 , data[0] = 10 , data[1] = 20 , data[2] = 30 , data[3] = 40 .",
    "In line \\(4\\) , third = &second , fourth = &first , fifth = data + first + 1 = &data[0] + first + 1 = &data[0] + 2 = &data[2] .",
    "Here, &data[0] + 2 = &data[2] because adding \\(2\\) to the address of data[0] adds \\(2 \\times\\) sizeof(int) , which is the address of data[2] .",
    "In line \\(5\\) , (*third)++ \\(\\rightarrow\\) second++ , so second = 3 .",
    "In line \\(6\\) , (*fourth)++ \\(\\rightarrow\\) first++ , so first = 2 .",
    "In line \\(7\\) , data[second] = *fifth + first + *third + *fourth = data[2] + 2 + 3 + 2 = 37 .",
    "Hence, data[3] = 37 .",
    "In line \\(8\\) , we print first = 2, second = 3, third = 3, fourth = 2, fifth = 30 .",
    "In line \\(11\\) , we print 10, 20, 30, 37, .",
    "The output is",
    "Quiz",
    "0 Questions",
    "7.4.  Exercises #",
    "Many of these exercises are taken from past exams of APS105 Computer Fundamentals courses at University of Toronto.",
    "The solutions are provided in the answer boxes.",
    "Headings in this page classify the exercises into different categories: [Easy] , [Intermediate] , and [Challenging] .",
    "I suggest you start by easy exercises and work your way up to the challenging ones.",
    "Part of Question 6 in Winter 2020 Midterm Exam [Easy]",
    "The following code segment will cause a runtime error.",
    "Identify the potential runtime error and briefly explain how you would fix it.",
    "Problem: The maximum index for cArray is 4 (array out-of-bounds error).",
    "Solution: Change [5] to [4].",
    "Question 5 in Winter 2022 Midterm Exam [Intermediate]",
    "In the box provided below, write the output generated after the following program is completely executed.",
    "In line 3, first = 1 , second = 2 , data[0] = 10 , data[1] = 20 , data[2] = 30 , data[3] = 40 .",
    "In line 4, third = &second , fourth = &first , fifth = data + first + 1 = &data[0] + first + 1 = &data[2].",
    "In line 5, (*third)++ \\(\\rightarrow\\) second++ , so second = 3 .",
    "In line 6, (*fourth)++ \\(\\rightarrow\\) first++ , so first = 2 .",
    "In line 7, data[second] = *fifth + first + *third + *fourth = data[2] + 2 + 3 + 2 = 37",
    "In line 8, we print first = 2, second = 3, third = 3, fourth = 2, fifth = 30 .",
    "In line 11, we print 10, 20, 30, 37, .",
    "Output is",
    "Question 5 in Winter 2020 Midterm Exam [Intermediate]",
    "What is the output of the following program?",
    "Output is",
    "Question 14 in Winter 2017 Midterm Exam [Intermediate]",
    "Write a complete C program that prompts the user repeatedly for a sequence of up to 10 integer values.",
    "After receiving all 10 values, or if the user enters 0, the program will stop prompting for more values.",
    "You can assume that the user enters at least one value before entering 0.",
    "Your program will complete the following three tasks, in the order as given below, using the values the user entered.",
    "• Print the total number of values entered;",
    "• Print all the values in the order that the user entered them;",
    "• Print whether the values are entered in ascending order, i.e., the next value is either greater than or equal to the previous one.",
    "For example, {3, 4, 7, 7} is a sequence of values in ascending order, but {3, 4, 7, 6} is not.",
    "Hint: you will need to use an array for this question.",
    "Here are a few example runs of your program.",
    "Example run 1:",
    "Example run 2:",
    "Example run 3:",
    "Example run 4:",
    "Question 9 in Winter 2018 Midterm Exam [Intermediate]",
    "The dot product, an operation with which every first-year engineer is familiar, consists of the element-by-element multiplication of two vectors, and the cumulative sum of these resulting products.",
    "If vector \\(a = [a_1, a_2, a_3]\\) , and \\(b = [b_1, b_2, b_3]\\) , then the dot product \\(a · b = a_1 \\times b_1 + a_2 \\times b_2 + a_3 \\times b_3\\) .",
    "Smartphones, which can be found at this very moment in many first-year engineer’s pocket, do perform a similar operation when the treble or the bass are adjusted when the said engineer is enjoying a song.",
    "This operation is called filtering .",
    "Suppose now that you have two vectors, one representing a song, and the other representing a filter.",
    "Write a complete C program that will calculate and print the dot product between these two vectors as a single value.",
    "Your program should simply print:",
    "Your program must use a function, called dotProduct , which takes in pointers to the two vectors and their length, and returns the result.",
    "Before your program calls dotProduct , the two vectors should be initialized using the following elements:",
    "Next time you listen to a song, consider that it is very possible that two 50 element long arrays are being used by a function very similar to the one you will write below, and that function is being called at least once every 48 thousandths of a second, so that you can enjoy that Taylor Swift song.",
    "Okay, make it Justin Bieber, then.",
    "Question 11 in Winter 2018 Midterm Exam [Intermediate]",
    "Recall that the function rand() returns a random integer each time it is called.",
    "Write a complete C program to help assess the quality of rand() , by following the three steps provided below.",
    "First, declare an array with the identifier random that contains \\(1,000\\) int-type integers, and then fill this array with random numbers between \\(0\\) and \\(255\\) (inclusive).",
    "Second, declare another array with the identifier h that contains \\(256\\) integers, and use that array to create a histogram so that at the end of the program, for each i between \\(0\\) and \\(255\\) (inclusive), h[i] will have a value x if exactly x elements of array random have the value i .",
    "Finally, print out the values of all elements of h .",
    "For the sake of convenience, you do not need to seed the random number generator.",
    "(The quality of rand() can then be assessed by someone who uses your program as follows: if the printed-out numbers are all within a small range, then the quality of rand() is pretty good; on the other hand, if the printed-out numbers span a large range, then the quality of rand() is rather poor.)",
    "Question 10 in Winter 2020 Midterm Exam [Intermediate]",
    "Complete the definition of a C function secondLargest whose prototype is shown below.",
    "The function returns the index of the second largest integer in the list array, which contains count elements.",
    "For example, if the list passed to the array is {3, 9, 7, 5, 9, 8, 2, 4, 9} , the function returns 5 , as list[5] contains the second largest integer 8 .",
    "If there are multiple occurrences of the second largest integer, the function returns the first occurrence.",
    "For example, if the list is {3, 8, 3, 5, 9, 8, 2, 3, 8} , the function returns 1 .",
    "If there does not exist a second largest integer (i.e., all integers in the array are of the same value), the function returns -1 .",
    "For the sake of simplicity, you may assume that all integers in the array are positive, and there exists at least one element in the array (i.e., count > 0 ).",
    "If you find a number larger than the largest, update the second largest with the previous largest and the largest with the new largest.",
    "However, if you find a number that is not larger than the largest, but is larger than the second largest, then only update the second largest.",
    "Question 12 in Winter 2020 Midterm Exam [Challenging]",
    "In a Pascal’s Triangle, the first row, row #0, has a single element 1.",
    "Each succeeding row elements are the sum of the two elements just above (if there is only one number just above, then that number is duplicated).",
    "So the first 5 rows (numbering from zero) are:",
    "Looking at the last row, row #4, we have sums: \\(0 + 1\\) , \\(1 + 3\\) , \\(3 + 3\\) , \\(3 + 1\\) , \\(1 + 0\\) (getting the values from the row above) to give us \\(1\\) , \\(4\\) , \\(6\\) , \\(4\\) , \\(1\\) .",
    "If we push this all left we get:",
    "Write a function calculatePascalRowSeven , with the prototype given below, that calculates row#7 (the eighth row) of Pascal’s triangle, iterating from row #0.",
    "Do an in-place calculation, so that the result ends up in pascalRow[] .",
    "Do not use any other array.",
    "The given main() function prints the result.",
    "Calculate each row in the outer loop, and each element in each row in the inner loop.",
    "You need to save pArray[element] in a variable named saveElement because you will not find it to get pArray[element + 1] .",
    "Question 13 in Winter 2018 Midterm Exam [Challenging]",
    "The constant E is defined as a double constant of \\(2.718281828459045\\) .",
    "A first positive integer is called a mirror of a second one if they both contain two digits, and when the two digits in the first integer are flipped, the first integer becomes the second one.",
    "For example, 81 is a mirror of 18 (and vice versa).",
    "Implement a function called firstMirrorInE that returns the first two-digit number found in consecutive digits of E whose mirror have appeared earlier in the sequence of digits.",
    "You should only consider the first 16 digits of E — 2.718281828459045 .",
    "The function returns \\(0\\) if such a mirror pair does not exist in the first 16 consecutive digits of E.",
    "Hint: The firstMirrorInE function should return \\(28\\) , since its mirror, \\(82\\) , has appeared earlier in the sequence of digits.",
    "Your function must not simply return \\(28\\) without doing any work.",
    "It is also incorrect to return \\(81\\) , because even though its mirror, \\(18\\) , appeared previously, \\(81\\) is not the first in the sequence that can be found.",
    "Feel free to declare and implement additional functions when needed.",
    "Question 11 in Winter 2020 Midterm Exam [Challenging]",
    "The Sieve of Eratosthenes is an ancient algorithm for finding prime numbers.",
    "To use this algorithm to find all prime numbers less than a given integer, say 100, we start by making a list of consecutive integers less than \\(100\\) .",
    "We first take \\(p\\) = 2, the smallest prime number, and print it.",
    "We then eliminate all multiples of \\(p\\) less than \\(100\\) in the list, (2 \\(p\\) , 3 \\(p\\) , 4 \\(p\\) , …), from the list, since they are multiples of \\(p\\) and are therefore not prime numbers.",
    "After eliminating the multiples of \\(p\\) , we find the first number after \\(p\\) that has not yet been eliminated, as it must be the next prime number.",
    "We assign this new prime number to \\(p\\) , print it, and eliminate its multiples from the list, and so on.",
    "We repeat this procedure until \\(p^2\\) is greater than or equal to \\(100\\) .",
    "The numbers that remain in the list are prime numbers, and we finish by printing them out.",
    "Write a complete C program that uses the Sieve of Eratosthenes algorithm to print all prime numbers less than 100.",
    "Your implementation must not use the % (modulo) operator.",
    "The output of your program should be:",
    "Hint: Use an array of size \\(100\\) to keep track of whether an integer has been eliminated or not.",
    "7.3.  How do we pass an array to a function? #",
    "To pass an array to a function, all what you need to do is pass the pointer to the first element of the array.",
    "For example, in the following code skeleton, we show how do we pass an array to a function.",
    "Code Skeleton",
    "In line \\(2\\) , the input data type is int [] .",
    "This means that when the function is called, the input will be a pointer to the first element in the array, which is also the array identifier.",
    "In line \\(6\\) , we pass to the function f a pointer to the first element of the array, which is also the array identifier: f(x) .",
    "In line \\(9\\) , the function header will receive the pointer of the first element in the array in list .",
    "Since x in the main function is the pointer to the first element in the array and is the array identifier, list is also pointing to the first element in the array and is the array identifier in function f .",
    "7.3.1.  Size of array in a function is unknown! #",
    "Within the function, we can access elements as we see appropriate.",
    "However, the only problem is that within the function f , the size of the array list is unknown! If we need to loop over all the elements in the array to calculate the sum of the elements, for example, we will not know when to stop incrementing the index.",
    "Hence, we need to pass the size of the array along with the pointer to the first element in the array.",
    "Let’s write a program that finds the sum of the elements in an array.",
    "The program should call a function to calculate the sum of the elements in an array.",
    "This is similar to finding the average of the elements in an array.",
    "In line \\(3\\) , we define the inputs to the function as int[] , which is the type of the pointer to the first element in an array and int , which is the type of the size of the array.",
    "In line \\(13\\) , we receive x in list , and size in main as size in sumData .",
    "In line \\(16\\) , we access the elements of list array as we would do with arrays normally.",
    "Important: list is pointing towards what x is pointing to.",
    "Both are pointing to the first element in the array.",
    "7.3.2.  Can I use the pointer syntax too? #",
    "Since array identifiers are also pointers , is it possible to index elements in the array using pointers instead of [] ?",
    "Yes, it is possible, and we show below how.",
    "In line \\(3\\) , we accept int* instead of int[] , because they are equivalent.",
    "In line \\(13\\) , we accept x into int* list , because they are equivalent.",
    "x is a pointer and list is also a pointer.",
    "In line \\(16\\) , we can access elements in the array by adding i to the pointer list and dereferencing: *(list + i) .",
    "This is because *(list + i) is equivalent to list[i] .",
    "The syntax of pointers – * and & – and syntax of arrays – [] are interchangeable.",
    "This means that we can use any syntax at any time in our program as long as the statements are correct! For example,",
    "In line \\(4\\) , we define the input as a pointer: int* .",
    "However, we set the input in the header of the function as int[] in line \\(15\\) , since int* and int[] are equivalent.",
    "Similarly, in line \\(19\\) , we index in the array list as *(list + index) , since it is equivalent to list[i] .",
    "7.3.3.  Are we passing the array by value or by pointers? #",
    "When we pass arrays to functions, we are technically passing a pointer to the first element in the array.",
    "To better visualize passing an array to a function, watch the following video.",
    "This means that any changes in the array in the function will be reflected in the main or caller function.",
    "For example, let’s write a function that swaps the elements at i and index j in an array.",
    "We will write a function named swap that takes in the array as int list[] , and the two indices of the elements we want to swap: int i and int j .",
    "We also implement a function that prints the elements of the array.",
    "It takes in the array as int list[] and the size of the array as const int size .",
    "In the following code, we print the array x before and after calling the function swap to swap the element at index i = 0 with element at index j = 4 .",
    "As observed, since we are passing to swap the pointer to the first element in the array, any change to the array in the function is also reflected in the caller function.",
    "Quiz",
    "0 Questions",
    "7.  Arrays #",
    "So far, we have been dealing with variables that hold a single value.",
    "In many cases, it is very powerful to deal with many values under the same variable.",
    "It will help us write fewer lines of code.",
    "In this chapter, we discuss variable that hold several values using a single identifier: arrays.",
    "7.1.  Why and how to use arrays? #",
    "Let’s say we have a table containing the grades of all students taking APS 105: Computer Fundamentals course.",
    "Student Name 1 Grade",
    "Muhammad Ali 100",
    "Whitney Houston 95",
    "Elon Musk 67",
    "Malala Yousafzai 99",
    "Steve Jobs 72",
    "Lionel Messi 101",
    "Mohamed Salah 200",
    "Now, I want to calculate the average of the grades.",
    "We can have the grade of each student stored using a int variable.",
    "However, if the students were more than 440, as in APS105, I think as an instructor, I will suffer as I type \\(440\\) + variable names.",
    "Then, I will suffer when summing all these variables to get the average grade.",
    "Dealing with multiple variables is troublesome.",
    "Instead, we can have \\(\\mbox{grade}_1\\) , \\(\\mbox{grade}_2\\) , \\(\\mbox{grade}_3\\) \\(\\dots\\) stored in one vector named \\(\\mbox{grade}\\) as we do in math.",
    "We can easily then deal with all the grades using the vector of name \\(\\mbox{grade}\\) .",
    "Similarly, in C programming language, we can use an array to represent a vector, elements of a table, contents of boxes in a game, cards in a card deck, weights of a neural network, characters in a word or sentence and many more.",
    "To declare an array that can store \\(7\\) grades, we can do the following:",
    "Fig. 7.1  Declare an array with  \\(7\\)   int  type elements. #",
    "To access and initialize different elements inside the array, we need to index the array as follows:",
    "In C programming language, to access the first element, we use an index of 0 , i.e. first element in the grades array is grades[0] .",
    "This makes the last element has an index of one less than the size , i.e. grades[6] is the last element in the grades array.",
    "Please note that the size of the array is still \\(7\\) .",
    "Declare and initialize in the same statement.",
    "To declare and initialize an array in the same statement, we can do the following:",
    "Fig. 7.2  Declare an array with  \\(7\\)   int  type elements, and initialize each element in the array between  {}  curly brackets. #",
    "Notice in the second way, we did not put the size of the array between [] square brackets, because the compiler will deduce the size of the array from the number of element you are initializing between {} curly brackets.",
    "This is only possible when we declare AND initialize in the same statement.",
    "Size of array is fixed!",
    "The size of an array should be a whole number and fixed throughout the entire program.",
    "It cannot be shrunk or extended.",
    "Hence, the size of the array can be stored in a int , and since the size of the array does not change, we can use const int .",
    "In C programming language, you can also set the size of the array as a macro.",
    "A macro is an alias for a value.",
    "It is not a variable.",
    "It has no data type.",
    "It is not stored in memory.",
    "It is only an alias.",
    "For example, you can set up a macro as follows:",
    "When the compiler compiles your code, it will replace all SIZE with 7.",
    "Hence, the macro SIZE is an alias/nickname for \\(7\\) .",
    "The above code is the same as",
    "Code when compiler replaces all SIZE with 7",
    "If you were to set the size of the array as a const int variable, it will look like this:",
    "Code with size of array as const int",
    "Given that we now have an array that holds the grades of a class, let’s write a C program that calculates the average of the elements in this array.",
    "Step 1: Toy example.",
    "An example array having three elements, int array[3] = {1, 2, 3}; .",
    "The sum of the elements is \\(1 + 2 + 3 = 6\\) , and the average is \\(\\frac{6}{3} = 2\\) .",
    "Step 2: Think of a solution! We need to add each element in the array to the summation repeatedly to get the sum of all the elements.",
    "Then we divide the summation by the size of the array.",
    "Step 3: Decompose into steps.",
    "We need a variable that holds the sum of the array.",
    "In each step, we will repeatedly add the elements of the array to sum .",
    "Then get the average by dividing sum by the size of the array.",
    "Set sum to 0.",
    "Set index to 0.",
    "Add to sum the element of the array at index .",
    "Increment index by \\(1\\) .",
    "Repeat \\(3\\) – \\(4\\) until index reaches size of array.",
    "If it happens, we shouldn’t add the element at index = size of the array, since this is beyond the array bounds.",
    "The last element to add is at index = size of array - 1.",
    "Repeat \\(3\\) – \\(4\\) until index reaches size of array.",
    "If it happens, we shouldn’t add the element at index = size of the array, since this is beyond the array bounds.",
    "The last element to add is at index = size of array - 1.",
    "Divide sum by size of array.",
    "Step 4: Write code.",
    "Let’s convert the steps into code.",
    "Download avg-array.c if you want to run the program yourself.",
    "Step 5: Debug your code.",
    "The above code is working fine for the given example.",
    "Some common mistakes that will help you debug your code are:",
    "In line \\(10\\) , instead of going from index = 0 to index = SIZE - 1 , you may do the mistake of for(int index = 0; index <= SIZE; index++) .",
    "Since the condition is index <= SIZE with an equal sign, the index goes from 0 \\(\\rightarrow\\) SIZE .",
    "There is no element at index = SIZE , because the last element is at index = SIZE - 1 .",
    "In line \\(10\\) , instead of going from index = 0 to index = SIZE - 1 , you may do the mistake of for(int index = 0; index <= SIZE; index++) .",
    "Since the condition is index <= SIZE with an equal sign, the index goes from 0 \\(\\rightarrow\\) SIZE .",
    "There is no element at index = SIZE , because the last element is at index = SIZE - 1 .",
    "In line \\(10\\) , some people may start from index = 1 to index = SIZE - 1 or to index = SIZE .",
    "Starting from index = 1 is missing the first element, which is at index 0 .",
    "Hence, you MUST start from index = 0 .",
    "Also, you MUST end at index = SIZE - 1 , since there is no element at index SIZE .",
    "In line \\(10\\) , some people may start from index = 1 to index = SIZE - 1 or to index = SIZE .",
    "Starting from index = 1 is missing the first element, which is at index 0 .",
    "Hence, you MUST start from index = 0 .",
    "Also, you MUST end at index = SIZE - 1 , since there is no element at index SIZE .",
    "In line \\(13\\) , sum is a int and SIZE is a macro with value 7 (no data type).",
    "The result of sum / SIZE should be a int with no numbers after the decimal place.",
    "Hence, to make the result have numbers after the decimal, we need to type cast sum into double .",
    "We learned type cast in Chapter 2.3: Type casting .",
    "In line \\(13\\) , sum is a int and SIZE is a macro with value 7 (no data type).",
    "The result of sum / SIZE should be a int with no numbers after the decimal place.",
    "Hence, to make the result have numbers after the decimal, we need to type cast sum into double .",
    "We learned type cast in Chapter 2.3: Type casting .",
    "Step 6: Test your code.",
    "Try out different values in the array, and different array sizes to ensure the code works for different cases.",
    "7.1.1.  Exercise: Reverse The Elements in an Array #",
    "In this subsection, say we have a few elements in an array that are sorted in ascending order, and we want to reverse these elements as shown in the following figure.",
    "Fig. 7.3  An array before and after reversing. #",
    "Step 1: Toy example.",
    "We can use the above drawing as our example.",
    "Step 2: Think of a solution! We can start by swapping the elements in index \\(0\\) and \\(5\\) , then swap elements at index \\(1\\) and \\(4\\) , then swap elements at index \\(2\\) and \\(3\\) .",
    "We shouldn’t swap elements at index \\(3\\) and \\(2\\) , because we just swapped them.",
    "This is depicted in the figure above.",
    "Step 3: Decompose into steps.",
    "Set variable low to 0 and high to SIZE - 1 .",
    "Swap element at index low with element at index high .",
    "Increment low and decrement high by 1.",
    "Repeat \\(2\\) – \\(3\\) till all elements are swapped, which happens when low becomes higher than high .",
    "But this may not happen if the size of the array is odd, and not even.",
    "For example, in the following figure, the size of the array is even.",
    "We shouldn’t swap, when low becomes 2 and high becomes 2.",
    "Hence, we should stop swapping when low becomes greater than or equal to high .",
    "Repeat \\(2\\) – \\(3\\) till all elements are swapped, which happens when low becomes higher than high .",
    "But this may not happen if the size of the array is odd, and not even.",
    "For example, in the following figure, the size of the array is even.",
    "We shouldn’t swap, when low becomes 2 and high becomes 2.",
    "Hence, we should stop swapping when low becomes greater than or equal to high .",
    "Fig. 7.4  An array with even number of elements before and after reversing. #",
    "Step 4: Write code.",
    "Download reverse-array.c if you want to run the program yourself.",
    "In line \\(10\\) , we initialize low and high in the initialization section of the for loop.",
    "Recall in Chapter 4.3 Variations in for loop , we can do so.",
    "Similarly, in the increment statement, we incremented low and decremented high .",
    "In lines \\(11\\) – \\(13\\) , we did what we did in the swap function in Chapter 6.3: How to use pointers to communicate more with functions?",
    "Step 5: Test your code.",
    "Test your code with odd number of elements, one element, and two elements to ensure it would work in different settings.",
    "7.1.2.  Summary of Important Features of Arrays #",
    "First element exists at index at \\(0\\) .",
    "Size of the array is fixed throughout the program.",
    "If you are declaring and initializing, you don’t need to put the size between [] , because the compiler will deduce the size from the number of elements between {} What happens if you give less elements than size?",
    "For example, int array [ 5 ] = { 1 , 2 }; This is also equivalent to int array [5] = {1, 2, 0, 0, 0}; .",
    "This means that the remaining elements in the array will be set to \\(0\\) .",
    "It happens if we initialize fewer elements than the size of the array.",
    "What happens if you give more elements than size?",
    "For example, int array [ 5 ] = { 1 , 2 , 3 , 4 , 5 , 6 }; You will get a warning when you compile your code.",
    "The warning will say “warning: excess elements in array initializer”.",
    "This is because you are initializing an excess element in the array.",
    "If you run the program, you may get an undefined behavior.",
    "Possible errors include segmentation fault, bus error or normal operation.",
    "If you are declaring and initializing, you don’t need to put the size between [] , because the compiler will deduce the size from the number of elements between {}",
    "What happens if you give less elements than size?",
    "For example,",
    "This is also equivalent to int array [5] = {1, 2, 0, 0, 0}; .",
    "This means that the remaining elements in the array will be set to \\(0\\) .",
    "It happens if we initialize fewer elements than the size of the array.",
    "What happens if you give more elements than size?",
    "For example,",
    "You will get a warning when you compile your code.",
    "The warning will say “warning: excess elements in array initializer”.",
    "This is because you are initializing an excess element in the array.",
    "If you run the program, you may get an undefined behavior.",
    "Possible errors include segmentation fault, bus error or normal operation.",
    "If you try accessing an element at an index greater than the SIZE of the array, the behavior is undefined.",
    "You may get a segmentation fault, or you may access a memory space having garbage value.",
    "Hence, please ensure that the value of the variable you are using as an index is between \\(0\\) and the size of the array - 1.",
    "If you try accessing an element at an index greater than the SIZE of the array, the behavior is undefined.",
    "You may get a segmentation fault, or you may access a memory space having garbage value.",
    "Hence, please ensure that the value of the variable you are using as an index is between \\(0\\) and the size of the array - 1.",
    "Quiz",
    "0 Questions",
    "All names referred here are fictional character names, and any similarities between these names and reality is probably by coincidence.",
    "4.1.  While Loop #",
    "The while loop is a control flow statement that allows instructions/statements/code to be executed repeatedly based on a given condition.",
    "4.1.1.  What is a while loop? #",
    "The syntax of the while loop is as follows:",
    "Fig. 4.1  The flow chart of a while loop. #",
    "As the above flow chart shows, the execution of the while loop starts by:",
    "Checking the condition of the loop.",
    "If the condition is true , the statements inside the curly braces will be executed.",
    "Repeat 1 and 2 until the condition becomes false .",
    "Once the condition becomes false , the while loop will exit and nothing inside the curly braces will be executed anymore.",
    "The program will continue executing the statements after the while loop.",
    "Once the condition becomes false , the while loop will exit and nothing inside the curly braces will be executed anymore.",
    "The program will continue executing the statements after the while loop.",
    "For example, the following program will print out the numbers \\(1\\) through \\(3\\) .",
    "Fig. 4.2  The execution of a program with a while loop. #",
    "To print numbers \\(1\\) to \\(10\\) , we can change the condition to i <= 10 .",
    "The following program will print out the numbers \\(1\\) through \\(10\\) .",
    "Download while-print-nums.c if you want to run the program yourself.",
    "Write a C program that takes in from the user numbers and calculates the sum of the numbers.",
    "The program should stop when the user enters a negative number.",
    "Step 1: Toy example.",
    "For example, if the user enters 18, 5, 3, 2, 1, -1, the program should print out the sum of the numbers \\(18 + 5 + 2 + 1\\) , which is 29.",
    "Step 2: Think of a solution! The program should repeatedly take in numbers from the user.",
    "Repetition needs a loop.",
    "Repetition is for:",
    "repeatedly entering numbers from the user",
    "repeatedly adding the entered number to the sum.",
    "This is on one condition, if the numbers were positive .",
    "The program should stop when the user enters a negative number .",
    "This is on one condition, if the numbers were positive .",
    "The program should stop when the user enters a negative number .",
    "Step 3: Decompose into steps.",
    "Writing the steps down requires us to write a pseudocode .",
    "Pseudocode is an informal way of writing code that helps programmers develop code without worrying about syntax or details.",
    "Pseudocode is a good way to think about the steps that the program should take.",
    "A potential pseudocode for this program is as follows:",
    "Initialize the sum to zero.",
    "Take in a number from the user.",
    "Check if the number is negative.",
    "If the number is negative, exit the while loop.",
    "Check if the number is negative.",
    "If the number is negative, exit the while loop.",
    "If the number is not negative, add the number to the sum.",
    "Repeat steps 2-4 until the user enters a negative number.",
    "Step 4: Draw your solution.",
    "The following flow chart shows the steps that the program should take.",
    "Fig. 4.3  The flow chart of the while loop exercise that finds the sum of numbers entered by the user until the user enters a negative number. #",
    "Step 5: Write the code.",
    "Download sum-numbers-while.c to get the following code.",
    "Common Confusions!",
    "Should we take the number from the user inside or outside the while loop?",
    "Outside the while loop.",
    "This is because we need to check if the number is negative before we add it to the sum.",
    "If we decide to take in the first number from the user inside the while loop, we would have already passed the condition of the while loop.",
    "Should we initialize the sum to zero?",
    "Yes, we should initialize the sum to zero.",
    "This is because the sum should be zero if the user enters a negative number in the beginning.",
    "If we do not initialize the sum to zero, the sum will be undefined.",
    "Step 6: Test your code.",
    "Test your code with other numbers.",
    "For example, try entering a negative number first.",
    "What happens?",
    "The sum should be 0.",
    "Try entering a zero number.",
    "What happens?",
    "The while loop should not stop and you should be still able to enter numbers.",
    "Kindly, refer to the following video if you want to trace the code above.",
    "4.1.2.  Infinite Loops #",
    "What happens when the condition in the while loop is always true?",
    "The while loop will never stop and the program will never exit.",
    "This is called an infinite loop.",
    "For example, the following program will never stop since i > 0 is always true :",
    "Quiz",
    "0 Questions",
    "4.5.  Debugging for loops #",
    "In this section, we debug an example program that uses a nested loop to print a pattern.",
    "The program is shown below.",
    "We go through common mistakes and types of errors that you might encounter when writing a code with a loop.",
    "4.5.1.  Goal of debugging exercises #",
    "Practice reviewing/reading other people’s code",
    "Fix mistakes in other people’s code (debugging)",
    "See/avoid mistakes in your own code",
    "4.5.2.  Common mistakes #",
    "The first step in debugging is to identify the common mistakes.",
    "Here are some common mistakes that you might make when writing a loop.",
    "Wrong initialization of the loop variable, e.g. , initializing i = 0 instead of i = 1 for a loop that starts from 1.",
    "Did not have a statement that changes the condition appropriately, e.g. , i -= 1 instead of i += 1 .",
    "Using incorrect logical operator, e.g. , used && instead of || or vice versa.",
    "Using uncomfortable loop type, e.g. , using a while loop in case where it is easier to deal with do-while loop.",
    "Missing an = or adding an = in the wrong place, e.g. , having while(x > 0) instead of while ( x >= 0) .",
    "4.5.3.  Debugging a program with a loop #",
    "The following is a code to print a pattern of stars.",
    "The code is shown below.",
    "Download triangle-with-bugs.c to debug the program yourself.",
    "Expected output",
    "Actual Output",
    "You can find the corrected code below.",
    "Download triangle-fixed.c to see the corrected code.",
    "Corrected Code",
    "4.5.4.  Debugging a program with a do-while loop #",
    "The following code is supposed to take input int from the user into maxRange variable, then finds a random prime number between \\(1\\) and maxRange .",
    "However, it has a few bugs that we discuss and fix in the video above.",
    "You can try out debugging the code yourself here before watching the video: random-primeNum-with-bugs.c .",
    "Code with bugs",
    "Download the fixed code: random-primeNum.c .",
    "Fixed code",
    "Quiz",
    "0 Questions",
    "4.6.  Exercises #",
    "Many of these exercises are taken from past exams of APS105 Computer Fundamentals courses at University of Toronto.",
    "The solutions are provided in the answer boxes.",
    "Headings in this page classify the exercises into different categories: [Easy] , [Intermediate] , and [Challenging] .",
    "I suggest you start by easy exercises and work your way up to the challenging ones.",
    "4.6.1.  Loops #",
    "Question 1 in Winter 2022 Final Exam [Easy]",
    "Re-write the following code snippet replacing the for loop with a while loop.",
    "The changes you make should not change the functionality of the code snippet.",
    "Your code snippet should have exactly the same number of variables and the same variable names.",
    "Question 8 in Winter 2022 Final Exam [Easy]",
    "Write a complete C program that calculates and prints the sum of all numbers between \\(1\\) and \\(999\\) (inclusive) that satisfy all the following conditions:",
    "The number is divisible by \\(9\\) .",
    "The number is even.",
    "The ten’s digit of the number is not \\(7\\) .",
    "For example, the ten’s digit in \\(753\\) is \\(5\\) , the ten’s digit of \\(671\\) is \\(7\\) , and the ten’s digit of \\(9\\) is \\(0\\) .",
    "The ten’s digit of the number is not \\(7\\) .",
    "For example, the ten’s digit in \\(753\\) is \\(5\\) , the ten’s digit of \\(671\\) is \\(7\\) , and the ten’s digit of \\(9\\) is \\(0\\) .",
    "Modified version of Question 4 in Winter 2018 Midterm Exam [Intermediate]",
    "Write a C program that prints the most significant digit of a positive int-type integer that is taken from the user.",
    "The program should prompt the user “Enter a number:” and prints “The leading digit is: ” followed by the most significant digit.",
    "For example, if the user input is 987654321 , the program will print 9 .",
    "You can assume that the user always enters a positive integer.",
    "Question 6 in Winter 2020 Midterm Exam [Intermediate]",
    "The value of the mathematical constant \\(e\\) can be expressed using the infinite series: \\( e = 1 + \\frac{1}{1!} + \\frac{1}{2!} + \\frac{1}{3!} + ...\\)",
    "Write a C program that approximates the value of \\(e\\) by approximating \\(1 + \\frac{1}{1!} + \\frac{1}{2!} + \\frac{1}{3!} + ...\\) .",
    "Rather than adding an infinite number of terms, your program should continue adding terms until the value of a term is less than \\(0.001\\) .",
    "Your program should print the approximation to \\(e\\) and the number of terms used to determine the approximation.",
    "The terms in the series are \\(1\\) , \\(\\frac{1}{1!}\\) , \\(\\frac{1}{2!}\\) and so on.",
    "Question 11 in Winter 2018 Midterm Exam [Challenging]",
    "Write a C program that returns a randomly generated prime number between \\(1\\) and a maximum int -type integer, maxRange (inclusive), which is provided as by the user as input, and is assumed to be greater than \\(1\\) .",
    "A prime number is a natural number greater than 1 that cannot be formed by multiplying two smaller natural numbers.",
    "For example, \\(2\\) , \\(3\\) , \\(5\\) , \\(11\\) , and \\(13\\) are all prime numbers.",
    "The program prompts the user “Enter the maximum range: ” to enter the maxRange value and prints “Random prime number generated is ” followed by the randomly generated prime number.",
    "You can assume that the user always enters a positive integer greater than \\(1\\) .",
    "You are not allowed to use arrays or pointer variables in your implementation.",
    "For convenience, you do not need to seed the random number generator.",
    "4.6.2.  Debugging/Finding Errors #",
    "Question 8 in Winter 2018 Midterm Exam[Intermediate]",
    "Identify and correct all compile-time errors you find in the C program below.",
    "Compile-time errors are errors — not warnings — that the compiler will report when compiling the program.",
    "Each line may or may not contain compile-time errors, and there may be more than one error per line.",
    "Code with compile-time errors",
    "Line 5: the scope of i is only within the {} of the do-while loop, so it cannot be used outside the loop in the conditional statement.",
    "Hence, i should be declared before the do-while loop.",
    "More on scope in the next chapter.",
    "Line 8: Missing closing )",
    "Line 10: Commas should be semi-colon",
    "Line 11: Cannot use modulo operator with double values, should be corrected to y = (int) b * j % (int) a; (or declare variable a and b as int)",
    "Line 11: variable y is not declared but used here.",
    "Can be declared with j as int j, y;",
    "4.  Repetition #",
    "In the previous chapter, we discussed how to make decisions in C.",
    "In this chapter, we will discuss how to instruct the computer to repeat instructions.",
    "For example, we might want to print out the numbers 1 through 10.",
    "We could do this by printing out each number individually as in the following statement:",
    "printf(\"1 2 3 4 5 6 7 8 9 10\\n\");",
    "The issue with that is that it is prone to mistakes.",
    "For example, I can mistakenly write \\(5\\) twice.",
    "Also, it is also not very efficient.",
    "If I want to print out the numbers 1 through 100, I would have to write out 100 numbers.",
    "That is a lot of work!",
    "Why do we need loops?",
    "We need loops to repeat a block of code multiple times.",
    "It is efficient and less prone to mistakes.",
    "In this chapter, we will discuss the while , do while and for loops.",
    "4.2.  Do-while loop #",
    "In the previous section, we discussed how to repeat a set of instructions in programming using a while loop.",
    "In this section, we will discuss the do-while loop.",
    "The do-while loop is similar to the while loop.",
    "The only difference is that the do-while loop will always execute at least once , even if the condition is false .",
    "This is because the condition is checked at the end of the loop.",
    "4.2.1.  What is the do-while loop? #",
    "The syntax of the do-while is as follows:",
    "Fig. 4.4  The flow chart of a do-while loop. #",
    "As the above flow chart shows, the execution of the do-while loop starts by:",
    "Executing the statements inside the curly braces.",
    "Checking the condition of the loop.",
    "If the condition is true , repeat 1 and 2 until the condition becomes false .",
    "Once the condition is false , the loop will exit and nothing inside the curly braces will be executed anymore.",
    "The program will continue executing the statements after the do-while loop.",
    "Once the condition is false , the loop will exit and nothing inside the curly braces will be executed anymore.",
    "The program will continue executing the statements after the do-while loop.",
    "Let’s look at an example to study the order of execution.",
    "In the following code, we do the exact same thing as in The execution of a program with a while loop.",
    "We print numbers from \\(1\\) to \\(3\\) .",
    "The only difference is that we use a do-while loop instead of a while loop.",
    "Fig. 4.5  The execution of a program with a do-while loop. #",
    "If we want to print numbers from \\(1\\) to \\(10\\) , we just need to change the condition from i <= 3 to i <= 10 as in the following code.",
    "Download do-while-print-nums.c if you want to run the program yourself.",
    "4.2.2.  Do-while loop vs. while loop #",
    "The main difference between the do-while and the while loop is that the do-while loop will always execute the statements between {} at least once, even if the condition is false .",
    "While the while loop will not execute the statements between {} if the condition is false .",
    "This makes do-while loops useful when we want to execute a set of statements at least once.",
    "For example, we can use a do-while loop to validate user input like in the following exercise.",
    "Write a C program that asks the user to enter a number between \\(1\\) and \\(10\\) .",
    "If the user enters a number that is not between \\(1\\) and \\(10\\) , the program will ask the user to enter a number again.",
    "The program will keep asking the user to enter a number until the user enters a number between \\(1\\) and \\(10\\) .",
    "Once the user enters a number between \\(1\\) and \\(10\\) , the program will print out the number.",
    "Step 1: Toy example.",
    "For example, if the user enters \\(-2\\) , the program will ask the user to enter a number again.",
    "If the user enters \\(5\\) , the program will print out \\(5\\) .",
    "Step 2: Think of a solution! The program should repeatedly take in numbers from the user until the number falls between \\(1\\) and \\(10\\) , i.e. , (num >= 1 && num <= 10) .",
    "Repetition needs a loop.",
    "Repetition is for repeatedly entering numbers from the user.",
    "This is on the condition that the previous numbers entered were outside the bound of 1 and 10, i.e. !(num >= 1 && num <= 10) or (num < 0 || num > 10) .",
    "The program should stop when the user enters a number between \\(1\\) and \\(10\\) .",
    "Step 3: Decompose into steps.",
    "A potential pseudocode for this program is as follows:",
    "Ask the user to enter a number.",
    "Check if the number is between \\(1\\) and \\(10\\) .",
    "Repeat 1 – 2, if the number is not between \\(1\\) and \\(10\\) .",
    "If the number is between \\(1\\) and \\(10\\) , print out the number.",
    "Step 4: Draw your solution (optional).",
    "Fig. 4.6  The flow chart of the do while loop exercise that validates that the user input number is between  \\(1\\)  and  \\(10\\) . #",
    "Step 5: Write the code.",
    "Download validate-input.c to get the following code.",
    "Step 6: Test your code.",
    "Test your code with other numbers.",
    "For example, try a number at the boundary, e.g., \\(1\\) , \\(10\\) , \\(0\\) , \\(11\\) .",
    "Quiz",
    "0 Questions",
    "4.3.  For loops #",
    "In the previous sections, we discussed how to repeat instructions using while and do-while loops.",
    "In this section, we will discuss the for loop.",
    "4.3.1.  Forming the structure of a for loop from a while loop #",
    "Recall the example, where we used while and do-while loops to print numbers between \\(1\\) and \\(3\\) .",
    "In the following code, we highlight the specific structure of the while loop that allows us to go through fixed number of iterations.",
    "The structure highlights three features: initialization, condition, and increment.",
    "Fig. 4.7  The main features of while loop for fixed number of iterations: initialization, condition, and increment. #",
    "The pre-mentioned structure is common, so C has a special loop called the for loop that allows us to write the same code in a more compact way.",
    "The syntax of the for loop is as follows:",
    "Fig. 4.8  The flow chart of a for loop. #",
    "The following figure shows the order of execution in a for loop that prints numbers from \\(1\\) to \\(3\\) .",
    "Fig. 4.9  The execution of a program with a for loop. #",
    "Again if we want to print numbers from \\(1\\) to \\(10\\) , we only change the condition from i <= 3 to i <= 10 .",
    "The following program will print out the numbers \\(1\\) through \\(10\\) using a for loop.",
    "Download for-print-nums.c if you want to run the program yourself.",
    "4.3.2.  Scope of the loop variable #",
    "In the for loop, the initialization and declaration of the loop variable are done in the same statement, e.g. , int i = 1 .",
    "This makes the i variable only visible inside the for loop.",
    "After the for loop, the loop variable is no longer visible.",
    "For example, if we compile the following code, we would get a compilation error.",
    "Code with compilation error",
    "The error in the following figure is because the loop variable i is not visible outside the loop.",
    "We refer to the visibility of the loop variable as the scope of the loop variable.",
    "i is out of scope after the loop.",
    "We will discuss scope more later!",
    "Fig. 4.10  The error message when the loop variable is used outside the loop. #",
    "Solution! If you want to use the loop variable outside the loop, you can declare it outside the loop and initialize it inside the loop.",
    "For example, the following code will compile and run without any error.",
    "Download for-loop-scope.c if you want to run the program yourself.",
    "4.3.3.  Variations in for loop #",
    "You can use the for loop in different ways, including omitting some statements.",
    "You can omit the initialization and/or increment statements.",
    "For example, the following code snippet shows a for loop to print out the numbers \\(1\\) through \\(10\\) without initialization and increment statements.",
    "1 int i = 1 ; // initialization 2 for (; i <= 10 ;) { 3 printf ( \"%d \" , i ); 4 i ++ ; // increment 5 }",
    "You can omit the initialization and/or increment statements.",
    "For example, the following code snippet shows a for loop to print out the numbers \\(1\\) through \\(10\\) without initialization and increment statements.",
    "If the condition in the for loop is empty, then the default is that the condition is true .",
    "For example, the following code snippet with infinitely print * .",
    "1 for (;;) { 2 printf ( \"*\" ); 3 }",
    "If the condition in the for loop is empty, then the default is that the condition is true .",
    "For example, the following code snippet with infinitely print * .",
    "You can have more  complex expressions  in initialization or increment statements. For example, you can have multiple statements in the initialization or increment statements. Multiple statements should be separated by a comma  , . If there were no statements in the body of the loop, the for loop should end with a  ; . For example, the following code snippet will print out the numbers  \\(1\\)  through  \\(3\\) . \n for   ( int   i   =   1 ;   i   <=   3 ;   printf ( \"%d \" ,   i ),   i ++ ) \n    ; \n \n \n The order of execution for such for loop is shown in the following figure. \n \n \n \n Fig. 4.11  The order of execution for a compact for loop. # \n \n \n You can declare and initialize multiple variables in the initialization statement. For example, the following code snippet will print out the timetable of 7. \n Code \n \n  \n #include <stdio.h>  \n  \nint main(void) {\n  for (int i = 1, j = 7; i <= 10; printf(\"7 * %d = %d\\n\", i, j), i += 1, j += 7)\n    ;\n  return 0;\n}",
    "You can have more complex expressions in initialization or increment statements.",
    "For example, you can have multiple statements in the initialization or increment statements.",
    "Multiple statements should be separated by a comma , .",
    "If there were no statements in the body of the loop, the for loop should end with a ; .",
    "For example, the following code snippet will print out the numbers \\(1\\) through \\(3\\) .",
    "The order of execution for such for loop is shown in the following figure.",
    "Fig. 4.11  The order of execution for a compact for loop. #",
    "You can declare and initialize multiple variables in the initialization statement.",
    "For example, the following code snippet will print out the timetable of 7.",
    "You can have complex conditions. The condition can be complex using logical ( && ,  || ,  ! ) and relational operators ( > ,  >= ,  < ,  <= ,  == ,  != ). Conditions cannot be separated using  ,  as the initialization and increment statements can. \n \n Exercise \n Write a C program to print out the squares of the numbers from  \\(1\\)  to  \\(50\\)  or until the square of the number is greater than  \\(200\\) . \n Step 1: Toy example.  The expected output is \n \n1 4 9 16 25 36 49 64 81 100 121 144 169 196\n \n Step 2: Think of a solution!  You can use a for loop to loop over the numbers from  \\(1\\)  to  \\(50\\)  and print their squares. However, there is an additional condition that the square of the number should be less than  \\(200\\) . You can add this condition statement to exit the loop when the condition is not satisfied. \n Step 3: Decompose into steps.  You can decompose the problem into the following steps. \n \n Initialize a number to  \\(1\\) . \n Print the square of the number. \n Increment the number by  \\(1\\) . \n Check if the square of the number is less than  \\(200\\)  and the number is less than  \\(50\\) . \n If the condition is satisfied, go to step 2. Otherwise, exit the loop. \n \n Step 4: Draw your solution (optional).  You can draw your solution to help you write the correct code. The following figure shows the solution. \n \n \n \n Fig. 4.12  The flow chart for the solution. # \n \n \n Step 5: Write the code.  You can write the code as follows. \n Code \n \n \n#include <stdio.h>\n \nint main(void) {\n  for (int num = 1; (num <= 50) && (num * num < 200); num += 1) {\n    printf(\"%d \", num * num);\n  }\n  return 0;\n}\n \n \n Step 6: Test your code.  You can test your code easily by looking at the numbers printed out. 196, which is the last square printed is less than 200. All numbers printed are squares. 196 is a square of 14, which is less than 50. Therefore, the code is  \\(\\sim 100\\%\\)  correct. I have the  \\(\\sim\\)  to encourage you to be  skeptical !",
    "You can have complex conditions.",
    "The condition can be complex using logical ( && , || , ! ) and relational operators ( > , >= , < , <= , == , != ).",
    "Conditions cannot be separated using , as the initialization and increment statements can.",
    "Write a C program to print out the squares of the numbers from \\(1\\) to \\(50\\) or until the square of the number is greater than \\(200\\) .",
    "Step 1: Toy example.",
    "The expected output is",
    "Step 2: Think of a solution! You can use a for loop to loop over the numbers from \\(1\\) to \\(50\\) and print their squares.",
    "However, there is an additional condition that the square of the number should be less than \\(200\\) .",
    "You can add this condition statement to exit the loop when the condition is not satisfied.",
    "Step 3: Decompose into steps.",
    "You can decompose the problem into the following steps.",
    "Initialize a number to \\(1\\) .",
    "Print the square of the number.",
    "Increment the number by \\(1\\) .",
    "Check if the square of the number is less than \\(200\\) and the number is less than \\(50\\) .",
    "If the condition is satisfied, go to step 2.",
    "Otherwise, exit the loop.",
    "If the condition is satisfied, go to step 2.",
    "Otherwise, exit the loop.",
    "Step 4: Draw your solution (optional).",
    "You can draw your solution to help you write the correct code.",
    "The following figure shows the solution.",
    "Fig. 4.12  The flow chart for the solution. #",
    "Step 5: Write the code.",
    "You can write the code as follows.",
    "Step 6: Test your code.",
    "You can test your code easily by looking at the numbers printed out.",
    "196, which is the last square printed is less than 200.",
    "All numbers printed are squares.",
    "196 is a square of 14, which is less than 50.",
    "Therefore, the code is \\(\\sim 100\\%\\) correct.",
    "I have the \\(\\sim\\) to encourage you to be skeptical !",
    "4.3.4.  How to choose the kind of the loop: while, do-while, for? #",
    "You can use the:",
    "for : if you know the number of iterations in advance.",
    "do-while : if you want to test the condition after executing the body of the loop at least once.",
    "while : if you want to test the condition before executing the body of the loop.",
    "Quiz",
    "0 Questions",
    "4.4.  Nested loops #",
    "Just like how if-statements can be nested, loops can be nested too.",
    "Nested loops would be necessary if we decompose a problem into multiple parts, and each part has its own repetition.",
    "For example, in this next exercise, we print multiple lines where each line has different repetition pattern.",
    "4.4.1.  Print a 2 dimensional pattern #",
    "Write a C program that prints the following pattern:",
    "Step 1: Toy example.",
    "The expected output is shown above.",
    "But a more simplified version of the output is printing only three line as follows.",
    "Step 2: Think of a solution! There are two sources of repetition.",
    "The first source of repetition is the number of lines, i.e. , we are printing three lines in the toy example.",
    "The second source of repetition is the number of stars in each line.",
    "In the first line, we are printing 1 * , in the second line, we are printing 2 * s and so on.",
    "We can use a loop to repeat the action of printing lines.",
    "For each line, we can use another loop to repeat the action of printing stars.",
    "In every line, we can print out the number of stars that is equal to the line number.",
    "Step 3: Decompose into steps.",
    "We can decompose the problem into two parts.",
    "The first part is in each line, we print out the number of stars that is equal to the line number.",
    "The second part is to print out all the number of lines.",
    "In other words, we need a loop that repeats printing stars, and another loop that repeats printing lines.",
    "Printing lines can be decomposed into the following steps:",
    "Initialize a variable line to \\(1\\) .",
    "Print out stars equal to the line number.",
    "Increment the variable line by \\(1\\) .",
    "Repeat 2 and 3 until the variable line is greater than number of lines to be printed, e.g. \\(3\\) .",
    "The second step “2.",
    "Print out stars equal to the line number.” can be decomposed into the following steps:",
    "Initialize a variable star to \\(1\\) .",
    "Print out a * .",
    "Increment the value of star by \\(1\\) .",
    "Repeat 2 and 3 until the value of star is greater than the value line .",
    "Step 4: Write the code.",
    "The code is shown below.",
    "Download print-stars-pattern.c if you want to run the program yourself.",
    "Step 5: Test the code.",
    "Try changing 3 to 5 and see what happens.",
    "It should print the following pattern.",
    "Step 6: Debug the code.",
    "It is possible that you do not get the expected output.",
    "Some common mistakes are:",
    "Misplacing the printf(\"\\n\") statement to be in the inner loop.",
    "This will print a new line for every * .",
    "If you did so, the output will look like this: Misplacing printf(\"\\n\") in the inner loop.",
    "#include <stdio.h> int main(void) { for (int line = 1; line <= 3; line += 1) { // loop over lines for (int star = 1; star <= line; star += 1) { // loop over stars in a single line printf(\"*\"); printf(\"\\n\"); // misplaced } } return 0; } Undesired Output * * * * * * It should be placed after the inner loop only when one line is printed out.",
    "Misplacing the printf(\"\\n\") statement to be in the inner loop.",
    "This will print a new line for every * .",
    "If you did so, the output will look like this:",
    "Misplacing printf(\"\\n\") in the inner loop.",
    "Undesired Output",
    "It should be placed after the inner loop only when one line is printed out.",
    "Some people prefer to start line and star from 0 , instead of 1 .",
    "This is perfectly fine, unless you are printing out the number of stars that is equal to the line number.",
    "In that case, you need to change the condition in the outer loop to line < 3 or line <= 2 .",
    "There is no need to change the condition in the inner loop.",
    "This is because line is now already reduced by 1 since it starts from 0 .",
    "Starting line and star from 0 .",
    "#include <stdio.h> int main(void) { for (int line = 0; line < 3; line += 1) { // loop over lines for (int star = 0; star <= line; star += 1) { // loop over stars in a single line printf(\"*\"); } printf(\"\\n\"); } return 0; }",
    "Some people prefer to start line and star from 0 , instead of 1 .",
    "This is perfectly fine, unless you are printing out the number of stars that is equal to the line number.",
    "In that case, you need to change the condition in the outer loop to line < 3 or line <= 2 .",
    "There is no need to change the condition in the inner loop.",
    "This is because line is now already reduced by 1 since it starts from 0 .",
    "Starting line and star from 0 .",
    "4.4.2.  Let’s tweak the pattern a little! #",
    "Write a C program that prints the following pattern with \\(n\\) rows.",
    "\\(n\\) would be taken as input from the user.",
    "In the following pattern, \\(n\\) is set to \\(5\\) .",
    "Step 1: Toy example.",
    "The expected output is shown above.",
    "We can use it as a toy example to develop our solution.",
    "Step 2: Think of a solution! Again, here we need an outer loop for the number of rows to print, and an inner loop for the number of spaces and number of stars to print in each row.",
    "In the following figure, we can see a pattern in the number of spaces and number of stars in each line.",
    "The number of spaces is equal to \\(n\\) - row number and the number of stars is equal to row number.",
    "We will use a loop to print out each row.",
    "For each row, we will use another loop to print out the number of spaces and number of stars.",
    "In every row, we can print out the number of spaces that is equal to \\(n\\) - row number.",
    "Then, we can print the number of stars that is equal to row number.",
    "Fig. 4.13  Pattern of stars/asterisks #",
    "Step 3: Decompose into steps.",
    "We can decompose the problem into two parts.",
    "The first part is to print out the number of rows.",
    "The second part is to print out the number of spaces and number of stars in each line.",
    "The second part can be decomposed into the following steps:",
    "Initialize a variable row to \\(1\\) .",
    "Print out the number of spaces that is equal to \\(n\\) - row number and stars that is equal to row number.",
    "Increment the variable row by \\(1\\) .",
    "Repeat 2 and 3 until the variable row is greater than \\(n\\) for the toy example.",
    "The second step “2.",
    "Print out the number of spaces that is equal to \\(n\\) - row number and stars that is equal to row number” can be decomposed into the following steps:",
    "Initialize a variable column to \\(1\\) .",
    "Print a space if the value of column is less than or equal to \\(n\\) - row number.",
    "Otherwise, print out a * .",
    "Increment the variable column by \\(1\\) .",
    "Repeat 2 to 4 until the variable column is greater than \\(n\\) .",
    "Step 4: Write the code.",
    "The code is shown below.",
    "Download reverse-stars-pattern.c if you want to run the program yourself.",
    "Step 5: Test the code.",
    "Test the code with corner numbers that may break your code.",
    "For example, try changing \\(5\\) to \\(1\\) and see what happens.",
    "It should print only one * .",
    "Try changing \\(5\\) to \\(0\\) and see what happens.",
    "It should print nothing.",
    "Step 6: Debug the code.",
    "It is possible that you do not get the expected output.",
    "Some common mistakes in printing patterns were discussed in the previous exercise.",
    "Quiz",
    "0 Questions"
]